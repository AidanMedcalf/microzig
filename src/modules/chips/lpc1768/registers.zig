// generated using svd2zig.py
// DO NOT EDIT
// based on LPC176x5x version 0.2
const mmio = @import("microzig-mmio").mmio;
const Name = "LPC176x5x";
pub const WDT = extern struct {
    pub const Address: u32 = 0x40000000;
    // byte offset: 0 Watchdog mode register. This register determines the basic mode and status of the Watchdog Timer.
    pub const MOD = mmio(Address + 0x00000000, 32, packed struct {
        WDEN: bool, // bit offset: 0 desc: Watchdog enable bit. This bit is Set Only.
        WDRESET: bool, // bit offset: 1 desc: Watchdog reset enable bit. This bit is Set Only. See Table 652.
        WDTOF: bool, // bit offset: 2 desc: Watchdog time-out flag. Set when the watchdog timer times out, cleared by software.
        WDINT: bool, // bit offset: 3 desc: Watchdog interrupt flag. Cleared by software.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Watchdog timer constant register. The value in this register determines the time-out value.
    pub const TC = mmio(Address + 0x00000004, 32, packed struct {
        Count: u32, // bit offset: 0 desc: Watchdog time-out interval.
    });
    // byte offset: 8 Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
    pub const FEED = mmio(Address + 0x00000008, 32, packed struct {
        Feed: u8, // bit offset: 0 desc: Feed value should be 0xAA followed by 0x55.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Watchdog timer value register. This register reads out the current value of the Watchdog timer.
    pub const TV = mmio(Address + 0x0000000c, 32, packed struct {
        Count: u32, // bit offset: 0 desc: Counter timer value.
    });
    // byte offset: 16 Watchdog clock select register.
    pub const CLKSEL = mmio(Address + 0x00000010, 32, packed struct {
        CLKSEL: u2, // bit offset: 0 desc: Selects source of WDT clock
        reserved29: u1 = 0,
        reserved28: u1 = 0,
        reserved27: u1 = 0,
        reserved26: u1 = 0,
        reserved25: u1 = 0,
        reserved24: u1 = 0,
        reserved23: u1 = 0,
        reserved22: u1 = 0,
        reserved21: u1 = 0,
        reserved20: u1 = 0,
        reserved19: u1 = 0,
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LOCK: bool, // bit offset: 31 desc: If this bit is set to one writing to this register does not affect bit 0. The clock source can only be changed by first clearing this bit, then writing the new value of bit 0.
    });
};
pub const TIMER0 = extern struct {
    pub const Address: u32 = 0x40004000;
    // byte offset: 0 Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
    pub const IR = mmio(Address + 0x00000000, 32, packed struct {
        MR0INT: bool, // bit offset: 0 desc: Interrupt flag for match channel 0.
        MR1INT: bool, // bit offset: 1 desc: Interrupt flag for match channel 1.
        MR2INT: bool, // bit offset: 2 desc: Interrupt flag for match channel 2.
        MR3INT: bool, // bit offset: 3 desc: Interrupt flag for match channel 3.
        CR0INT: bool, // bit offset: 4 desc: Interrupt flag for capture channel 0 event.
        CR1INT: bool, // bit offset: 5 desc: Interrupt flag for capture channel 1 event.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    pub const TCR = mmio(Address + 0x00000004, 32, packed struct {
        CEN: bool, // bit offset: 0 desc: When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled.
        CRST: bool, // bit offset: 1 desc: When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    pub const TC = mmio(Address + 0x00000008, 32, packed struct {
        TC: u32, // bit offset: 0 desc: Timer counter value.
    });
    // byte offset: 12 Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
    pub const PR = mmio(Address + 0x0000000c, 32, packed struct {
        PM: u32, // bit offset: 0 desc: Prescale counter maximum value.
    });
    // byte offset: 16 Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    pub const PC = mmio(Address + 0x00000010, 32, packed struct {
        PC: u32, // bit offset: 0 desc: Prescale counter value.
    });
    // byte offset: 20 Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    pub const MCR = mmio(Address + 0x00000014, 32, packed struct {
        MR0I: bool, // bit offset: 0 desc: Interrupt on MR0
        MR0R: bool, // bit offset: 1 desc: Reset on MR0
        MR0S: bool, // bit offset: 2 desc: Stop on MR0
        MR1I: bool, // bit offset: 3 desc: Interrupt on MR1
        MR1R: bool, // bit offset: 4 desc: Reset on MR1
        MR1S: bool, // bit offset: 5 desc: Stop on MR1
        MR2I: bool, // bit offset: 6 desc: Interrupt on MR2
        MR2R: bool, // bit offset: 7 desc: Reset on MR2
        MR2S: bool, // bit offset: 8 desc: Stop on MR2.
        MR3I: bool, // bit offset: 9 desc: Interrupt on MR3
        MR3R: bool, // bit offset: 10 desc: Reset on MR3
        MR3S: bool, // bit offset: 11 desc: Stop on MR3
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 40 Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    pub const CCR = mmio(Address + 0x00000028, 32, packed struct {
        CAP0RE: bool, // bit offset: 0 desc: Capture on CAPn.0 rising edge
        CAP0FE: bool, // bit offset: 1 desc: Capture on CAPn.0 falling edge
        CAP0I: bool, // bit offset: 2 desc: Interrupt on CAPn.0 event
        CAP1RE: bool, // bit offset: 3 desc: Capture on CAPn.1 rising edge
        CAP1FE: bool, // bit offset: 4 desc: Capture on CAPn.1 falling edge
        CAP1I: bool, // bit offset: 5 desc: Interrupt on CAPn.1 event
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 48 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 60 External Match Register. The EMR controls the external match pins.
    pub const EMR = mmio(Address + 0x0000003c, 32, packed struct {
        EM0: bool, // bit offset: 0 desc: External Match 0. When a match occurs between the TC and MR0, this bit can either toggle, go low, go high, or do nothing, depending on bits 5:4 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM1: bool, // bit offset: 1 desc: External Match 1. When a match occurs between the TC and MR1, this bit can either toggle, go low, go high, or do nothing, depending on bits 7:6 of this register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner (0 = low, 1 = high).
        EM2: bool, // bit offset: 2 desc: External Match 2. When a match occurs between the TC and MR2, this bit can either toggle, go low, go high, or do nothing, depending on bits 9:8 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM3: bool, // bit offset: 3 desc: External Match 3. When a match occurs between the TC and MR3, this bit can either toggle, go low, go high, or do nothing, depending on bits 11:10 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EMC0: u2, // bit offset: 4 desc: External Match Control 0. Determines the functionality of External Match 0.
        EMC1: u2, // bit offset: 6 desc: External Match Control 1. Determines the functionality of External Match 1.
        EMC2: u2, // bit offset: 8 desc: External Match Control 2. Determines the functionality of External Match 2.
        EMC3: u2, // bit offset: 10 desc: External Match Control 3. Determines the functionality of External Match 3.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    pub const CTCR = mmio(Address + 0x00000070, 32, packed struct {
        CTMODE: u2, // bit offset: 0 desc: Counter/Timer Mode This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale Register.
        CINSEL: u2, // bit offset: 2 desc: Count Input Select When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected for a particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture Control Register (TnCCR) must be programmed as 000. However, capture and/or interrupt can be selected for the other 3 CAPn inputs in the same timer.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const TIMER1 = extern struct {
    pub const Address: u32 = 0x40008000;
    // byte offset: 0 Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
    pub const IR = mmio(Address + 0x00000000, 32, packed struct {
        MR0INT: bool, // bit offset: 0 desc: Interrupt flag for match channel 0.
        MR1INT: bool, // bit offset: 1 desc: Interrupt flag for match channel 1.
        MR2INT: bool, // bit offset: 2 desc: Interrupt flag for match channel 2.
        MR3INT: bool, // bit offset: 3 desc: Interrupt flag for match channel 3.
        CR0INT: bool, // bit offset: 4 desc: Interrupt flag for capture channel 0 event.
        CR1INT: bool, // bit offset: 5 desc: Interrupt flag for capture channel 1 event.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    pub const TCR = mmio(Address + 0x00000004, 32, packed struct {
        CEN: bool, // bit offset: 0 desc: When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled.
        CRST: bool, // bit offset: 1 desc: When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    pub const TC = mmio(Address + 0x00000008, 32, packed struct {
        TC: u32, // bit offset: 0 desc: Timer counter value.
    });
    // byte offset: 12 Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
    pub const PR = mmio(Address + 0x0000000c, 32, packed struct {
        PM: u32, // bit offset: 0 desc: Prescale counter maximum value.
    });
    // byte offset: 16 Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    pub const PC = mmio(Address + 0x00000010, 32, packed struct {
        PC: u32, // bit offset: 0 desc: Prescale counter value.
    });
    // byte offset: 20 Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    pub const MCR = mmio(Address + 0x00000014, 32, packed struct {
        MR0I: bool, // bit offset: 0 desc: Interrupt on MR0
        MR0R: bool, // bit offset: 1 desc: Reset on MR0
        MR0S: bool, // bit offset: 2 desc: Stop on MR0
        MR1I: bool, // bit offset: 3 desc: Interrupt on MR1
        MR1R: bool, // bit offset: 4 desc: Reset on MR1
        MR1S: bool, // bit offset: 5 desc: Stop on MR1
        MR2I: bool, // bit offset: 6 desc: Interrupt on MR2
        MR2R: bool, // bit offset: 7 desc: Reset on MR2
        MR2S: bool, // bit offset: 8 desc: Stop on MR2.
        MR3I: bool, // bit offset: 9 desc: Interrupt on MR3
        MR3R: bool, // bit offset: 10 desc: Reset on MR3
        MR3S: bool, // bit offset: 11 desc: Stop on MR3
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 24 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 40 Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    pub const CCR = mmio(Address + 0x00000028, 32, packed struct {
        CAP0RE: bool, // bit offset: 0 desc: Capture on CAPn.0 rising edge
        CAP0FE: bool, // bit offset: 1 desc: Capture on CAPn.0 falling edge
        CAP0I: bool, // bit offset: 2 desc: Interrupt on CAPn.0 event
        CAP1RE: bool, // bit offset: 3 desc: Capture on CAPn.1 rising edge
        CAP1FE: bool, // bit offset: 4 desc: Capture on CAPn.1 falling edge
        CAP1I: bool, // bit offset: 5 desc: Interrupt on CAPn.1 event
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 44 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 48 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 48 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 60 External Match Register. The EMR controls the external match pins.
    pub const EMR = mmio(Address + 0x0000003c, 32, packed struct {
        EM0: bool, // bit offset: 0 desc: External Match 0. When a match occurs between the TC and MR0, this bit can either toggle, go low, go high, or do nothing, depending on bits 5:4 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM1: bool, // bit offset: 1 desc: External Match 1. When a match occurs between the TC and MR1, this bit can either toggle, go low, go high, or do nothing, depending on bits 7:6 of this register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner (0 = low, 1 = high).
        EM2: bool, // bit offset: 2 desc: External Match 2. When a match occurs between the TC and MR2, this bit can either toggle, go low, go high, or do nothing, depending on bits 9:8 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM3: bool, // bit offset: 3 desc: External Match 3. When a match occurs between the TC and MR3, this bit can either toggle, go low, go high, or do nothing, depending on bits 11:10 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EMC0: u2, // bit offset: 4 desc: External Match Control 0. Determines the functionality of External Match 0.
        EMC1: u2, // bit offset: 6 desc: External Match Control 1. Determines the functionality of External Match 1.
        EMC2: u2, // bit offset: 8 desc: External Match Control 2. Determines the functionality of External Match 2.
        EMC3: u2, // bit offset: 10 desc: External Match Control 3. Determines the functionality of External Match 3.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    pub const CTCR = mmio(Address + 0x00000070, 32, packed struct {
        CTMODE: u2, // bit offset: 0 desc: Counter/Timer Mode This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale Register.
        CINSEL: u2, // bit offset: 2 desc: Count Input Select When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected for a particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture Control Register (TnCCR) must be programmed as 000. However, capture and/or interrupt can be selected for the other 3 CAPn inputs in the same timer.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const UART0 = extern struct {
    pub const Address: u32 = 0x4000c000;
    // byte offset: 0 Receiver Buffer Register. Contains the next received character to be read (DLAB =0).
    pub const RBR = mmio(Address + 0x00000000, 32, packed struct {
        RBR: u8, // bit offset: 0 desc: The UARTn Receiver Buffer Register contains the oldest received byte in the UARTn Rx FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 Transmit Holding Regiter. The next character to be transmitted is written here (DLAB =0).
    pub const THR = mmio(Address + 0x00000000, 32, packed struct {
        THR: u8, // bit offset: 0 desc: Writing to the UARTn Transmit Holding Register causes the data to be stored in the UARTn transmit FIFO. The byte will be sent when it reaches the bottom of the FIFO and the transmitter is available.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
    pub const DLL = mmio(Address + 0x00000000, 32, packed struct {
        DLLSB: u8, // bit offset: 0 desc: The UARTn Divisor Latch LSB Register, along with the UnDLM register, determines the baud rate of the UARTn.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
    pub const DLM = mmio(Address + 0x00000004, 32, packed struct {
        DLMSB: u8, // bit offset: 0 desc: The UARTn Divisor Latch MSB Register, along with the U0DLL register, determines the baud rate of the UARTn.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts (DLAB =0).
    pub const IER = mmio(Address + 0x00000004, 32, packed struct {
        RBRIE: bool, // bit offset: 0 desc: RBR Interrupt Enable. Enables the Receive Data Available interrupt for UARTn. It also controls the Character Receive Time-out interrupt.
        THREIE: bool, // bit offset: 1 desc: THRE Interrupt Enable. Enables the THRE interrupt for UARTn. The status of this can be read from UnLSR[5].
        RXIE: bool, // bit offset: 2 desc: RX Line Status Interrupt Enable. Enables the UARTn RX line status interrupts. The status of this interrupt can be read from UnLSR[4:1].
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABEOINTEN: bool, // bit offset: 8 desc: Enables the end of auto-baud interrupt.
        ABTOINTEN: bool, // bit offset: 9 desc: Enables the auto-baud time-out interrupt.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Interrupt ID Register. Identifies which interrupt(s) are pending.
    pub const IIR = mmio(Address + 0x00000008, 32, packed struct {
        INTSTATUS: bool, // bit offset: 0 desc: Interrupt status. Note that UnIIR[0] is active low. The pending interrupt can be determined by evaluating UnIIR[3:1].
        INTID: u3, // bit offset: 1 desc: Interrupt identification. UnIER[3:1] identifies an interrupt corresponding to the UARTn Rx or TX FIFO. All other combinations of UnIER[3:1] not listed below are reserved (000,100,101,111).
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        FIFOENABLE: u2, // bit offset: 6 desc: Copies of UnFCR[0].
        ABEOINT: bool, // bit offset: 8 desc: End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled.
        ABTOINT: bool, // bit offset: 9 desc: Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 FIFO Control Register. Controls UART FIFO usage and modes.
    pub const FCR = mmio(Address + 0x00000008, 32, packed struct {
        FIFOEN: bool, // bit offset: 0 desc: FIFO Enable.
        RXFIFORES: bool, // bit offset: 1 desc: RX FIFO Reset.
        TXFIFORES: bool, // bit offset: 2 desc: TX FIFO Reset.
        DMAMODE: bool, // bit offset: 3 desc: DMA Mode Select. When the FIFO enable (bit 0 of this register) is set, this bit selects the DMA mode. See Section 18.6.6.1.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXTRIGLVL: u2, // bit offset: 6 desc: RX Trigger Level. These two bits determine how many receiver UARTn FIFO characters must be written before an interrupt or DMA request is activated.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Line Control Register. Contains controls for frame formatting and break generation.
    pub const LCR = mmio(Address + 0x0000000c, 32, packed struct {
        WLS: u2, // bit offset: 0 desc: Word Length Select.
        SBS: bool, // bit offset: 2 desc: Stop Bit Select
        PE: bool, // bit offset: 3 desc: Parity Enable.
        PS: u2, // bit offset: 4 desc: Parity Select
        BC: bool, // bit offset: 6 desc: Break Control
        DLAB: bool, // bit offset: 7 desc: Divisor Latch Access Bit
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Line Status Register. Contains flags for transmit and receive status, including line errors.
    pub const LSR = mmio(Address + 0x00000014, 32, packed struct {
        RDR: bool, // bit offset: 0 desc: Receiver Data Ready. UnLSR[0] is set when the UnRBR holds an unread character and is cleared when the UARTn RBR FIFO is empty.
        OE: bool, // bit offset: 1 desc: Overrun Error. The overrun error condition is set as soon as it occurs. An UnLSR read clears UnLSR[1]. UnLSR[1] is set when UARTn RSR has a new character assembled and the UARTn RBR FIFO is full. In this case, the UARTn RBR FIFO will not be overwritten and the character in the UARTn RSR will be lost.
        PE: bool, // bit offset: 2 desc: Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. An UnLSR read clears UnLSR[2]. Time of parity error detection is dependent on UnFCR[0]. Note: A parity error is associated with the character at the top of the UARTn RBR FIFO.
        FE: bool, // bit offset: 3 desc: Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. An UnLSR read clears UnLSR[3]. The time of the framing error detection is dependent on UnFCR[0]. Upon detection of a framing error, the Rx will attempt to resynchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UARTn RBR FIFO.
        BI: bool, // bit offset: 4 desc: Break Interrupt. When RXDn is held in the spacing state (all zeroes) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXDn goes to marking state (all ones). An UnLSR read clears this status bit. The time of break detection is dependent on UnFCR[0]. Note: The break interrupt is associated with the character at the top of the UARTn RBR FIFO.
        THRE: bool, // bit offset: 5 desc: Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UARTn THR and is cleared on a UnTHR write.
        TEMT: bool, // bit offset: 6 desc: Transmitter Empty. TEMT is set when both UnTHR and UnTSR are empty; TEMT is cleared when either the UnTSR or the UnTHR contain valid data.
        RXFE: bool, // bit offset: 7 desc: Error in RX FIFO . UnLSR[7] is set when a character with a Rx error such as framing error, parity error or break interrupt, is loaded into the UnRBR. This bit is cleared when the UnLSR register is read and there are no subsequent errors in the UARTn FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Scratch Pad Register. 8-bit temporary storage for software.
    pub const SCR = mmio(Address + 0x0000001c, 32, packed struct {
        PAD: u8, // bit offset: 0 desc: A readable, writable byte.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 Auto-baud Control Register. Contains controls for the auto-baud feature.
    pub const ACR = mmio(Address + 0x00000020, 32, packed struct {
        START: bool, // bit offset: 0 desc: Start bit. This bit is automatically cleared after auto-baud completion.
        MODE: bool, // bit offset: 1 desc: Auto-baud mode select bit.
        AUTORESTART: bool, // bit offset: 2 desc: Restart bit.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABEOINTCLR: bool, // bit offset: 8 desc: End of auto-baud interrupt clear bit (write-only accessible). Writing a 1 will clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
        ABTOINTCLR: bool, // bit offset: 9 desc: Auto-baud time-out interrupt clear bit (write-only accessible). Writing a 1 will clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Fractional Divider Register. Generates a clock input for the baud rate divider.
    pub const FDR = mmio(Address + 0x00000028, 32, packed struct {
        DIVADDVAL: u4, // bit offset: 0 desc: Baud-rate generation pre-scaler divisor value. If this field is 0, fractional baud-rate generator will not impact the UARTn baudrate.
        MULVAL: u4, // bit offset: 4 desc: Baud-rate pre-scaler multiplier value. This field must be greater or equal 1 for UARTn to operate properly, regardless of whether the fractional baud-rate generator is used or not.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 Transmit Enable Register. Turns off UART transmitter for use with software flow control.
    pub const TER = mmio(Address + 0x00000030, 32, packed struct {
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TXEN: bool, // bit offset: 7 desc: When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit is cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software implementing software-handshaking can clear this bit when it receives an XOFF character (DC3). Software can set this bit again when it receives an XON (DC1) character.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 76 RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
    pub const RS485CTRL = mmio(Address + 0x0000004c, 32, packed struct {
        NMMEN: bool, // bit offset: 0 desc: NMM enable.
        RXDIS: bool, // bit offset: 1 desc: Receiver enable.
        AADEN: bool, // bit offset: 2 desc: AAD enable.
        reserved1: u1 = 0,
        DCTRL: bool, // bit offset: 4 desc: Direction control enable.
        OINV: bool, // bit offset: 5 desc: Direction control pin polarity. This bit reverses the polarity of the direction control signal on the Un_OE pin.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 80 RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
    pub const RS485ADRMATCH = mmio(Address + 0x00000050, 32, packed struct {
        ADRMATCH: u8, // bit offset: 0 desc: Contains the address match value.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 84 RS-485/EIA-485 direction control delay.
    pub const RS485DLY = mmio(Address + 0x00000054, 32, packed struct {
        DLY: u8, // bit offset: 0 desc: Contains the direction control (UnOE) delay value. This register works in conjunction with an 8-bit counter.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const UART1 = extern struct {
    pub const Address: u32 = 0x40010000;
    // byte offset: 0 DLAB =0 Receiver Buffer Register. Contains the next received character to be read.
    pub const RBR = mmio(Address + 0x00000000, 32, packed struct {
        RBR: u8, // bit offset: 0 desc: The UART1 Receiver Buffer Register contains the oldest received byte in the UART1 RX FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 DLAB =0. Transmit Holding Register. The next character to be transmitted is written here.
    pub const THR = mmio(Address + 0x00000000, 32, packed struct {
        THR: u8, // bit offset: 0 desc: Writing to the UART1 Transmit Holding Register causes the data to be stored in the UART1 transmit FIFO. The byte will be sent when it reaches the bottom of the FIFO and the transmitter is available.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 DLAB =1. Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider.
    pub const DLL = mmio(Address + 0x00000000, 32, packed struct {
        DLLSB: u8, // bit offset: 0 desc: The UART1 Divisor Latch LSB Register, along with the U1DLM register, determines the baud rate of the UART1.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 DLAB =1. Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider.
    pub const DLM = mmio(Address + 0x00000004, 32, packed struct {
        DLMSB: u8, // bit offset: 0 desc: The UART1 Divisor Latch MSB Register, along with the U1DLL register, determines the baud rate of the UART1.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 DLAB =0. Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART1 interrupts.
    pub const IER = mmio(Address + 0x00000004, 32, packed struct {
        RBRIE: bool, // bit offset: 0 desc: RBR Interrupt Enable. Enables the Receive Data Available interrupt for UART1. It also controls the Character Receive Time-out interrupt.
        THREIE: bool, // bit offset: 1 desc: THRE Interrupt Enable. Enables the THRE interrupt for UART1. The status of this interrupt can be read from LSR[5].
        RXIE: bool, // bit offset: 2 desc: RX Line Interrupt Enable. Enables the UART1 RX line status interrupts. The status of this interrupt can be read from LSR[4:1].
        MSIE: bool, // bit offset: 3 desc: Modem Status Interrupt Enable. Enables the modem interrupt. The status of this interrupt can be read from MSR[3:0].
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        CTSIE: bool, // bit offset: 7 desc: CTS Interrupt Enable. If auto-cts mode is enabled this bit enables/disables the modem status interrupt generation on a CTS1 signal transition. If auto-cts mode is disabled a CTS1 transition will generate an interrupt if Modem Status Interrupt Enable (IER[3]) is set. In normal operation a CTS1 signal transition will generate a Modem Status Interrupt unless the interrupt has been disabled by clearing the IER[3] bit in the IER register. In auto-cts mode a transition on the CTS1 bit will trigger an interrupt only if both the IER[3] and IER[7] bits are set.
        ABEOIE: bool, // bit offset: 8 desc: Enables the end of auto-baud interrupt.
        ABTOIE: bool, // bit offset: 9 desc: Enables the auto-baud time-out interrupt.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Interrupt ID Register. Identifies which interrupt(s) are pending.
    pub const IIR = mmio(Address + 0x00000008, 32, packed struct {
        INTSTATUS: bool, // bit offset: 0 desc: Interrupt status. Note that IIR[0] is active low. The pending interrupt can be determined by evaluating IIR[3:1].
        INTID: u3, // bit offset: 1 desc: Interrupt identification. IER[3:1] identifies an interrupt corresponding to the UART1 Rx or TX FIFO. All other combinations of IER[3:1] not listed below are reserved (100,101,111).
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        FIFOENABLE: u2, // bit offset: 6 desc: Copies of FCR[0].
        ABEOINT: bool, // bit offset: 8 desc: End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled.
        ABTOINT: bool, // bit offset: 9 desc: Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 FIFO Control Register. Controls UART1 FIFO usage and modes.
    pub const FCR = mmio(Address + 0x00000008, 32, packed struct {
        FIFOEN: bool, // bit offset: 0 desc: FIFO enable.
        RXFIFORES: bool, // bit offset: 1 desc: RX FIFO Reset.
        TXFIFORES: bool, // bit offset: 2 desc: TX FIFO Reset.
        DMAMODE: bool, // bit offset: 3 desc: DMA Mode Select. When the FIFO enable bit (bit 0 of this register) is set, this bit selects the DMA mode. See Section 36.6.6.1.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXTRIGLVL: u2, // bit offset: 6 desc: RX Trigger Level. These two bits determine how many receiver UART1 FIFO characters must be written before an interrupt is activated.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Line Control Register. Contains controls for frame formatting and break generation.
    pub const LCR = mmio(Address + 0x0000000c, 32, packed struct {
        WLS: u2, // bit offset: 0 desc: Word Length Select.
        SBS: bool, // bit offset: 2 desc: Stop Bit Select.
        PE: bool, // bit offset: 3 desc: Parity Enable.
        PS: u2, // bit offset: 4 desc: Parity Select.
        BC: bool, // bit offset: 6 desc: Break Control.
        DLAB: bool, // bit offset: 7 desc: Divisor Latch Access Bit (DLAB)
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 Modem Control Register. Contains controls for flow control handshaking and loopback mode.
    pub const MCR = mmio(Address + 0x00000010, 32, packed struct {
        DTRCTRL: bool, // bit offset: 0 desc: DTR Control. Source for modem output pin, DTR. This bit reads as 0 when modem loopback mode is active.
        RTSCTRL: bool, // bit offset: 1 desc: RTS Control. Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LMS: bool, // bit offset: 4 desc: Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD1, has no effect on loopback and output pin, TXD1 is held in marking state. The 4 modem inputs (CTS, DSR, RI and DCD) are disconnected externally. Externally, the modem outputs (RTS, DTR) are set inactive. Internally, the 4 modem outputs are connected to the 4 modem inputs. As a result of these connections, the upper 4 bits of the MSR will be driven by the lower 4 bits of the MCR rather than the 4 modem inputs in normal mode. This permits modem status interrupts to be generated in loopback mode by writing the lower 4 bits of MCR.
        reserved2: u1 = 0,
        RTSEN: bool, // bit offset: 6 desc: RTS enable.
        CTSEN: bool, // bit offset: 7 desc: CTS enable.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Line Status Register. Contains flags for transmit and receive status, including line errors.
    pub const LSR = mmio(Address + 0x00000014, 32, packed struct {
        RDR: bool, // bit offset: 0 desc: Receiver Data Ready. LSR[0] is set when the RBR holds an unread character and is cleared when the UART1 RBR FIFO is empty.
        OE: bool, // bit offset: 1 desc: Overrun Error. The overrun error condition is set as soon as it occurs. An LSR read clears LSR[1]. LSR[1] is set when UART1 RSR has a new character assembled and the UART1 RBR FIFO is full. In this case, the UART1 RBR FIFO will not be overwritten and the character in the UART1 RSR will be lost.
        PE: bool, // bit offset: 2 desc: Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. An LSR read clears LSR[2]. Time of parity error detection is dependent on FCR[0]. Note: A parity error is associated with the character at the top of the UART1 RBR FIFO.
        FE: bool, // bit offset: 3 desc: Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. An LSR read clears LSR[3]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to resynchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UART1 RBR FIFO.
        BI: bool, // bit offset: 4 desc: Break Interrupt. When RXD1 is held in the spacing state (all zeroes) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). An LSR read clears this status bit. The time of break detection is dependent on FCR[0]. Note: The break interrupt is associated with the character at the top of the UART1 RBR FIFO.
        THRE: bool, // bit offset: 5 desc: Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UART1 THR and is cleared on a THR write.
        TEMT: bool, // bit offset: 6 desc: Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data.
        RXFE: bool, // bit offset: 7 desc: Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the UART1 FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Modem Status Register. Contains handshake signal status flags.
    pub const MSR = mmio(Address + 0x00000018, 32, packed struct {
        DCTS: bool, // bit offset: 0 desc: Delta CTS. Set upon state change of input CTS. Cleared on an MSR read.
        DDSR: bool, // bit offset: 1 desc: Delta DSR. Set upon state change of input DSR. Cleared on an MSR read.
        TERI: bool, // bit offset: 2 desc: Trailing Edge RI. Set upon low to high transition of input RI. Cleared on an MSR read.
        DDCD: bool, // bit offset: 3 desc: Delta DCD. Set upon state change of input DCD. Cleared on an MSR read.
        CTS: bool, // bit offset: 4 desc: Clear To Send State. Complement of input signal CTS. This bit is connected to MCR[1] in modem loopback mode.
        DSR: bool, // bit offset: 5 desc: Data Set Ready State. Complement of input signal DSR. This bit is connected to MCR[0] in modem loopback mode.
        RI: bool, // bit offset: 6 desc: Ring Indicator State. Complement of input RI. This bit is connected to MCR[2] in modem loopback mode.
        DCD: bool, // bit offset: 7 desc: Data Carrier Detect State. Complement of input DCD. This bit is connected to MCR[3] in modem loopback mode.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Scratch Pad Register. 8-bit temporary storage for software.
    pub const SCR = mmio(Address + 0x0000001c, 32, packed struct {
        Pad: u8, // bit offset: 0 desc: A readable, writable byte.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 Auto-baud Control Register. Contains controls for the auto-baud feature.
    pub const ACR = mmio(Address + 0x00000020, 32, packed struct {
        START: bool, // bit offset: 0 desc: Auto-baud start bit. This bit is automatically cleared after auto-baud completion.
        MODE: bool, // bit offset: 1 desc: Auto-baud mode select bit.
        AUTORESTART: bool, // bit offset: 2 desc: Auto-baud restart bit.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABEOINTCLR: bool, // bit offset: 8 desc: End of auto-baud interrupt clear bit (write-only).
        ABTOINTCLR: bool, // bit offset: 9 desc: Auto-baud time-out interrupt clear bit (write-only).
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Fractional Divider Register. Generates a clock input for the baud rate divider.
    pub const FDR = mmio(Address + 0x00000028, 32, packed struct {
        DIVADDVAL: u4, // bit offset: 0 desc: Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the UART1 baud rate.
        MULVAL: u4, // bit offset: 4 desc: Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for UART1 to operate properly, regardless of whether the fractional baud rate generator is used or not.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 Transmit Enable Register. Turns off UART transmitter for use with software flow control.
    pub const TER = mmio(Address + 0x00000030, 32, packed struct {
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TXEN: bool, // bit offset: 7 desc: When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 76 RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
    pub const RS485CTRL = mmio(Address + 0x0000004c, 32, packed struct {
        NMMEN: bool, // bit offset: 0 desc: RS-485/EIA-485 Normal Multidrop Mode (NMM) mode select.
        RXDIS: bool, // bit offset: 1 desc: Receive enable.
        AADEN: bool, // bit offset: 2 desc: Auto Address Detect (AAD) enable.
        SEL: bool, // bit offset: 3 desc: Direction control.
        DCTRL: bool, // bit offset: 4 desc: Direction control enable.
        OINV: bool, // bit offset: 5 desc: Polarity. This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 80 RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
    pub const RS485ADRMATCH = mmio(Address + 0x00000050, 32, packed struct {
        ADRMATCH: u8, // bit offset: 0 desc: Contains the address match value.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 84 RS-485/EIA-485 direction control delay.
    pub const RS485DLY = mmio(Address + 0x00000054, 32, packed struct {
        DLY: u8, // bit offset: 0 desc: Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const PWM1 = extern struct {
    pub const Address: u32 = 0x40018000;
    // byte offset: 0 Interrupt Register. The IR can be written to clear interrupts, or read to identify which PWM interrupt sources are pending.
    pub const IR = mmio(Address + 0x00000000, 32, packed struct {
        PWMMR0INT: bool, // bit offset: 0 desc: Interrupt flag for PWM match channel 0.
        PWMMR1INT: bool, // bit offset: 1 desc: Interrupt flag for PWM match channel 1.
        PWMMR2INT: bool, // bit offset: 2 desc: Interrupt flag for PWM match channel 2.
        PWMMR3INT: bool, // bit offset: 3 desc: Interrupt flag for PWM match channel 3.
        PWMCAP0INT: bool, // bit offset: 4 desc: Interrupt flag for capture input 0
        PWMCAP1INT: bool, // bit offset: 5 desc: Interrupt flag for capture input 1 (available in PWM1IR only; this bit is reserved in PWM0IR).
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PWMMR4INT: bool, // bit offset: 8 desc: Interrupt flag for PWM match channel 4.
        PWMMR5INT: bool, // bit offset: 9 desc: Interrupt flag for PWM match channel 5.
        PWMMR6INT: bool, // bit offset: 10 desc: Interrupt flag for PWM match channel 6.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Timer Control Register. The TCR is used to control the Timer Counter functions.
    pub const TCR = mmio(Address + 0x00000004, 32, packed struct {
        CE: bool, // bit offset: 0 desc: Counter Enable
        CR: bool, // bit offset: 1 desc: Counter Reset
        reserved1: u1 = 0,
        PWMEN: bool, // bit offset: 3 desc: PWM Enable
        MDIS: bool, // bit offset: 4 desc: Master Disable (PWM0 only). The two PWMs may be synchronized using the Master Disable control bit. The Master disable bit of the Master PWM (PWM0 module) controls a secondary enable input to both PWMs, as shown in Figure 141. This bit has no function in the Slave PWM (PWM1).
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    pub const TC = mmio(Address + 0x00000008, 32, packed struct {
        TC: u32, // bit offset: 0 desc: Timer counter value.
    });
    // byte offset: 12 Prescale Register. Determines how often the PWM counter is incremented.
    pub const PR = mmio(Address + 0x0000000c, 32, packed struct {
        PM: u32, // bit offset: 0 desc: Prescale counter maximum value.
    });
    // byte offset: 16 Prescale Counter. Prescaler for the main PWM counter.
    pub const PC = mmio(Address + 0x00000010, 32, packed struct {
        PC: u32, // bit offset: 0 desc: Prescale counter value.
    });
    // byte offset: 20 Match Control Register. The MCR is used to control whether an interrupt is generated and if the PWM counter is reset when a Match occurs.
    pub const MCR = mmio(Address + 0x00000014, 32, packed struct {
        PWMMR0I: bool, // bit offset: 0 desc: Interrupt PWM0
        PWMMR0R: bool, // bit offset: 1 desc: Reset PWM0
        PWMMR0S: bool, // bit offset: 2 desc: Stop PWM0
        PWMMR1I: bool, // bit offset: 3 desc: Interrupt PWM1
        PWMMR1R: bool, // bit offset: 4 desc: Reset PWM1
        PWMMR1S: bool, // bit offset: 5 desc: Stop PWM1
        PWMMR2I: bool, // bit offset: 6 desc: Interrupt PWM0
        PWMMR2R: bool, // bit offset: 7 desc: Reset PWM0
        PWMMR2S: bool, // bit offset: 8 desc: Stop PWM0
        PWMMR3I: bool, // bit offset: 9 desc: Interrupt PWM3
        PWMMR3R: bool, // bit offset: 10 desc: Reset PWM3
        PWMMR3S: bool, // bit offset: 11 desc: Stop PWM0
        PWMMR4I: bool, // bit offset: 12 desc: Interrupt PWM4
        PWMMR4R: bool, // bit offset: 13 desc: Reset PWM4
        PWMMR4S: bool, // bit offset: 14 desc: Stop PWM4
        PWMMR5I: bool, // bit offset: 15 desc: Interrupt PWM5
        PWMMR5R: bool, // bit offset: 16 desc: Reset PWM5
        PWMMR5S: bool, // bit offset: 17 desc: Stop PWM5
        PWMMR6I: bool, // bit offset: 18 desc: Interrupt PWM6
        PWMMR6R: bool, // bit offset: 19 desc: Reset PWM6
        PWMMR6S: bool, // bit offset: 20 desc: Stop PWM6
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
    pub const MR0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
    pub const MR1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
    pub const MR2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
    pub const MR3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 40 Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated for a capture event.
    pub const CCR = mmio(Address + 0x00000028, 32, packed struct {
        CAP0_R: bool, // bit offset: 0 desc: Capture on PWMn_CAP0 rising edge
        CAP0_F: bool, // bit offset: 1 desc: Capture on PWMn_CAP0 falling edge
        CAP0_I: bool, // bit offset: 2 desc: Interrupt on PWMn_CAP0 event
        CAP1_R: bool, // bit offset: 3 desc: Capture on PWMn_CAP1 rising edge. Reserved for PWM0.
        CAP1_F: bool, // bit offset: 4 desc: Capture on PWMn_CAP1 falling edge. Reserved for PWM0.
        CAP1_I: bool, // bit offset: 5 desc: Interrupt on PWMn_CAP1 event. Reserved for PWM0.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 PWM Control Register. Enables PWM outputs and selects either single edge or double edge controlled PWM outputs.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PWMSEL2: bool, // bit offset: 2 desc: PWM[2] output single/double edge mode control.
        PWMSEL3: bool, // bit offset: 3 desc: PWM[3] output edge control.
        PWMSEL4: bool, // bit offset: 4 desc: PWM[4] output edge control.
        PWMSEL5: bool, // bit offset: 5 desc: PWM[5] output edge control.
        PWMSEL6: bool, // bit offset: 6 desc: PWM[6] output edge control.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        PWMENA1: bool, // bit offset: 9 desc: PWM[1] output enable control.
        PWMENA2: bool, // bit offset: 10 desc: PWM[2] output enable control.
        PWMENA3: bool, // bit offset: 11 desc: PWM[3] output enable control.
        PWMENA4: bool, // bit offset: 12 desc: PWM[4] output enable control.
        PWMENA5: bool, // bit offset: 13 desc: PWM[5] output enable control.
        PWMENA6: bool, // bit offset: 14 desc: PWM[6] output enable control. See PWMENA1 for details.
    });
    // byte offset: 48 PWM Control Register. Enables PWM outputs and selects either single edge or double edge controlled PWM outputs.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PWMSEL2: bool, // bit offset: 2 desc: PWM[2] output single/double edge mode control.
        PWMSEL3: bool, // bit offset: 3 desc: PWM[3] output edge control.
        PWMSEL4: bool, // bit offset: 4 desc: PWM[4] output edge control.
        PWMSEL5: bool, // bit offset: 5 desc: PWM[5] output edge control.
        PWMSEL6: bool, // bit offset: 6 desc: PWM[6] output edge control.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        PWMENA1: bool, // bit offset: 9 desc: PWM[1] output enable control.
        PWMENA2: bool, // bit offset: 10 desc: PWM[2] output enable control.
        PWMENA3: bool, // bit offset: 11 desc: PWM[3] output enable control.
        PWMENA4: bool, // bit offset: 12 desc: PWM[4] output enable control.
        PWMENA5: bool, // bit offset: 13 desc: PWM[5] output enable control.
        PWMENA6: bool, // bit offset: 14 desc: PWM[6] output enable control. See PWMENA1 for details.
    });
    // byte offset: 64 Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
    pub const MR4 = mmio(Address + 0x00000040, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 68 Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
    pub const MR5 = mmio(Address + 0x00000044, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 72 Match Register. Match registers are continuously compared to the PWM counter in order to control PWM output edges.
    pub const MR6 = mmio(Address + 0x00000048, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 76 PWM Control Register. Enables PWM outputs and selects either single edge or double edge controlled PWM outputs.
    pub const PCR = mmio(Address + 0x0000004c, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PWMSEL2: bool, // bit offset: 2 desc: PWM[2] output single/double edge mode control.
        PWMSEL3: bool, // bit offset: 3 desc: PWM[3] output edge control.
        PWMSEL4: bool, // bit offset: 4 desc: PWM[4] output edge control.
        PWMSEL5: bool, // bit offset: 5 desc: PWM[5] output edge control.
        PWMSEL6: bool, // bit offset: 6 desc: PWM[6] output edge control.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        PWMENA1: bool, // bit offset: 9 desc: PWM[1] output enable control.
        PWMENA2: bool, // bit offset: 10 desc: PWM[2] output enable control.
        PWMENA3: bool, // bit offset: 11 desc: PWM[3] output enable control.
        PWMENA4: bool, // bit offset: 12 desc: PWM[4] output enable control.
        PWMENA5: bool, // bit offset: 13 desc: PWM[5] output enable control.
        PWMENA6: bool, // bit offset: 14 desc: PWM[6] output enable control. See PWMENA1 for details.
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 80 Load Enable Register. Enables use of updated PWM match values.
    pub const LER = mmio(Address + 0x00000050, 32, packed struct {
        MAT0LATCHEN: bool, // bit offset: 0 desc: Enable PWM Match 0 Latch. PWM MR0 register update control. Writing a one to this bit allows the last value written to the PWM Match Register 0 to be become effective when the timer is next reset by a PWM Match event. See Section 27.6.7.
        MAT1LATCHEN: bool, // bit offset: 1 desc: Enable PWM Match 1 Latch. PWM MR1 register update control. See bit 0 for details.
        MAT2LATCHEN: bool, // bit offset: 2 desc: Enable PWM Match 2 Latch. PWM MR2 register update control. See bit 0 for details.
        MAT3LATCHEN: bool, // bit offset: 3 desc: Enable PWM Match 3 Latch. PWM MR3 register update control. See bit 0 for details.
        MAT4LATCHEN: bool, // bit offset: 4 desc: Enable PWM Match 4 Latch. PWM MR4 register update control. See bit 0 for details.
        MAT5LATCHEN: bool, // bit offset: 5 desc: Enable PWM Match 5 Latch. PWM MR5 register update control. See bit 0 for details.
        MAT6LATCHEN: bool, // bit offset: 6 desc: Enable PWM Match 6 Latch. PWM MR6 register update control. See bit 0 for details.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    pub const CTCR = mmio(Address + 0x00000070, 32, packed struct {
        MOD: u2, // bit offset: 0 desc: Counter/ Timer Mode
        CIS: u2, // bit offset: 2 desc: Count Input Select. When bits 1:0 are not 00, these bits select which PWM_CAP pin carries the signal used to increment the TC. Other combinations are reserved.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const I2C0 = extern struct {
    pub const Address: u32 = 0x4001c000;
    // byte offset: 0 I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
    pub const CONSET = mmio(Address + 0x00000000, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        AA: bool, // bit offset: 2 desc: Assert acknowledge flag.
        SI: bool, // bit offset: 3 desc: I2C interrupt flag.
        STO: bool, // bit offset: 4 desc: STOP flag.
        STA: bool, // bit offset: 5 desc: START flag.
        I2EN: bool, // bit offset: 6 desc: I2C interface enable.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
    pub const STAT = mmio(Address + 0x00000004, 32, packed struct {
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        Status: u5, // bit offset: 3 desc: These bits give the actual status information about the I 2C interface.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
    pub const DAT = mmio(Address + 0x00000008, 32, packed struct {
        Data: u8, // bit offset: 0 desc: This register holds data values that have been received or are to be transmitted.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR0 = mmio(Address + 0x0000000c, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
    pub const SCLH = mmio(Address + 0x00000010, 32, packed struct {
        SCLH: u16, // bit offset: 0 desc: Count for SCL HIGH time period selection.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
    pub const SCLL = mmio(Address + 0x00000014, 32, packed struct {
        SCLL: u16, // bit offset: 0 desc: Count for SCL low time period selection.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
    pub const CONCLR = mmio(Address + 0x00000018, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        AAC: bool, // bit offset: 2 desc: Assert acknowledge Clear bit.
        SIC: bool, // bit offset: 3 desc: I2C interrupt Clear bit.
        reserved2: u1 = 0,
        STAC: bool, // bit offset: 5 desc: START flag Clear bit.
        I2ENC: bool, // bit offset: 6 desc: I2C interface Disable bit.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Monitor mode control register.
    pub const MMCTRL = mmio(Address + 0x0000001c, 32, packed struct {
        MM_ENA: bool, // bit offset: 0 desc: Monitor mode enable.
        ENA_SCL: bool, // bit offset: 1 desc: SCL output enable.
        MATCH_ALL: bool, // bit offset: 2 desc: Select interrupt register match.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR1 = mmio(Address + 0x00000020, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 36 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR2 = mmio(Address + 0x00000024, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 40 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR3 = mmio(Address + 0x00000028, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 44 Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
    pub const DATA_BUFFER = mmio(Address + 0x0000002c, 32, packed struct {
        Data: u8, // bit offset: 0 desc: This register holds contents of the 8 MSBs of the DAT shift register.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 I2C Slave address mask register
    pub const MASK_0 = mmio(Address + 0x00000030, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 52 I2C Slave address mask register
    pub const MASK_1 = mmio(Address + 0x00000034, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 56 I2C Slave address mask register
    pub const MASK_2 = mmio(Address + 0x00000038, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 60 I2C Slave address mask register
    pub const MASK_3 = mmio(Address + 0x0000003c, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
};
pub const SPI = extern struct {
    pub const Address: u32 = 0x40020000;
    // byte offset: 0 SPI Control Register. This register controls the operation of the SPI.
    pub const CR = mmio(Address + 0x00000000, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        BITENABLE: bool, // bit offset: 2 desc: The SPI controller sends and receives 8 bits of data per transfer.
        CPHA: bool, // bit offset: 3 desc: Clock phase control determines the relationship between the data and the clock on SPI transfers, and controls when a slave transfer is defined as starting and ending.
        CPOL: bool, // bit offset: 4 desc: Clock polarity control.
        MSTR: bool, // bit offset: 5 desc: Master mode select.
        LSBF: bool, // bit offset: 6 desc: LSB First controls which direction each byte is shifted when transferred.
        SPIE: bool, // bit offset: 7 desc: Serial peripheral interrupt enable.
        BITS: u4, // bit offset: 8 desc: When bit 2 of this register is 1, this field controls the number of bits per transfer:
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 SPI Status Register. This register shows the status of the SPI.
    pub const SR = mmio(Address + 0x00000004, 32, packed struct {
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABRT: bool, // bit offset: 3 desc: Slave abort. When 1, this bit indicates that a slave abort has occurred. This bit is cleared by reading this register.
        MODF: bool, // bit offset: 4 desc: Mode fault. when 1, this bit indicates that a Mode fault error has occurred. This bit is cleared by reading this register, then writing the SPI0 control register.
        ROVR: bool, // bit offset: 5 desc: Read overrun. When 1, this bit indicates that a read overrun has occurred. This bit is cleared by reading this register.
        WCOL: bool, // bit offset: 6 desc: Write collision. When 1, this bit indicates that a write collision has occurred. This bit is cleared by reading this register, then accessing the SPI Data Register.
        SPIF: bool, // bit offset: 7 desc: SPI transfer complete flag. When 1, this bit indicates when a SPI data transfer is complete. When a master, this bit is set at the end of the last cycle of the transfer. When a slave, this bit is set on the last data sampling edge of the SCK. This bit is cleared by first reading this register, then accessing the SPI Data Register. Note: this is not the SPI interrupt flag. This flag is found in the SPINT register.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 SPI Data Register. This bi-directional register provides the transmit and receive data for the SPI. Transmit data is provided to the SPI0 by writing to this register. Data received by the SPI0 can be read from this register.
    pub const DR = mmio(Address + 0x00000008, 32, packed struct {
        DATALOW: u8, // bit offset: 0 desc: SPI Bi-directional data port.
        DATAHIGH: u8, // bit offset: 8 desc: If bit 2 of the SPCR is 1 and bits 11:8 are other than 1000, some or all of these bits contain the additional transmit and receive bits. When less than 16 bits are selected, the more significant among these bits read as zeroes.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 SPI Clock Counter Register. This register controls the frequency of a master's SCK0.
    pub const CCR = mmio(Address + 0x0000000c, 32, packed struct {
        COUNTER: u8, // bit offset: 0 desc: SPI0 Clock counter setting.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 SPI Interrupt Flag. This register contains the interrupt flag for the SPI interface.
    pub const INT = mmio(Address + 0x0000001c, 32, packed struct {
        SPIF: bool, // bit offset: 0 desc: SPI interrupt flag. Set by the SPI interface to generate an interrupt. Cleared by writing a 1 to this bit. Note: this bit will be set once when SPIE = 1 and at least one of SPIF and WCOL bits is 1. However, only when the SPI Interrupt bit is set and SPI0 Interrupt is enabled in the NVIC, SPI based interrupt can be processed by interrupt handling software.
        padding31: u1 = 0,
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const RTC = extern struct {
    pub const Address: u32 = 0x40024000;
    // byte offset: 0 Interrupt Location Register
    pub const ILR = mmio(Address + 0x00000000, 32, packed struct {
        RTCCIF: bool, // bit offset: 0 desc: When one, the Counter Increment Interrupt block generated an interrupt. Writing a one to this bit location clears the counter increment interrupt.
        RTCALF: bool, // bit offset: 1 desc: When one, the alarm registers generated an interrupt. Writing a one to this bit location clears the alarm interrupt.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Clock Control Register
    pub const CCR = mmio(Address + 0x00000008, 32, packed struct {
        CLKEN: bool, // bit offset: 0 desc: Clock Enable.
        CTCRST: bool, // bit offset: 1 desc: CTC Reset.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        CCALEN: bool, // bit offset: 4 desc: Calibration counter enable.
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Counter Increment Interrupt Register
    pub const CIIR = mmio(Address + 0x0000000c, 32, packed struct {
        IMSEC: bool, // bit offset: 0 desc: When 1, an increment of the Second value generates an interrupt.
        IMMIN: bool, // bit offset: 1 desc: When 1, an increment of the Minute value generates an interrupt.
        IMHOUR: bool, // bit offset: 2 desc: When 1, an increment of the Hour value generates an interrupt.
        IMDOM: bool, // bit offset: 3 desc: When 1, an increment of the Day of Month value generates an interrupt.
        IMDOW: bool, // bit offset: 4 desc: When 1, an increment of the Day of Week value generates an interrupt.
        IMDOY: bool, // bit offset: 5 desc: When 1, an increment of the Day of Year value generates an interrupt.
        IMMON: bool, // bit offset: 6 desc: When 1, an increment of the Month value generates an interrupt.
        IMYEAR: bool, // bit offset: 7 desc: When 1, an increment of the Year value generates an interrupt.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 Alarm Mask Register
    pub const AMR = mmio(Address + 0x00000010, 32, packed struct {
        AMRSEC: bool, // bit offset: 0 desc: When 1, the Second value is not compared for the alarm.
        AMRMIN: bool, // bit offset: 1 desc: When 1, the Minutes value is not compared for the alarm.
        AMRHOUR: bool, // bit offset: 2 desc: When 1, the Hour value is not compared for the alarm.
        AMRDOM: bool, // bit offset: 3 desc: When 1, the Day of Month value is not compared for the alarm.
        AMRDOW: bool, // bit offset: 4 desc: When 1, the Day of Week value is not compared for the alarm.
        AMRDOY: bool, // bit offset: 5 desc: When 1, the Day of Year value is not compared for the alarm.
        AMRMON: bool, // bit offset: 6 desc: When 1, the Month value is not compared for the alarm.
        AMRYEAR: bool, // bit offset: 7 desc: When 1, the Year value is not compared for the alarm.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Consolidated Time Register 0
    pub const CTIME0 = mmio(Address + 0x00000014, 32, packed struct {
        SECONDS: u6, // bit offset: 0 desc: Seconds value in the range of 0 to 59
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        MINUTES: u6, // bit offset: 8 desc: Minutes value in the range of 0 to 59
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        HOURS: u5, // bit offset: 16 desc: Hours value in the range of 0 to 23
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        DOW: u3, // bit offset: 24 desc: Day of week value in the range of 0 to 6
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Consolidated Time Register 1
    pub const CTIME1 = mmio(Address + 0x00000018, 32, packed struct {
        DOM: u5, // bit offset: 0 desc: Day of month value in the range of 1 to 28, 29, 30, or 31 (depending on the month and whether it is a leap year).
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        MONTH: u4, // bit offset: 8 desc: Month value in the range of 1 to 12.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        YEAR: u12, // bit offset: 16 desc: Year value in the range of 0 to 4095.
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Consolidated Time Register 2
    pub const CTIME2 = mmio(Address + 0x0000001c, 32, packed struct {
        DOY: u12, // bit offset: 0 desc: Day of year value in the range of 1 to 365 (366 for leap years).
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 Seconds Counter
    pub const SEC = mmio(Address + 0x00000020, 32, packed struct {
        SECONDS: u6, // bit offset: 0 desc: Seconds value in the range of 0 to 59
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 Minutes Register
    pub const MIN = mmio(Address + 0x00000024, 32, packed struct {
        MINUTES: u6, // bit offset: 0 desc: Minutes value in the range of 0 to 59
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Hours Register
    pub const HRS = mmio(Address + 0x00000028, 32, packed struct {
        HOURS: u5, // bit offset: 0 desc: Hours value in the range of 0 to 23
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 Day of Month Register
    pub const DOM = mmio(Address + 0x0000002c, 32, packed struct {
        DOM: u5, // bit offset: 0 desc: Day of month value in the range of 1 to 28, 29, 30, or 31 (depending on the month and whether it is a leap year).
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 Day of Week Register
    pub const DOW = mmio(Address + 0x00000030, 32, packed struct {
        DOW: u3, // bit offset: 0 desc: Day of week value in the range of 0 to 6.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 52 Day of Year Register
    pub const DOY = mmio(Address + 0x00000034, 32, packed struct {
        DOY: u9, // bit offset: 0 desc: Day of year value in the range of 1 to 365 (366 for leap years).
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 56 Months Register
    pub const MONTH = mmio(Address + 0x00000038, 32, packed struct {
        MONTH: u4, // bit offset: 0 desc: Month value in the range of 1 to 12.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 60 Years Register
    pub const YEAR = mmio(Address + 0x0000003c, 32, packed struct {
        YEAR: u12, // bit offset: 0 desc: Year value in the range of 0 to 4095.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 64 Calibration Value Register
    pub const CALIBRATION = mmio(Address + 0x00000040, 32, packed struct {
        CALVAL: u17, // bit offset: 0 desc: If enabled, the calibration counter counts up to this value. The maximum value is 131, 072 corresponding to about 36.4 hours. Calibration is disabled if CALVAL = 0.
        CALDIR: bool, // bit offset: 17 desc: Calibration direction
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 68 General Purpose Register 0
    pub const GPREG0 = mmio(Address + 0x00000044, 32, packed struct {
        GP: u32, // bit offset: 0 desc: General purpose storage.
    });
    // byte offset: 72 General Purpose Register 0
    pub const GPREG1 = mmio(Address + 0x00000048, 32, packed struct {
        GP: u32, // bit offset: 0 desc: General purpose storage.
    });
    // byte offset: 76 General Purpose Register 0
    pub const GPREG2 = mmio(Address + 0x0000004c, 32, packed struct {
        GP: u32, // bit offset: 0 desc: General purpose storage.
    });
    // byte offset: 80 General Purpose Register 0
    pub const GPREG3 = mmio(Address + 0x00000050, 32, packed struct {
        GP: u32, // bit offset: 0 desc: General purpose storage.
    });
    // byte offset: 84 General Purpose Register 0
    pub const GPREG4 = mmio(Address + 0x00000054, 32, packed struct {
        GP: u32, // bit offset: 0 desc: General purpose storage.
    });
    // byte offset: 88 RTC Auxiliary Enable register
    pub const RTC_AUXEN = mmio(Address + 0x00000058, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RTC_OSCFEN: bool, // bit offset: 4 desc: Oscillator Fail Detect interrupt enable. When 0: the RTC Oscillator Fail detect interrupt is disabled. When 1: the RTC Oscillator Fail detect interrupt is enabled. See Section 30.6.2.5.
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 92 RTC Auxiliary control register
    pub const RTC_AUX = mmio(Address + 0x0000005c, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RTC_OSCF: bool, // bit offset: 4 desc: RTC Oscillator Fail detect flag. Read: this bit is set if the RTC oscillator stops, and when RTC power is first turned on. An interrupt will occur when this bit is set, the RTC_OSCFEN bit in RTC_AUXEN is a 1, and the RTC interrupt is enabled in the NVIC. Write: writing a 1 to this bit clears the flag.
        reserved2: u1 = 0,
        RTC_PDOUT: bool, // bit offset: 6 desc: When 0: the RTC_ALARM pin reflects the RTC alarm status. When 1: the RTC_ALARM pin indicates Deep Power-down mode.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 96 Alarm value for Seconds
    pub const ASEC = mmio(Address + 0x00000060, 32, packed struct {
        SECONDS: u6, // bit offset: 0 desc: Seconds value in the range of 0 to 59
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 100 Alarm value for Minutes
    pub const AMIN = mmio(Address + 0x00000064, 32, packed struct {
        MINUTES: u6, // bit offset: 0 desc: Minutes value in the range of 0 to 59
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 104 Alarm value for Hours
    pub const AHRS = mmio(Address + 0x00000068, 32, packed struct {
        HOURS: u5, // bit offset: 0 desc: Hours value in the range of 0 to 23
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 108 Alarm value for Day of Month
    pub const ADOM = mmio(Address + 0x0000006c, 32, packed struct {
        DOM: u5, // bit offset: 0 desc: Day of month value in the range of 1 to 28, 29, 30, or 31 (depending on the month and whether it is a leap year).
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 Alarm value for Day of Week
    pub const ADOW = mmio(Address + 0x00000070, 32, packed struct {
        DOW: u3, // bit offset: 0 desc: Day of week value in the range of 0 to 6.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 116 Alarm value for Day of Year
    pub const ADOY = mmio(Address + 0x00000074, 32, packed struct {
        DOY: u9, // bit offset: 0 desc: Day of year value in the range of 1 to 365 (366 for leap years).
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 120 Alarm value for Months
    pub const AMON = mmio(Address + 0x00000078, 32, packed struct {
        MONTH: u4, // bit offset: 0 desc: Month value in the range of 1 to 12.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 124 Alarm value for Year
    pub const AYRS = mmio(Address + 0x0000007c, 32, packed struct {
        YEAR: u12, // bit offset: 0 desc: Year value in the range of 0 to 4095.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const GPIOINT = extern struct {
    pub const Address: u32 = 0x40028080;
    // byte offset: 0 GPIO overall Interrupt Status.
    pub const STATUS = mmio(Address + 0x00000000, 32, packed struct {
        P0INT: bool, // bit offset: 0 desc: Port 0 GPIO interrupt pending.
        reserved1: u1 = 0,
        P2INT: bool, // bit offset: 2 desc: Port 2 GPIO interrupt pending.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 GPIO Interrupt Status for Rising edge for Port 0.
    pub const STATR0 = mmio(Address + 0x00000004, 32, packed struct {
        P0_0REI: bool, // bit offset: 0 desc: Status of Rising Edge Interrupt for P0[0]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_1REI: bool, // bit offset: 1 desc: Status of Rising Edge Interrupt for P0[1]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_2REI: bool, // bit offset: 2 desc: Status of Rising Edge Interrupt for P0[2]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_3REI: bool, // bit offset: 3 desc: Status of Rising Edge Interrupt for P0[3]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_4REI: bool, // bit offset: 4 desc: Status of Rising Edge Interrupt for P0[4]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_5REI: bool, // bit offset: 5 desc: Status of Rising Edge Interrupt for P0[5]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_6REI: bool, // bit offset: 6 desc: Status of Rising Edge Interrupt for P0[6]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_7REI: bool, // bit offset: 7 desc: Status of Rising Edge Interrupt for P0[7]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_8REI: bool, // bit offset: 8 desc: Status of Rising Edge Interrupt for P0[8]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_9REI: bool, // bit offset: 9 desc: Status of Rising Edge Interrupt for P0[9]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_10REI: bool, // bit offset: 10 desc: Status of Rising Edge Interrupt for P0[10]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_11REI: bool, // bit offset: 11 desc: Status of Rising Edge Interrupt for P0[11]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_12REI: bool, // bit offset: 12 desc: Status of Rising Edge Interrupt for P0[12]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_13REI: bool, // bit offset: 13 desc: Status of Rising Edge Interrupt for P0[13]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_14REI: bool, // bit offset: 14 desc: Status of Rising Edge Interrupt for P0[14]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_15REI: bool, // bit offset: 15 desc: Status of Rising Edge Interrupt for P0[15]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_16REI: bool, // bit offset: 16 desc: Status of Rising Edge Interrupt for P0[16]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_17REI: bool, // bit offset: 17 desc: Status of Rising Edge Interrupt for P0[17]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_18REI: bool, // bit offset: 18 desc: Status of Rising Edge Interrupt for P0[18]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_19REI: bool, // bit offset: 19 desc: Status of Rising Edge Interrupt for P0[19]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_20REI: bool, // bit offset: 20 desc: Status of Rising Edge Interrupt for P0[20]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_21REI: bool, // bit offset: 21 desc: Status of Rising Edge Interrupt for P0[21]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_22REI: bool, // bit offset: 22 desc: Status of Rising Edge Interrupt for P0[22]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_23REI: bool, // bit offset: 23 desc: Status of Rising Edge Interrupt for P0[23]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_24REI: bool, // bit offset: 24 desc: Status of Rising Edge Interrupt for P0[24]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_25REI: bool, // bit offset: 25 desc: Status of Rising Edge Interrupt for P0[25]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_26REI: bool, // bit offset: 26 desc: Status of Rising Edge Interrupt for P0[26]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_27REI: bool, // bit offset: 27 desc: Status of Rising Edge Interrupt for P0[27]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_28REI: bool, // bit offset: 28 desc: Status of Rising Edge Interrupt for P0[28]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_29REI: bool, // bit offset: 29 desc: Status of Rising Edge Interrupt for P0[29]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P0_30REI: bool, // bit offset: 30 desc: Status of Rising Edge Interrupt for P0[30]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        padding1: u1 = 0,
    });
    // byte offset: 8 GPIO Interrupt Status for Falling edge for Port 0.
    pub const STATF0 = mmio(Address + 0x00000008, 32, packed struct {
        P0_0FEI: bool, // bit offset: 0 desc: Status of Falling Edge Interrupt for P0[0]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_1FEI: bool, // bit offset: 1 desc: Status of Falling Edge Interrupt for P0[1]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_2FEI: bool, // bit offset: 2 desc: Status of Falling Edge Interrupt for P0[2]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_3FEI: bool, // bit offset: 3 desc: Status of Falling Edge Interrupt for P0[3]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_4FEI: bool, // bit offset: 4 desc: Status of Falling Edge Interrupt for P0[4]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_5FEI: bool, // bit offset: 5 desc: Status of Falling Edge Interrupt for P0[5]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_6FEI: bool, // bit offset: 6 desc: Status of Falling Edge Interrupt for P0[6]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_7FEI: bool, // bit offset: 7 desc: Status of Falling Edge Interrupt for P0[7]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_8FEI: bool, // bit offset: 8 desc: Status of Falling Edge Interrupt for P0[8]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_9FEI: bool, // bit offset: 9 desc: Status of Falling Edge Interrupt for P0[9]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_10FEI: bool, // bit offset: 10 desc: Status of Falling Edge Interrupt for P0[10]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_11FEI: bool, // bit offset: 11 desc: Status of Falling Edge Interrupt for P0[11]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_12FEI: bool, // bit offset: 12 desc: Status of Falling Edge Interrupt for P0[12]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_13FEI: bool, // bit offset: 13 desc: Status of Falling Edge Interrupt for P0[13]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_14FEI: bool, // bit offset: 14 desc: Status of Falling Edge Interrupt for P0[14]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_15FEI: bool, // bit offset: 15 desc: Status of Falling Edge Interrupt for P0[15]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_16FEI: bool, // bit offset: 16 desc: Status of Falling Edge Interrupt for P0[16]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_17FEI: bool, // bit offset: 17 desc: Status of Falling Edge Interrupt for P0[17]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_18FEI: bool, // bit offset: 18 desc: Status of Falling Edge Interrupt for P0[18]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_19FEI: bool, // bit offset: 19 desc: Status of Falling Edge Interrupt for P0[19]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_20FEI: bool, // bit offset: 20 desc: Status of Falling Edge Interrupt for P0[20]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_21FEI: bool, // bit offset: 21 desc: Status of Falling Edge Interrupt for P0[21]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_22FEI: bool, // bit offset: 22 desc: Status of Falling Edge Interrupt for P0[22]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_23FEI: bool, // bit offset: 23 desc: Status of Falling Edge Interrupt for P0[23]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_24FEI: bool, // bit offset: 24 desc: Status of Falling Edge Interrupt for P0[24]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_25FEI: bool, // bit offset: 25 desc: Status of Falling Edge Interrupt for P0[25]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_26FEI: bool, // bit offset: 26 desc: Status of Falling Edge Interrupt for P0[26]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_27FEI: bool, // bit offset: 27 desc: Status of Falling Edge Interrupt for P0[27]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_28FEI: bool, // bit offset: 28 desc: Status of Falling Edge Interrupt for P0[28]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_29FEI: bool, // bit offset: 29 desc: Status of Falling Edge Interrupt for P0[29]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P0_30FEI: bool, // bit offset: 30 desc: Status of Falling Edge Interrupt for P0[30]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        padding1: u1 = 0,
    });
    // byte offset: 12 GPIO Interrupt Clear.
    pub const CLR0 = mmio(Address + 0x0000000c, 32, packed struct {
        P0_0CI: bool, // bit offset: 0 desc: Clear GPIO port Interrupts for P0[0]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_1CI: bool, // bit offset: 1 desc: Clear GPIO port Interrupts for P0[1]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_2CI: bool, // bit offset: 2 desc: Clear GPIO port Interrupts for P0[2]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_3CI: bool, // bit offset: 3 desc: Clear GPIO port Interrupts for P0[3]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_4CI: bool, // bit offset: 4 desc: Clear GPIO port Interrupts for P0[4]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_5CI: bool, // bit offset: 5 desc: Clear GPIO port Interrupts for P0[5]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_6CI: bool, // bit offset: 6 desc: Clear GPIO port Interrupts for P0[6]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_7CI: bool, // bit offset: 7 desc: Clear GPIO port Interrupts for P0[7]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_8CI: bool, // bit offset: 8 desc: Clear GPIO port Interrupts for P0[8]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_9CI: bool, // bit offset: 9 desc: Clear GPIO port Interrupts for P0[9]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_10CI: bool, // bit offset: 10 desc: Clear GPIO port Interrupts for P0[10]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_11CI: bool, // bit offset: 11 desc: Clear GPIO port Interrupts for P0[11]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_12CI: bool, // bit offset: 12 desc: Clear GPIO port Interrupts for P0[12]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_13CI: bool, // bit offset: 13 desc: Clear GPIO port Interrupts for P0[13]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_14CI: bool, // bit offset: 14 desc: Clear GPIO port Interrupts for P0[14]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_15CI: bool, // bit offset: 15 desc: Clear GPIO port Interrupts for P0[15]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_16CI: bool, // bit offset: 16 desc: Clear GPIO port Interrupts for P0[16]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_17CI: bool, // bit offset: 17 desc: Clear GPIO port Interrupts for P0[17]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_18CI: bool, // bit offset: 18 desc: Clear GPIO port Interrupts for P0[18]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_19CI: bool, // bit offset: 19 desc: Clear GPIO port Interrupts for P0[19]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_20CI: bool, // bit offset: 20 desc: Clear GPIO port Interrupts for P0[20]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_21CI: bool, // bit offset: 21 desc: Clear GPIO port Interrupts for P0[21]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_22CI: bool, // bit offset: 22 desc: Clear GPIO port Interrupts for P0[22]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_23CI: bool, // bit offset: 23 desc: Clear GPIO port Interrupts for P0[23]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_24CI: bool, // bit offset: 24 desc: Clear GPIO port Interrupts for P0[24]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_25CI: bool, // bit offset: 25 desc: Clear GPIO port Interrupts for P0[25]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_26CI: bool, // bit offset: 26 desc: Clear GPIO port Interrupts for P0[26]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_27CI: bool, // bit offset: 27 desc: Clear GPIO port Interrupts for P0[27]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_28CI: bool, // bit offset: 28 desc: Clear GPIO port Interrupts for P0[28]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_29CI: bool, // bit offset: 29 desc: Clear GPIO port Interrupts for P0[29]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P0_30CI: bool, // bit offset: 30 desc: Clear GPIO port Interrupts for P0[30]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        padding1: u1 = 0,
    });
    // byte offset: 16 GPIO Interrupt Enable for Rising edge for Port 0.
    pub const ENR0 = mmio(Address + 0x00000010, 32, packed struct {
        P0_0ER: bool, // bit offset: 0 desc: Enable rising edge interrupt for P0[0]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_1ER: bool, // bit offset: 1 desc: Enable rising edge interrupt for P0[1]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_2ER: bool, // bit offset: 2 desc: Enable rising edge interrupt for P0[2]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_3ER: bool, // bit offset: 3 desc: Enable rising edge interrupt for P0[3]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_4ER: bool, // bit offset: 4 desc: Enable rising edge interrupt for P0[4]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_5ER: bool, // bit offset: 5 desc: Enable rising edge interrupt for P0[5]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_6ER: bool, // bit offset: 6 desc: Enable rising edge interrupt for P0[6]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_7ER: bool, // bit offset: 7 desc: Enable rising edge interrupt for P0[7]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_8ER: bool, // bit offset: 8 desc: Enable rising edge interrupt for P0[8]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_9ER: bool, // bit offset: 9 desc: Enable rising edge interrupt for P0[9]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_10ER: bool, // bit offset: 10 desc: Enable rising edge interrupt for P0[10]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_11ER: bool, // bit offset: 11 desc: Enable rising edge interrupt for P0[11]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_12ER: bool, // bit offset: 12 desc: Enable rising edge interrupt for P0[12]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_13ER: bool, // bit offset: 13 desc: Enable rising edge interrupt for P0[13]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_14ER: bool, // bit offset: 14 desc: Enable rising edge interrupt for P0[14]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_15ER: bool, // bit offset: 15 desc: Enable rising edge interrupt for P0[15]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_16ER: bool, // bit offset: 16 desc: Enable rising edge interrupt for P0[16]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_17ER: bool, // bit offset: 17 desc: Enable rising edge interrupt for P0[17]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_18ER: bool, // bit offset: 18 desc: Enable rising edge interrupt for P0[18]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_19ER: bool, // bit offset: 19 desc: Enable rising edge interrupt for P0[19]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_20ER: bool, // bit offset: 20 desc: Enable rising edge interrupt for P0[20]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_21ER: bool, // bit offset: 21 desc: Enable rising edge interrupt for P0[21]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_22ER: bool, // bit offset: 22 desc: Enable rising edge interrupt for P0[22]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_23ER: bool, // bit offset: 23 desc: Enable rising edge interrupt for P0[23]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_24ER: bool, // bit offset: 24 desc: Enable rising edge interrupt for P0[24]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_25ER: bool, // bit offset: 25 desc: Enable rising edge interrupt for P0[25]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_26ER: bool, // bit offset: 26 desc: Enable rising edge interrupt for P0[26]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_27ER: bool, // bit offset: 27 desc: Enable rising edge interrupt for P0[27]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_28ER: bool, // bit offset: 28 desc: Enable rising edge interrupt for P0[28]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_29ER: bool, // bit offset: 29 desc: Enable rising edge interrupt for P0[29]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P0_30ER: bool, // bit offset: 30 desc: Enable rising edge interrupt for P0[30]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        padding1: u1 = 0,
    });
    // byte offset: 20 GPIO Interrupt Enable for Falling edge for Port 0.
    pub const ENF0 = mmio(Address + 0x00000014, 32, packed struct {
        P0_0EF: bool, // bit offset: 0 desc: Enable falling edge interrupt for P0[0]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_1EF: bool, // bit offset: 1 desc: Enable falling edge interrupt for P0[1]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_2EF: bool, // bit offset: 2 desc: Enable falling edge interrupt for P0[2]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_3EF: bool, // bit offset: 3 desc: Enable falling edge interrupt for P0[3]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_4EF: bool, // bit offset: 4 desc: Enable falling edge interrupt for P0[4]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_5EF: bool, // bit offset: 5 desc: Enable falling edge interrupt for P0[5]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_6EF: bool, // bit offset: 6 desc: Enable falling edge interrupt for P0[6]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_7EF: bool, // bit offset: 7 desc: Enable falling edge interrupt for P0[7]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_8EF: bool, // bit offset: 8 desc: Enable falling edge interrupt for P0[8]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_9EF: bool, // bit offset: 9 desc: Enable falling edge interrupt for P0[9]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_10EF: bool, // bit offset: 10 desc: Enable falling edge interrupt for P0[10]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_11EF: bool, // bit offset: 11 desc: Enable falling edge interrupt for P0[11]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_12EF: bool, // bit offset: 12 desc: Enable falling edge interrupt for P0[12]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_13EF: bool, // bit offset: 13 desc: Enable falling edge interrupt for P0[13]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_14EF: bool, // bit offset: 14 desc: Enable falling edge interrupt for P0[14]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_15EF: bool, // bit offset: 15 desc: Enable falling edge interrupt for P0[15]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_16EF: bool, // bit offset: 16 desc: Enable falling edge interrupt for P0[16]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_17EF: bool, // bit offset: 17 desc: Enable falling edge interrupt for P0[17]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_18EF: bool, // bit offset: 18 desc: Enable falling edge interrupt for P0[18]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_19EF: bool, // bit offset: 19 desc: Enable falling edge interrupt for P0[19]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_20EF: bool, // bit offset: 20 desc: Enable falling edge interrupt for P0[20]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_21EF: bool, // bit offset: 21 desc: Enable falling edge interrupt for P0[21]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_22EF: bool, // bit offset: 22 desc: Enable falling edge interrupt for P0[22]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_23EF: bool, // bit offset: 23 desc: Enable falling edge interrupt for P0[23]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_24EF: bool, // bit offset: 24 desc: Enable falling edge interrupt for P0[24]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_25EF: bool, // bit offset: 25 desc: Enable falling edge interrupt for P0[25]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_26EF: bool, // bit offset: 26 desc: Enable falling edge interrupt for P0[26]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_27EF: bool, // bit offset: 27 desc: Enable falling edge interrupt for P0[27]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_28EF: bool, // bit offset: 28 desc: Enable falling edge interrupt for P0[28]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_29EF: bool, // bit offset: 29 desc: Enable falling edge interrupt for P0[29]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P0_30EF: bool, // bit offset: 30 desc: Enable falling edge interrupt for P0[30]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        padding1: u1 = 0,
    });
    // byte offset: 36 GPIO Interrupt Status for Rising edge for Port 0.
    pub const STATR2 = mmio(Address + 0x00000024, 32, packed struct {
        P2_0REI: bool, // bit offset: 0 desc: Status of Rising Edge Interrupt for P2[0]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_1REI: bool, // bit offset: 1 desc: Status of Rising Edge Interrupt for P2[1]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_2REI: bool, // bit offset: 2 desc: Status of Rising Edge Interrupt for P2[2]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_3REI: bool, // bit offset: 3 desc: Status of Rising Edge Interrupt for P2[3]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_4REI: bool, // bit offset: 4 desc: Status of Rising Edge Interrupt for P2[4]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_5REI: bool, // bit offset: 5 desc: Status of Rising Edge Interrupt for P2[5]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_6REI: bool, // bit offset: 6 desc: Status of Rising Edge Interrupt for P2[6]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_7REI: bool, // bit offset: 7 desc: Status of Rising Edge Interrupt for P2[7]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_8REI: bool, // bit offset: 8 desc: Status of Rising Edge Interrupt for P2[8]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_9REI: bool, // bit offset: 9 desc: Status of Rising Edge Interrupt for P2[9]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_10REI: bool, // bit offset: 10 desc: Status of Rising Edge Interrupt for P2[10]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_11REI: bool, // bit offset: 11 desc: Status of Rising Edge Interrupt for P2[11]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_12REI: bool, // bit offset: 12 desc: Status of Rising Edge Interrupt for P2[12]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        P2_13REI: bool, // bit offset: 13 desc: Status of Rising Edge Interrupt for P2[13]. 0 = No rising edge detected. 1 = Rising edge interrupt generated.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 GPIO Interrupt Status for Falling edge for Port 0.
    pub const STATF2 = mmio(Address + 0x00000028, 32, packed struct {
        P2_0FEI: bool, // bit offset: 0 desc: Status of Falling Edge Interrupt for P2[0]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_1FEI: bool, // bit offset: 1 desc: Status of Falling Edge Interrupt for P2[1]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_2FEI: bool, // bit offset: 2 desc: Status of Falling Edge Interrupt for P2[2]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_3FEI: bool, // bit offset: 3 desc: Status of Falling Edge Interrupt for P2[3]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_4FEI: bool, // bit offset: 4 desc: Status of Falling Edge Interrupt for P2[4]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_5FEI: bool, // bit offset: 5 desc: Status of Falling Edge Interrupt for P2[5]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_6FEI: bool, // bit offset: 6 desc: Status of Falling Edge Interrupt for P2[6]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_7FEI: bool, // bit offset: 7 desc: Status of Falling Edge Interrupt for P2[7]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_8FEI: bool, // bit offset: 8 desc: Status of Falling Edge Interrupt for P2[8]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_9FEI: bool, // bit offset: 9 desc: Status of Falling Edge Interrupt for P2[9]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_10FEI: bool, // bit offset: 10 desc: Status of Falling Edge Interrupt for P2[10]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_11FEI: bool, // bit offset: 11 desc: Status of Falling Edge Interrupt for P2[11]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_12FEI: bool, // bit offset: 12 desc: Status of Falling Edge Interrupt for P2[12]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        P2_13FEI: bool, // bit offset: 13 desc: Status of Falling Edge Interrupt for P2[13]. 0 = No falling edge detected. 1 = Falling edge interrupt generated.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 GPIO Interrupt Clear.
    pub const CLR2 = mmio(Address + 0x0000002c, 32, packed struct {
        P2_0CI: bool, // bit offset: 0 desc: Clear GPIO port Interrupts for P2[0]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_1CI: bool, // bit offset: 1 desc: Clear GPIO port Interrupts for P2[1]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_2CI: bool, // bit offset: 2 desc: Clear GPIO port Interrupts for P2[2]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_3CI: bool, // bit offset: 3 desc: Clear GPIO port Interrupts for P2[3]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_4CI: bool, // bit offset: 4 desc: Clear GPIO port Interrupts for P2[4]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_5CI: bool, // bit offset: 5 desc: Clear GPIO port Interrupts for P2[5]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_6CI: bool, // bit offset: 6 desc: Clear GPIO port Interrupts for P2[6]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_7CI: bool, // bit offset: 7 desc: Clear GPIO port Interrupts for P2[7]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_8CI: bool, // bit offset: 8 desc: Clear GPIO port Interrupts for P2[8]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_9CI: bool, // bit offset: 9 desc: Clear GPIO port Interrupts for P2[9]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_10CI: bool, // bit offset: 10 desc: Clear GPIO port Interrupts for P2[10]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_11CI: bool, // bit offset: 11 desc: Clear GPIO port Interrupts for P2[11]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_12CI: bool, // bit offset: 12 desc: Clear GPIO port Interrupts for P2[12]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        P2_13CI: bool, // bit offset: 13 desc: Clear GPIO port Interrupts for P2[13]. 0 = No effect. 1 = Clear corresponding bits in IOnINTSTATR and IOnSTATF.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 GPIO Interrupt Enable for Rising edge for Port 0.
    pub const ENR2 = mmio(Address + 0x00000030, 32, packed struct {
        P2_0ER: bool, // bit offset: 0 desc: Enable rising edge interrupt for P2[0]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_1ER: bool, // bit offset: 1 desc: Enable rising edge interrupt for P2[1]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_2ER: bool, // bit offset: 2 desc: Enable rising edge interrupt for P2[2]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_3ER: bool, // bit offset: 3 desc: Enable rising edge interrupt for P2[3]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_4ER: bool, // bit offset: 4 desc: Enable rising edge interrupt for P2[4]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_5ER: bool, // bit offset: 5 desc: Enable rising edge interrupt for P2[5]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_6ER: bool, // bit offset: 6 desc: Enable rising edge interrupt for P2[6]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_7ER: bool, // bit offset: 7 desc: Enable rising edge interrupt for P2[7]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_8ER: bool, // bit offset: 8 desc: Enable rising edge interrupt for P2[8]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_9ER: bool, // bit offset: 9 desc: Enable rising edge interrupt for P2[9]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_10ER: bool, // bit offset: 10 desc: Enable rising edge interrupt for P2[10]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_11ER: bool, // bit offset: 11 desc: Enable rising edge interrupt for P2[11]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_12ER: bool, // bit offset: 12 desc: Enable rising edge interrupt for P2[12]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        P2_13ER: bool, // bit offset: 13 desc: Enable rising edge interrupt for P2[13]. 0 = Disable rising edge interrupt. 1 = Enable rising edge interrupt.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 52 GPIO Interrupt Enable for Falling edge for Port 0.
    pub const ENF2 = mmio(Address + 0x00000034, 32, packed struct {
        P2_0EF: bool, // bit offset: 0 desc: Enable falling edge interrupt for P2[0]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_1EF: bool, // bit offset: 1 desc: Enable falling edge interrupt for P2[1]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_2EF: bool, // bit offset: 2 desc: Enable falling edge interrupt for P2[2]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_3EF: bool, // bit offset: 3 desc: Enable falling edge interrupt for P2[3]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_4EF: bool, // bit offset: 4 desc: Enable falling edge interrupt for P2[4]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_5EF: bool, // bit offset: 5 desc: Enable falling edge interrupt for P2[5]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_6EF: bool, // bit offset: 6 desc: Enable falling edge interrupt for P2[6]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_7EF: bool, // bit offset: 7 desc: Enable falling edge interrupt for P2[7]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_8EF: bool, // bit offset: 8 desc: Enable falling edge interrupt for P2[8]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_9EF: bool, // bit offset: 9 desc: Enable falling edge interrupt for P2[9]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_10EF: bool, // bit offset: 10 desc: Enable falling edge interrupt for P2[10]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_11EF: bool, // bit offset: 11 desc: Enable falling edge interrupt for P2[11]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_12EF: bool, // bit offset: 12 desc: Enable falling edge interrupt for P2[12]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        P2_13EF: bool, // bit offset: 13 desc: Enable falling edge interrupt for P2[13]. 0 = Disable falling edge interrupt. 1 = Enable falling edge interrupt.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const PINCONNECT = extern struct {
    pub const Address: u32 = 0x4002c000;
    // byte offset: 0 Pin function select register 0.
    pub const PINSEL0 = mmio(Address + 0x00000000, 32, packed struct {
        P0_0: u2, // bit offset: 0 desc: Pin function select P0.0.
        P0_1: u2, // bit offset: 2 desc: Pin function select P0.1.
        P0_2: u2, // bit offset: 4 desc: Pin function select P0.2.
        P0_3: u2, // bit offset: 6 desc: Pin function select P0.3.
        P0_4: u2, // bit offset: 8 desc: Pin function select P0.4.
        P0_5: u2, // bit offset: 10 desc: Pin function select P0.5.
        P0_6: u2, // bit offset: 12 desc: Pin function select P0.6.
        P0_7: u2, // bit offset: 14 desc: Pin function select P0.7.
        P0_8: u2, // bit offset: 16 desc: Pin function select P0.8.
        P0_9: u2, // bit offset: 18 desc: Pin function select P0.9.
        P0_10: u2, // bit offset: 20 desc: Pin function select P0.10.
        P0_11: u2, // bit offset: 22 desc: Pin function select P0.11.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P0_15: u2, // bit offset: 30 desc: Pin function select P0.15.
    });
    // byte offset: 4 Pin function select register 1.
    pub const PINSEL1 = mmio(Address + 0x00000004, 32, packed struct {
        P0_16: u2, // bit offset: 0 desc: Pin function select P0.16.
        P0_17: u2, // bit offset: 2 desc: Pin function select P0.17.
        P0_18: u2, // bit offset: 4 desc: Pin function select P0.18.
        P0_19: u2, // bit offset: 6 desc: Pin function select P019.
        P0_20: u2, // bit offset: 8 desc: Pin function select P0.20.
        P0_21: u2, // bit offset: 10 desc: Pin function select P0.21.
        P0_22: u2, // bit offset: 12 desc: Pin function select P022
        P0_23: u2, // bit offset: 14 desc: Pin function select P023.
        P0_24: u2, // bit offset: 16 desc: Pin function select P0.24.
        P0_25: u2, // bit offset: 18 desc: Pin function select P0.25.
        P0_26: u2, // bit offset: 20 desc: Pin function select P0.26.
        P0_27: u2, // bit offset: 22 desc: Pin function select P0.27.
        P0_28: u2, // bit offset: 24 desc: Pin function select P0.28.
        P0_29: u2, // bit offset: 26 desc: Pin function select P0.29
        P0_30: u2, // bit offset: 28 desc: Pin function select P0.30.
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Pin function select register 2.
    pub const PINSEL2 = mmio(Address + 0x00000008, 32, packed struct {
        P1_0: u2, // bit offset: 0 desc: Pin function select P1.0.
        P1_1: u2, // bit offset: 2 desc: Pin function select P1.1.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P1_4: u2, // bit offset: 8 desc: Pin function select P1.4.
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        P1_8: u2, // bit offset: 16 desc: Pin function select P1.8.
        P1_9: u2, // bit offset: 18 desc: Pin function select P1.9.
        P1_10: u2, // bit offset: 20 desc: Pin function select P1.10.
        P1_14: u2, // bit offset: 22 desc: Pin function select P1.14.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        P1_15: u2, // bit offset: 30 desc: Pin function select P1.15.
    });
    // byte offset: 12 Pin function select register 3.
    pub const PINSEL3 = mmio(Address + 0x0000000c, 32, packed struct {
        P1_16: u2, // bit offset: 0 desc: Pin function select P1.16.
        P1_17: u2, // bit offset: 2 desc: Pin function select P1.17.
        P1_18: u2, // bit offset: 4 desc: Pin function select P1.18.
        P1_19: u2, // bit offset: 6 desc: Pin function select P1.19.
        P1_20: u2, // bit offset: 8 desc: Pin function select P1.20.
        P1_21: u2, // bit offset: 10 desc: Pin function select P1.21.
        P1_22: u2, // bit offset: 12 desc: Pin function select P1.22
        P1_23: u2, // bit offset: 14 desc: Pin function select P1.23.
        P1_24: u2, // bit offset: 16 desc: Pin function select P1.24.
        P1_25: u2, // bit offset: 18 desc: Pin function select P1.25.
        P1_26: u2, // bit offset: 20 desc: Pin function select P1.26.
        P1_27: u2, // bit offset: 22 desc: Pin function select P1.27.
        P1_28: u2, // bit offset: 24 desc: Pin function select P1.28.
        P1_29: u2, // bit offset: 26 desc: Pin function select P1.29
        P1_30: u2, // bit offset: 28 desc: Pin function select P1.30.
        P1_31: u2, // bit offset: 30 desc: Pin function select P1.31.
    });
    // byte offset: 16 Pin function select register 4
    pub const PINSEL4 = mmio(Address + 0x00000010, 32, packed struct {
        P2_0: u2, // bit offset: 0 desc: Pin function select P2.0.
        P2_1: u2, // bit offset: 2 desc: Pin function select P2.1.
        P2_2: u2, // bit offset: 4 desc: Pin function select P2.2.
        P2_3: u2, // bit offset: 6 desc: Pin function select P2.3.
        P2_4: u2, // bit offset: 8 desc: Pin function select P2.4.
        P2_5: u2, // bit offset: 10 desc: Pin function select P2.5.
        P2_6: u2, // bit offset: 12 desc: Pin function select P2.6.
        P2_7: u2, // bit offset: 14 desc: Pin function select P2.7.
        P2_8: u2, // bit offset: 16 desc: Pin function select P2.8.
        P2_9: u2, // bit offset: 18 desc: Pin function select P2.9.
        P2_10: u2, // bit offset: 20 desc: Pin function select P2.10.
        P2_11: u2, // bit offset: 22 desc: Pin function select P2.11.
        P2_12: u2, // bit offset: 24 desc: Pin function select P2.12.
        P2_13: u2, // bit offset: 26 desc: Pin function select P2.13.
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Pin function select register 7
    pub const PINSEL7 = mmio(Address + 0x0000001c, 32, packed struct {
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P3_25: u2, // bit offset: 18 desc: Pin function select P3.25.
        P3_26: u2, // bit offset: 20 desc: Pin function select P3.26.
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 Pin function select register 9
    pub const PINSEL9 = mmio(Address + 0x00000024, 32, packed struct {
        reserved24: u1 = 0,
        reserved23: u1 = 0,
        reserved22: u1 = 0,
        reserved21: u1 = 0,
        reserved20: u1 = 0,
        reserved19: u1 = 0,
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P4_28: u2, // bit offset: 24 desc: Pin function select P4.28.
        P4_29: u2, // bit offset: 26 desc: Pin function select P4.29.
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Pin function select register 10
    pub const PINSEL10 = mmio(Address + 0x00000028, 32, packed struct {
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TPIUCTRL: bool, // bit offset: 3 desc: TPIU interface pins control.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 64 Pin mode select register 0
    pub const PINMODE0 = mmio(Address + 0x00000040, 32, packed struct {
        P0_00MODE: u2, // bit offset: 0 desc: Port 0 pin 0 on-chip pull-up/down resistor control.
        P0_01MODE: u2, // bit offset: 2 desc: Port 0 pin 1 control.
        P0_02MODE: u2, // bit offset: 4 desc: Port 0 pin 2 control.
        P0_03MODE: u2, // bit offset: 6 desc: Port 0 pin 3 control.
        P0_04MODE: u2, // bit offset: 8 desc: Port 0 pin 4 control.
        P0_05MODE: u2, // bit offset: 10 desc: Port 0 pin 5 control.
        P0_06MODE: u2, // bit offset: 12 desc: Port 0 pin 6 control.
        P0_07MODE: u2, // bit offset: 14 desc: Port 0 pin 7 control.
        P0_08MODE: u2, // bit offset: 16 desc: Port 0 pin 8 control.
        P0_09MODE: u2, // bit offset: 18 desc: Port 0 pin 9 control.
        P0_10MODE: u2, // bit offset: 20 desc: Port 0 pin 10 control.
        P0_11MODE: u2, // bit offset: 22 desc: Port 0 pin 11 control.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P0_15MODE: u2, // bit offset: 30 desc: Port 0 pin 15 control.
    });
    // byte offset: 68 Pin mode select register 1
    pub const PINMODE1 = mmio(Address + 0x00000044, 32, packed struct {
        P0_16MODE: u2, // bit offset: 0 desc: Port 1 pin 16 control.
        P0_17MODE: u2, // bit offset: 2 desc: Port 1 pin 17 control.
        P0_18MODE: u2, // bit offset: 4 desc: Port 1 pin 18 control.
        P0_19MODE: u2, // bit offset: 6 desc: Port 1 pin 19 control.
        P0_20MODE: u2, // bit offset: 8 desc: Port 1 pin 20 control.
        P0_21MODE: u2, // bit offset: 10 desc: Port 1 pin 21 control.
        P0_22MODE: u2, // bit offset: 12 desc: Port 1 pin 22 control.
        P0_23MODE: u2, // bit offset: 14 desc: Port 1 pin 23 control.
        P0_24MODE: u2, // bit offset: 16 desc: Port 1 pin 24 control.
        P0_25MODE: u2, // bit offset: 18 desc: Port 1 pin 25 control.
        P0_26MODE: u2, // bit offset: 20 desc: Port 1 pin 26 control.
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 72 Pin mode select register 2
    pub const PINMODE2 = mmio(Address + 0x00000048, 32, packed struct {
        P1_00MODE: u2, // bit offset: 0 desc: Port 1 pin 0 control.
        P1_01MODE: u2, // bit offset: 2 desc: Port 1 pin 1 control.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P1_04MODE: u2, // bit offset: 8 desc: Port 1 pin 4 control.
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        P1_08MODE: u2, // bit offset: 16 desc: Port 1 pin 8 control.
        P1_09MODE: u2, // bit offset: 18 desc: Port 1 pin 9 control.
        P1_10MODE: u2, // bit offset: 20 desc: Port 1 pin 10 control.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        P1_14MODE: u2, // bit offset: 28 desc: Port 1 pin 14 control.
        P1_15MODE: u2, // bit offset: 30 desc: Port 1 pin 15 control.
    });
    // byte offset: 76 Pin mode select register 3.
    pub const PINMODE3 = mmio(Address + 0x0000004c, 32, packed struct {
        P1_16MODE: u2, // bit offset: 0 desc: Port 1 pin 16 control.
        P1_17MODE: u2, // bit offset: 2 desc: Port 1 pin 17 control.
        P1_18MODE: u2, // bit offset: 4 desc: Port 1 pin 18 control.
        P1_19MODE: u2, // bit offset: 6 desc: Port 1 pin 19 control.
        P1_20MODE: u2, // bit offset: 8 desc: Port 1 pin 20 control.
        P1_21MODE: u2, // bit offset: 10 desc: Port 1 pin 21 control.
        P1_22MODE: u2, // bit offset: 12 desc: Port 1 pin 22 control.
        P1_23MODE: u2, // bit offset: 14 desc: Port 1 pin 23 control.
        P1_24MODE: u2, // bit offset: 16 desc: Port 1 pin 24 control.
        P1_25MODE: u2, // bit offset: 18 desc: Port 1 pin 25 control.
        P1_26MODE: u2, // bit offset: 20 desc: Port 1 pin 26 control.
        P1_27MODE: u2, // bit offset: 22 desc: Port 1 pin 27 control.
        P1_28MODE: u2, // bit offset: 24 desc: Port 1 pin 28 control.
        P1_29MODE: u2, // bit offset: 26 desc: Port 1 pin 29 control.
        P1_30MODE: u2, // bit offset: 28 desc: Port 1 pin 30 control.
        P1_31MODE: u2, // bit offset: 30 desc: Port 1 pin 31 control.
    });
    // byte offset: 80 Pin mode select register 4
    pub const PINMODE4 = mmio(Address + 0x00000050, 32, packed struct {
        P2_00MODE: u2, // bit offset: 0 desc: Port 2 pin 0 control.
        P2_01MODE: u2, // bit offset: 2 desc: Port 2 pin 1 control.
        P2_02MODE: u2, // bit offset: 4 desc: Port 2 pin 2 control.
        P2_03MODE: u2, // bit offset: 6 desc: Port 2 pin 3 control.
        P2_04MODE: u2, // bit offset: 8 desc: Port 2 pin 4 control.
        P2_05MODE: u2, // bit offset: 10 desc: Port 2 pin 5 control.
        P2_06MODE: u2, // bit offset: 12 desc: Port 2 pin 6 control.
        P2_07MODE: u2, // bit offset: 14 desc: Port 2 pin 7 control.
        P2_08MODE: u2, // bit offset: 16 desc: Port 2 pin 8 control.
        P2_09MODE: u2, // bit offset: 18 desc: Port 2 pin 9 control.
        P2_10MODE: u2, // bit offset: 20 desc: Port 2 pin 10 control.
        P2_11MODE: u2, // bit offset: 22 desc: Port 2 pin 11 control.
        P2_12MODE: u2, // bit offset: 24 desc: Port 2 pin 12 control.
        P2_13MODE: u2, // bit offset: 26 desc: Port 2 pin 13 control.
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 92 Pin mode select register 7
    pub const PINMODE7 = mmio(Address + 0x0000005c, 32, packed struct {
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P3_25MODE: u2, // bit offset: 18 desc: Port 3 pin 25 control.
        P3_26MODE: u2, // bit offset: 20 desc: Port 3 pin 26 control.
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 100 Pin mode select register 9
    pub const PINMODE9 = mmio(Address + 0x00000064, 32, packed struct {
        reserved24: u1 = 0,
        reserved23: u1 = 0,
        reserved22: u1 = 0,
        reserved21: u1 = 0,
        reserved20: u1 = 0,
        reserved19: u1 = 0,
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P4_28MODE: u2, // bit offset: 24 desc: Port 4 pin 28 control.
        P4_29MODE: u2, // bit offset: 26 desc: Port 4 pin 29 control.
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 104 Open drain mode control register 0
    pub const PINMODE_OD0 = mmio(Address + 0x00000068, 32, packed struct {
        P0_00OD: bool, // bit offset: 0 desc: Port 0 pin 0 open drain mode control. Pins may potentially be used for I2C-buses using standard port pins. If so, they should be configured for open drain mode via the related bits in PINMODE_OD0.
        P0_01OD: bool, // bit offset: 1 desc: Port 0 pin 1 open drain mode control. Pins may potentially be used for I2C-buses using standard port pins. If so, they should be configured for open drain mode via the related bits in PINMODE_OD0.
        P0_02OD: bool, // bit offset: 2 desc: Port 0 pin 2 open drain mode control
        P0_03OD: bool, // bit offset: 3 desc: Port 0 pin 3 open drain mode control
        P0_04OD: bool, // bit offset: 4 desc: Port 0 pin 4 open drain mode control
        P0_05OD: bool, // bit offset: 5 desc: Port 0 pin 5 open drain mode control
        P0_06OD: bool, // bit offset: 6 desc: Port 0 pin 6 open drain mode control
        P0_07OD: bool, // bit offset: 7 desc: Port 0 pin 7 open drain mode control
        P0_08OD: bool, // bit offset: 8 desc: Port 0 pin 8 open drain mode control
        P0_09OD: bool, // bit offset: 9 desc: Port 0 pin 9 open drain mode control
        P0_10OD: bool, // bit offset: 10 desc: Port 0 pin 10 open drain mode control. Pins may potentially be used for I2C-buses using standard port pins. If so, they should be configured for open drain mode via the related bits in PINMODE_OD0.
        P0_11OD: bool, // bit offset: 11 desc: Port 0 pin 11 open drain mode control. Pins may potentially be used for I2C-buses using standard port pins. If so, they should be configured for open drain mode via the related bits in PINMODE_OD0.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P0_15OD: bool, // bit offset: 15 desc: Port 0 pin 15 open drain mode control
        P0_16OD: bool, // bit offset: 16 desc: Port 0 pin 16 open drain mode control
        P0_17OD: bool, // bit offset: 17 desc: Port 0 pin 17 open drain mode control
        P0_18OD: bool, // bit offset: 18 desc: Port 0 pin 18 open drain mode control
        P0_19OD: bool, // bit offset: 19 desc: Port 0 pin 19 open drain mode control. Pins may potentially be used for I2C-buses using standard port pins. If so, they should be configured for open drain mode via the related bits in PINMODE_OD0.
        P0_20OD: bool, // bit offset: 20 desc: Port 0 pin 20open drain mode control. Pins may potentially be used for I2C-buses using standard port pins. If so, they should be configured for open drain mode via the related bits in PINMODE_OD0.
        P0_21OD: bool, // bit offset: 21 desc: Port 0 pin 21 open drain mode control
        P0_22OD: bool, // bit offset: 22 desc: Port 0 pin 22 open drain mode control
        P0_23OD: bool, // bit offset: 23 desc: Port 0 pin 23 open drain mode control
        P0_24OD: bool, // bit offset: 24 desc: Port 0 pin 24open drain mode control
        P0_25OD: bool, // bit offset: 25 desc: Port 0 pin 25 open drain mode control
        P0_26OD: bool, // bit offset: 26 desc: Port 0 pin 26 open drain mode control
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        P0_29OD: bool, // bit offset: 29 desc: Port 0 pin 29 open drain mode control
        P0_30OD: bool, // bit offset: 30 desc: Port 0 pin 30 open drain mode control
        padding1: u1 = 0,
    });
    // byte offset: 108 Open drain mode control register 1
    pub const PINMODE_OD1 = mmio(Address + 0x0000006c, 32, packed struct {
        P1_00OD: bool, // bit offset: 0 desc: Port 1 pin 0 open drain mode control.
        P1_01OD: bool, // bit offset: 1 desc: Port 1 pin 1 open drain mode control, see P1.00OD
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P1_04OD: bool, // bit offset: 4 desc: Port 1 pin 4 open drain mode control, see P1.00OD
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        P1_08OD: bool, // bit offset: 8 desc: Port 1 pin 8 open drain mode control, see P1.00OD
        P1_09OD: bool, // bit offset: 9 desc: Port 1 pin 9 open drain mode control, see P1.00OD
        P1_10OD: bool, // bit offset: 10 desc: Port 1 pin 10 open drain mode control, see P1.00OD
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        P1_14OD: bool, // bit offset: 14 desc: Port 1 pin 14 open drain mode control, see P1.00OD
        P1_15OD: bool, // bit offset: 15 desc: Port 1 pin 15 open drain mode control, see P1.00OD
        P1_16OD: bool, // bit offset: 16 desc: Port 1 pin 16 open drain mode control, see P1.00OD
        P1_17OD: bool, // bit offset: 17 desc: Port 1 pin 17 open drain mode control, see P1.00OD
        P1_18OD: bool, // bit offset: 18 desc: Port 1 pin 18 open drain mode control, see P1.00OD
        P1_19OD: bool, // bit offset: 19 desc: Port 1 pin 19 open drain mode control, see P1.00OD
        P1_20OD: bool, // bit offset: 20 desc: Port 1 pin 20open drain mode control, see P1.00OD
        P1_21OD: bool, // bit offset: 21 desc: Port 1 pin 21 open drain mode control, see P1.00OD
        P1_22OD: bool, // bit offset: 22 desc: Port 1 pin 22 open drain mode control, see P1.00OD
        P1_23OD: bool, // bit offset: 23 desc: Port 1 pin 23 open drain mode control, see P1.00OD
        P1_24OD: bool, // bit offset: 24 desc: Port 1 pin 24open drain mode control, see P1.00OD
        P1_25OD: bool, // bit offset: 25 desc: Port 1 pin 25 open drain mode control, see P1.00OD
        P1_26OD: bool, // bit offset: 26 desc: Port 1 pin 26 open drain mode control, see P1.00OD
        P1_27OD: bool, // bit offset: 27 desc: Port 1 pin 27 open drain mode control, see P1.00OD
        P1_28OD: bool, // bit offset: 28 desc: Port 1 pin 28 open drain mode control, see P1.00OD
        P1_29OD: bool, // bit offset: 29 desc: Port 1 pin 29 open drain mode control, see P1.00OD
        P1_30OD: bool, // bit offset: 30 desc: Port 1 pin 30 open drain mode control, see P1.00OD
        P1_31OD: bool, // bit offset: 31 desc: Port 1 pin 31 open drain mode control.
    });
    // byte offset: 112 Open drain mode control register 2
    pub const PINMODE_OD2 = mmio(Address + 0x00000070, 32, packed struct {
        P2_00OD: bool, // bit offset: 0 desc: Port 2 pin 0 open drain mode control.
        P2_01OD: bool, // bit offset: 1 desc: Port 2 pin 1 open drain mode control, see P2.00OD
        P2_02OD: bool, // bit offset: 2 desc: Port 2 pin 2 open drain mode control, see P2.00OD
        P2_03OD: bool, // bit offset: 3 desc: Port 2 pin 3 open drain mode control, see P2.00OD
        P2_04OD: bool, // bit offset: 4 desc: Port 2 pin 4 open drain mode control, see P2.00OD
        P2_05OD: bool, // bit offset: 5 desc: Port 2 pin 5 open drain mode control, see P2.00OD
        P2_06OD: bool, // bit offset: 6 desc: Port 2 pin 6 open drain mode control, see P2.00OD
        P2_07OD: bool, // bit offset: 7 desc: Port 2 pin 7 open drain mode control, see P2.00OD
        P2_08OD: bool, // bit offset: 8 desc: Port 2 pin 8 open drain mode control, see P2.00OD
        P2_09OD: bool, // bit offset: 9 desc: Port 2 pin 9 open drain mode control, see P2.00OD
        P2_10OD: bool, // bit offset: 10 desc: Port 2 pin 10 open drain mode control, see P2.00OD
        P2_11OD: bool, // bit offset: 11 desc: Port 2 pin 11 open drain mode control, see P2.00OD
        P2_12OD: bool, // bit offset: 12 desc: Port 2 pin 12 open drain mode control, see P2.00OD
        P2_13OD: bool, // bit offset: 13 desc: Port 2 pin 13 open drain mode control, see P2.00OD
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 116 Open drain mode control register 3
    pub const PINMODE_OD3 = mmio(Address + 0x00000074, 32, packed struct {
        reserved25: u1 = 0,
        reserved24: u1 = 0,
        reserved23: u1 = 0,
        reserved22: u1 = 0,
        reserved21: u1 = 0,
        reserved20: u1 = 0,
        reserved19: u1 = 0,
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P3_25OD: bool, // bit offset: 25 desc: Port 3 pin 25 open drain mode control.
        P3_26OD: bool, // bit offset: 26 desc: Port 3 pin 26 open drain mode control, see P3.25OD
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 120 Open drain mode control register 4
    pub const PINMODE_OD4 = mmio(Address + 0x00000078, 32, packed struct {
        reserved28: u1 = 0,
        reserved27: u1 = 0,
        reserved26: u1 = 0,
        reserved25: u1 = 0,
        reserved24: u1 = 0,
        reserved23: u1 = 0,
        reserved22: u1 = 0,
        reserved21: u1 = 0,
        reserved20: u1 = 0,
        reserved19: u1 = 0,
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        P4_28OD: bool, // bit offset: 28 desc: Port 4 pin 28 open drain mode control.
        P4_29OD: bool, // bit offset: 29 desc: Port 4 pin 29 open drain mode control, see P4.28OD
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 124 I2C Pin Configuration register
    pub const I2CPADCFG = mmio(Address + 0x0000007c, 32, packed struct {
        SDADRV0: bool, // bit offset: 0 desc: Drive mode control for the SDA0 pin, P0.27.
        SDAI2C0: bool, // bit offset: 1 desc: I 2C filter mode control for the SDA0 pin, P0.27.
        SCLDRV0: bool, // bit offset: 2 desc: Drive mode control for the SCL0 pin, P0.28.
        SCLI2C0: bool, // bit offset: 3 desc: I 2C filter mode control for the SCL0 pin, P0.28.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const SSP1 = extern struct {
    pub const Address: u32 = 0x40030000;
    // byte offset: 0 Control Register 0. Selects the serial clock rate, bus type, and data size.
    pub const CR0 = mmio(Address + 0x00000000, 32, packed struct {
        DSS: u4, // bit offset: 0 desc: Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used.
        FRF: u2, // bit offset: 4 desc: Frame Format.
        CPOL: bool, // bit offset: 6 desc: Clock Out Polarity. This bit is only used in SPI mode.
        CPHA: bool, // bit offset: 7 desc: Clock Out Phase. This bit is only used in SPI mode.
        SCR: u8, // bit offset: 8 desc: Serial Clock Rate. The number of prescaler-output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X [SCR+1]).
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Control Register 1. Selects master/slave and other modes.
    pub const CR1 = mmio(Address + 0x00000004, 32, packed struct {
        LBM: bool, // bit offset: 0 desc: Loop Back Mode.
        SSE: bool, // bit offset: 1 desc: SSP Enable.
        MS: bool, // bit offset: 2 desc: Master/Slave Mode.This bit can only be written when the SSE bit is 0.
        SOD: bool, // bit offset: 3 desc: Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SSP controller from driving the transmit data line (MISO).
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
    pub const DR = mmio(Address + 0x00000008, 32, packed struct {
        DATA: u16, // bit offset: 0 desc: Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SSP controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bits, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SSP controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bits, the data is right-justified in this field with higher order bits filled with 0s.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Status Register
    pub const SR = mmio(Address + 0x0000000c, 32, packed struct {
        TFE: bool, // bit offset: 0 desc: Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not.
        TNF: bool, // bit offset: 1 desc: Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not.
        RNE: bool, // bit offset: 2 desc: Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not.
        RFF: bool, // bit offset: 3 desc: Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not.
        BSY: bool, // bit offset: 4 desc: Busy. This bit is 0 if the SSPn controller is idle, or 1 if it is currently sending/receiving a frame and/or the Tx FIFO is not empty.
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 Clock Prescale Register
    pub const CPSR = mmio(Address + 0x00000010, 32, packed struct {
        CPSDVSR: u8, // bit offset: 0 desc: This even value between 2 and 254, by which PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Interrupt Mask Set and Clear Register
    pub const IMSC = mmio(Address + 0x00000014, 32, packed struct {
        RORIM: bool, // bit offset: 0 desc: Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.
        RTIM: bool, // bit offset: 1 desc: Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
        RXIM: bool, // bit offset: 2 desc: Software should set this bit to enable interrupt when the Rx FIFO is at least half full.
        TXIM: bool, // bit offset: 3 desc: Software should set this bit to enable interrupt when the Tx FIFO is at least half empty.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Raw Interrupt Status Register
    pub const RIS = mmio(Address + 0x00000018, 32, packed struct {
        RORRIS: bool, // bit offset: 0 desc: This bit is 1 if another frame was completely received while the RxFIFO was full. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.
        RTRIS: bool, // bit offset: 1 desc: This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
        RXRIS: bool, // bit offset: 2 desc: This bit is 1 if the Rx FIFO is at least half full.
        TXRIS: bool, // bit offset: 3 desc: This bit is 1 if the Tx FIFO is at least half empty.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Masked Interrupt Status Register
    pub const MIS = mmio(Address + 0x0000001c, 32, packed struct {
        RORMIS: bool, // bit offset: 0 desc: This bit is 1 if another frame was completely received while the RxFIFO was full, and this interrupt is enabled.
        RTMIS: bool, // bit offset: 1 desc: This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out period, and this interrupt is enabled. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
        RXMIS: bool, // bit offset: 2 desc: This bit is 1 if the Rx FIFO is at least half full, and this interrupt is enabled.
        TXMIS: bool, // bit offset: 3 desc: This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is enabled.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 SSPICR Interrupt Clear Register
    pub const ICR = mmio(Address + 0x00000020, 32, packed struct {
        RORIC: bool, // bit offset: 0 desc: Writing a 1 to this bit clears the frame was received when RxFIFO was full interrupt.
        RTIC: bool, // bit offset: 1 desc: Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read for a time-out period interrupt. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR / [SCR+1]).
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 SSP0 DMA control register
    pub const DMACR = mmio(Address + 0x00000024, 32, packed struct {
        RXDMAE: bool, // bit offset: 0 desc: Receive DMA Enable. When this bit is set to one 1, DMA for the receive FIFO is enabled, otherwise receive DMA is disabled.
        TXDMAE: bool, // bit offset: 1 desc: Transmit DMA Enable. When this bit is set to one 1, DMA for the transmit FIFO is enabled, otherwise transmit DMA is disabled
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const ADC = extern struct {
    pub const Address: u32 = 0x40034000;
    // byte offset: 0 A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
    pub const CR = mmio(Address + 0x00000000, 32, packed struct {
        SEL: u8, // bit offset: 0 desc: Selects which of the AD0[7:0] pins is (are) to be sampled and converted. For AD0, bit 0 selects Pin AD0[0], and bit 7 selects pin AD0[7]. In software-controlled mode, only one of these bits should be 1. In hardware scan mode, any value containing 1 to 8 ones is allowed. All zeroes is equivalent to 0x01.
        CLKDIV: u8, // bit offset: 8 desc: The APB clock (PCLK) is divided by (this value plus one) to produce the clock for the A/D converter, which should be less than or equal to 12.4 MHz. Typically, software should program the smallest value in this field that yields a clock of 12.4 MHz or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable.
        BURST: bool, // bit offset: 16 desc: Burst mode
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PDN: bool, // bit offset: 21 desc: Power down mode
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        START: u3, // bit offset: 24 desc: When the BURST bit is 0, these bits control whether and when an A/D conversion is started:
        EDGE: bool, // bit offset: 27 desc: This bit is significant only when the START field contains 010-111. In these cases:
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 A/D Global Data Register. This register contains the ADC's DONE bit and the result of the most recent A/D conversion.
    pub const GDR = mmio(Address + 0x00000004, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin selected by the SEL field, as it falls within the range of VREFP to VSS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        CHN: u3, // bit offset: 24 desc: These bits contain the channel from which the RESULT bits were converted (e.g. 000 identifies channel 0, 001 channel 1...).
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits. This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read and when the ADCR is written. If the ADCR is written while a conversion is still in progress, this bit is set and a new conversion is started.
    });
    // byte offset: 12 A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
    pub const INTEN = mmio(Address + 0x0000000c, 32, packed struct {
        ADINTEN0: bool, // bit offset: 0 desc: Interrupt enable
        ADINTEN1: bool, // bit offset: 1 desc: Interrupt enable
        ADINTEN2: bool, // bit offset: 2 desc: Interrupt enable
        ADINTEN3: bool, // bit offset: 3 desc: Interrupt enable
        ADINTEN4: bool, // bit offset: 4 desc: Interrupt enable
        ADINTEN5: bool, // bit offset: 5 desc: Interrupt enable
        ADINTEN6: bool, // bit offset: 6 desc: Interrupt enable
        ADINTEN7: bool, // bit offset: 7 desc: Interrupt enable
        ADGINTEN: bool, // bit offset: 8 desc: Interrupt enable
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_0 = mmio(Address + 0x00000010, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 20 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_1 = mmio(Address + 0x00000014, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 24 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_2 = mmio(Address + 0x00000018, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 28 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_3 = mmio(Address + 0x0000001c, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 32 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_4 = mmio(Address + 0x00000020, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 36 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_5 = mmio(Address + 0x00000024, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 40 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_6 = mmio(Address + 0x00000028, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 44 A/D Channel 0 Data Register. This register contains the result of the most recent conversion completed on channel 0.
    pub const DR_7 = mmio(Address + 0x0000002c, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESULT: u12, // bit offset: 4 desc: When DONE is 1, this field contains a binary fraction representing the voltage on the AD0[n] pin, as it falls within the range of VREFP to V SS. Zero in the field indicates that the voltage on the input pin was less than, equal to, or close to that on VSS, while 0xFFF indicates that the voltage on the input was close to, equal to, or greater than that on VREFP.
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        OVERRUN: bool, // bit offset: 30 desc: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the RESULT bits.This bit is cleared by reading this register.
        DONE: bool, // bit offset: 31 desc: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    });
    // byte offset: 48 A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt/DMA flag.
    pub const STAT = mmio(Address + 0x00000030, 32, packed struct {
        DONE0: bool, // bit offset: 0 desc: This bit mirrors the DONE status flag from the result register for A/D channel 0.
        DONE1: bool, // bit offset: 1 desc: This bit mirrors the DONE status flag from the result register for A/D channel 1.
        DONE2: bool, // bit offset: 2 desc: This bit mirrors the DONE status flag from the result register for A/D channel 2.
        DONE3: bool, // bit offset: 3 desc: This bit mirrors the DONE status flag from the result register for A/D channel 3.
        DONE4: bool, // bit offset: 4 desc: This bit mirrors the DONE status flag from the result register for A/D channel 4.
        DONE5: bool, // bit offset: 5 desc: This bit mirrors the DONE status flag from the result register for A/D channel 5.
        DONE6: bool, // bit offset: 6 desc: This bit mirrors the DONE status flag from the result register for A/D channel 6.
        DONE7: bool, // bit offset: 7 desc: This bit mirrors the DONE status flag from the result register for A/D channel 7.
        OVERRUN0: bool, // bit offset: 8 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 0.
        OVERRUN1: bool, // bit offset: 9 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 1.
        OVERRUN2: bool, // bit offset: 10 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 2.
        OVERRUN3: bool, // bit offset: 11 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 3.
        OVERRUN4: bool, // bit offset: 12 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 4.
        OVERRUN5: bool, // bit offset: 13 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 5.
        OVERRUN6: bool, // bit offset: 14 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 6.
        OVERRUN7: bool, // bit offset: 15 desc: This bit mirrors the OVERRRUN status flag from the result register for A/D channel 7.
        ADINT: bool, // bit offset: 16 desc: This bit is the A/D interrupt flag. It is one when any of the individual A/D channel Done flags is asserted and enabled to contribute to the A/D interrupt via the ADINTEN register.
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 52 ADC trim register.
    pub const TRM = mmio(Address + 0x00000034, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ADCOFFS: u4, // bit offset: 4 desc: Offset trim bits for ADC operation. Initialized by the boot code. Can be overwritten by the user.
        TRIM: u4, // bit offset: 8 desc: written-to by boot code. Can not be overwritten by the user. These bits are locked after boot code write.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const CANAFRAM = extern struct {
    pub const Address: u32 = 0x40038000;
    // byte offset: 0 CAN AF ram access register
    pub const MASK_0 = mmio(Address + 0x00000000, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 4 CAN AF ram access register
    pub const MASK_1 = mmio(Address + 0x00000004, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 8 CAN AF ram access register
    pub const MASK_2 = mmio(Address + 0x00000008, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 12 CAN AF ram access register
    pub const MASK_3 = mmio(Address + 0x0000000c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 16 CAN AF ram access register
    pub const MASK_4 = mmio(Address + 0x00000010, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 20 CAN AF ram access register
    pub const MASK_5 = mmio(Address + 0x00000014, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 24 CAN AF ram access register
    pub const MASK_6 = mmio(Address + 0x00000018, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 28 CAN AF ram access register
    pub const MASK_7 = mmio(Address + 0x0000001c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 32 CAN AF ram access register
    pub const MASK_8 = mmio(Address + 0x00000020, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 36 CAN AF ram access register
    pub const MASK_9 = mmio(Address + 0x00000024, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 40 CAN AF ram access register
    pub const MASK_10 = mmio(Address + 0x00000028, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 44 CAN AF ram access register
    pub const MASK_11 = mmio(Address + 0x0000002c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 48 CAN AF ram access register
    pub const MASK_12 = mmio(Address + 0x00000030, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 52 CAN AF ram access register
    pub const MASK_13 = mmio(Address + 0x00000034, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 56 CAN AF ram access register
    pub const MASK_14 = mmio(Address + 0x00000038, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 60 CAN AF ram access register
    pub const MASK_15 = mmio(Address + 0x0000003c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 64 CAN AF ram access register
    pub const MASK_16 = mmio(Address + 0x00000040, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 68 CAN AF ram access register
    pub const MASK_17 = mmio(Address + 0x00000044, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 72 CAN AF ram access register
    pub const MASK_18 = mmio(Address + 0x00000048, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 76 CAN AF ram access register
    pub const MASK_19 = mmio(Address + 0x0000004c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 80 CAN AF ram access register
    pub const MASK_20 = mmio(Address + 0x00000050, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 84 CAN AF ram access register
    pub const MASK_21 = mmio(Address + 0x00000054, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 88 CAN AF ram access register
    pub const MASK_22 = mmio(Address + 0x00000058, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 92 CAN AF ram access register
    pub const MASK_23 = mmio(Address + 0x0000005c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 96 CAN AF ram access register
    pub const MASK_24 = mmio(Address + 0x00000060, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 100 CAN AF ram access register
    pub const MASK_25 = mmio(Address + 0x00000064, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 104 CAN AF ram access register
    pub const MASK_26 = mmio(Address + 0x00000068, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 108 CAN AF ram access register
    pub const MASK_27 = mmio(Address + 0x0000006c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 112 CAN AF ram access register
    pub const MASK_28 = mmio(Address + 0x00000070, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 116 CAN AF ram access register
    pub const MASK_29 = mmio(Address + 0x00000074, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 120 CAN AF ram access register
    pub const MASK_30 = mmio(Address + 0x00000078, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 124 CAN AF ram access register
    pub const MASK_31 = mmio(Address + 0x0000007c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 128 CAN AF ram access register
    pub const MASK_32 = mmio(Address + 0x00000080, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 132 CAN AF ram access register
    pub const MASK_33 = mmio(Address + 0x00000084, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 136 CAN AF ram access register
    pub const MASK_34 = mmio(Address + 0x00000088, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 140 CAN AF ram access register
    pub const MASK_35 = mmio(Address + 0x0000008c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 144 CAN AF ram access register
    pub const MASK_36 = mmio(Address + 0x00000090, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 148 CAN AF ram access register
    pub const MASK_37 = mmio(Address + 0x00000094, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 152 CAN AF ram access register
    pub const MASK_38 = mmio(Address + 0x00000098, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 156 CAN AF ram access register
    pub const MASK_39 = mmio(Address + 0x0000009c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 160 CAN AF ram access register
    pub const MASK_40 = mmio(Address + 0x000000a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 164 CAN AF ram access register
    pub const MASK_41 = mmio(Address + 0x000000a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 168 CAN AF ram access register
    pub const MASK_42 = mmio(Address + 0x000000a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 172 CAN AF ram access register
    pub const MASK_43 = mmio(Address + 0x000000ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 176 CAN AF ram access register
    pub const MASK_44 = mmio(Address + 0x000000b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 180 CAN AF ram access register
    pub const MASK_45 = mmio(Address + 0x000000b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 184 CAN AF ram access register
    pub const MASK_46 = mmio(Address + 0x000000b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 188 CAN AF ram access register
    pub const MASK_47 = mmio(Address + 0x000000bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 192 CAN AF ram access register
    pub const MASK_48 = mmio(Address + 0x000000c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 196 CAN AF ram access register
    pub const MASK_49 = mmio(Address + 0x000000c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 200 CAN AF ram access register
    pub const MASK_50 = mmio(Address + 0x000000c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 204 CAN AF ram access register
    pub const MASK_51 = mmio(Address + 0x000000cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 208 CAN AF ram access register
    pub const MASK_52 = mmio(Address + 0x000000d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 212 CAN AF ram access register
    pub const MASK_53 = mmio(Address + 0x000000d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 216 CAN AF ram access register
    pub const MASK_54 = mmio(Address + 0x000000d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 220 CAN AF ram access register
    pub const MASK_55 = mmio(Address + 0x000000dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 224 CAN AF ram access register
    pub const MASK_56 = mmio(Address + 0x000000e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 228 CAN AF ram access register
    pub const MASK_57 = mmio(Address + 0x000000e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 232 CAN AF ram access register
    pub const MASK_58 = mmio(Address + 0x000000e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 236 CAN AF ram access register
    pub const MASK_59 = mmio(Address + 0x000000ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 240 CAN AF ram access register
    pub const MASK_60 = mmio(Address + 0x000000f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 244 CAN AF ram access register
    pub const MASK_61 = mmio(Address + 0x000000f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 248 CAN AF ram access register
    pub const MASK_62 = mmio(Address + 0x000000f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 252 CAN AF ram access register
    pub const MASK_63 = mmio(Address + 0x000000fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 256 CAN AF ram access register
    pub const MASK_64 = mmio(Address + 0x00000100, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 260 CAN AF ram access register
    pub const MASK_65 = mmio(Address + 0x00000104, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 264 CAN AF ram access register
    pub const MASK_66 = mmio(Address + 0x00000108, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 268 CAN AF ram access register
    pub const MASK_67 = mmio(Address + 0x0000010c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 272 CAN AF ram access register
    pub const MASK_68 = mmio(Address + 0x00000110, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 276 CAN AF ram access register
    pub const MASK_69 = mmio(Address + 0x00000114, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 280 CAN AF ram access register
    pub const MASK_70 = mmio(Address + 0x00000118, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 284 CAN AF ram access register
    pub const MASK_71 = mmio(Address + 0x0000011c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 288 CAN AF ram access register
    pub const MASK_72 = mmio(Address + 0x00000120, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 292 CAN AF ram access register
    pub const MASK_73 = mmio(Address + 0x00000124, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 296 CAN AF ram access register
    pub const MASK_74 = mmio(Address + 0x00000128, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 300 CAN AF ram access register
    pub const MASK_75 = mmio(Address + 0x0000012c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 304 CAN AF ram access register
    pub const MASK_76 = mmio(Address + 0x00000130, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 308 CAN AF ram access register
    pub const MASK_77 = mmio(Address + 0x00000134, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 312 CAN AF ram access register
    pub const MASK_78 = mmio(Address + 0x00000138, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 316 CAN AF ram access register
    pub const MASK_79 = mmio(Address + 0x0000013c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 320 CAN AF ram access register
    pub const MASK_80 = mmio(Address + 0x00000140, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 324 CAN AF ram access register
    pub const MASK_81 = mmio(Address + 0x00000144, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 328 CAN AF ram access register
    pub const MASK_82 = mmio(Address + 0x00000148, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 332 CAN AF ram access register
    pub const MASK_83 = mmio(Address + 0x0000014c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 336 CAN AF ram access register
    pub const MASK_84 = mmio(Address + 0x00000150, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 340 CAN AF ram access register
    pub const MASK_85 = mmio(Address + 0x00000154, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 344 CAN AF ram access register
    pub const MASK_86 = mmio(Address + 0x00000158, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 348 CAN AF ram access register
    pub const MASK_87 = mmio(Address + 0x0000015c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 352 CAN AF ram access register
    pub const MASK_88 = mmio(Address + 0x00000160, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 356 CAN AF ram access register
    pub const MASK_89 = mmio(Address + 0x00000164, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 360 CAN AF ram access register
    pub const MASK_90 = mmio(Address + 0x00000168, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 364 CAN AF ram access register
    pub const MASK_91 = mmio(Address + 0x0000016c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 368 CAN AF ram access register
    pub const MASK_92 = mmio(Address + 0x00000170, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 372 CAN AF ram access register
    pub const MASK_93 = mmio(Address + 0x00000174, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 376 CAN AF ram access register
    pub const MASK_94 = mmio(Address + 0x00000178, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 380 CAN AF ram access register
    pub const MASK_95 = mmio(Address + 0x0000017c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 384 CAN AF ram access register
    pub const MASK_96 = mmio(Address + 0x00000180, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 388 CAN AF ram access register
    pub const MASK_97 = mmio(Address + 0x00000184, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 392 CAN AF ram access register
    pub const MASK_98 = mmio(Address + 0x00000188, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 396 CAN AF ram access register
    pub const MASK_99 = mmio(Address + 0x0000018c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 400 CAN AF ram access register
    pub const MASK_100 = mmio(Address + 0x00000190, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 404 CAN AF ram access register
    pub const MASK_101 = mmio(Address + 0x00000194, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 408 CAN AF ram access register
    pub const MASK_102 = mmio(Address + 0x00000198, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 412 CAN AF ram access register
    pub const MASK_103 = mmio(Address + 0x0000019c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 416 CAN AF ram access register
    pub const MASK_104 = mmio(Address + 0x000001a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 420 CAN AF ram access register
    pub const MASK_105 = mmio(Address + 0x000001a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 424 CAN AF ram access register
    pub const MASK_106 = mmio(Address + 0x000001a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 428 CAN AF ram access register
    pub const MASK_107 = mmio(Address + 0x000001ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 432 CAN AF ram access register
    pub const MASK_108 = mmio(Address + 0x000001b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 436 CAN AF ram access register
    pub const MASK_109 = mmio(Address + 0x000001b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 440 CAN AF ram access register
    pub const MASK_110 = mmio(Address + 0x000001b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 444 CAN AF ram access register
    pub const MASK_111 = mmio(Address + 0x000001bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 448 CAN AF ram access register
    pub const MASK_112 = mmio(Address + 0x000001c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 452 CAN AF ram access register
    pub const MASK_113 = mmio(Address + 0x000001c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 456 CAN AF ram access register
    pub const MASK_114 = mmio(Address + 0x000001c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 460 CAN AF ram access register
    pub const MASK_115 = mmio(Address + 0x000001cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 464 CAN AF ram access register
    pub const MASK_116 = mmio(Address + 0x000001d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 468 CAN AF ram access register
    pub const MASK_117 = mmio(Address + 0x000001d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 472 CAN AF ram access register
    pub const MASK_118 = mmio(Address + 0x000001d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 476 CAN AF ram access register
    pub const MASK_119 = mmio(Address + 0x000001dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 480 CAN AF ram access register
    pub const MASK_120 = mmio(Address + 0x000001e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 484 CAN AF ram access register
    pub const MASK_121 = mmio(Address + 0x000001e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 488 CAN AF ram access register
    pub const MASK_122 = mmio(Address + 0x000001e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 492 CAN AF ram access register
    pub const MASK_123 = mmio(Address + 0x000001ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 496 CAN AF ram access register
    pub const MASK_124 = mmio(Address + 0x000001f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 500 CAN AF ram access register
    pub const MASK_125 = mmio(Address + 0x000001f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 504 CAN AF ram access register
    pub const MASK_126 = mmio(Address + 0x000001f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 508 CAN AF ram access register
    pub const MASK_127 = mmio(Address + 0x000001fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 512 CAN AF ram access register
    pub const MASK_128 = mmio(Address + 0x00000200, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 516 CAN AF ram access register
    pub const MASK_129 = mmio(Address + 0x00000204, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 520 CAN AF ram access register
    pub const MASK_130 = mmio(Address + 0x00000208, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 524 CAN AF ram access register
    pub const MASK_131 = mmio(Address + 0x0000020c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 528 CAN AF ram access register
    pub const MASK_132 = mmio(Address + 0x00000210, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 532 CAN AF ram access register
    pub const MASK_133 = mmio(Address + 0x00000214, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 536 CAN AF ram access register
    pub const MASK_134 = mmio(Address + 0x00000218, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 540 CAN AF ram access register
    pub const MASK_135 = mmio(Address + 0x0000021c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 544 CAN AF ram access register
    pub const MASK_136 = mmio(Address + 0x00000220, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 548 CAN AF ram access register
    pub const MASK_137 = mmio(Address + 0x00000224, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 552 CAN AF ram access register
    pub const MASK_138 = mmio(Address + 0x00000228, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 556 CAN AF ram access register
    pub const MASK_139 = mmio(Address + 0x0000022c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 560 CAN AF ram access register
    pub const MASK_140 = mmio(Address + 0x00000230, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 564 CAN AF ram access register
    pub const MASK_141 = mmio(Address + 0x00000234, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 568 CAN AF ram access register
    pub const MASK_142 = mmio(Address + 0x00000238, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 572 CAN AF ram access register
    pub const MASK_143 = mmio(Address + 0x0000023c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 576 CAN AF ram access register
    pub const MASK_144 = mmio(Address + 0x00000240, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 580 CAN AF ram access register
    pub const MASK_145 = mmio(Address + 0x00000244, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 584 CAN AF ram access register
    pub const MASK_146 = mmio(Address + 0x00000248, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 588 CAN AF ram access register
    pub const MASK_147 = mmio(Address + 0x0000024c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 592 CAN AF ram access register
    pub const MASK_148 = mmio(Address + 0x00000250, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 596 CAN AF ram access register
    pub const MASK_149 = mmio(Address + 0x00000254, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 600 CAN AF ram access register
    pub const MASK_150 = mmio(Address + 0x00000258, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 604 CAN AF ram access register
    pub const MASK_151 = mmio(Address + 0x0000025c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 608 CAN AF ram access register
    pub const MASK_152 = mmio(Address + 0x00000260, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 612 CAN AF ram access register
    pub const MASK_153 = mmio(Address + 0x00000264, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 616 CAN AF ram access register
    pub const MASK_154 = mmio(Address + 0x00000268, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 620 CAN AF ram access register
    pub const MASK_155 = mmio(Address + 0x0000026c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 624 CAN AF ram access register
    pub const MASK_156 = mmio(Address + 0x00000270, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 628 CAN AF ram access register
    pub const MASK_157 = mmio(Address + 0x00000274, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 632 CAN AF ram access register
    pub const MASK_158 = mmio(Address + 0x00000278, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 636 CAN AF ram access register
    pub const MASK_159 = mmio(Address + 0x0000027c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 640 CAN AF ram access register
    pub const MASK_160 = mmio(Address + 0x00000280, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 644 CAN AF ram access register
    pub const MASK_161 = mmio(Address + 0x00000284, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 648 CAN AF ram access register
    pub const MASK_162 = mmio(Address + 0x00000288, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 652 CAN AF ram access register
    pub const MASK_163 = mmio(Address + 0x0000028c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 656 CAN AF ram access register
    pub const MASK_164 = mmio(Address + 0x00000290, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 660 CAN AF ram access register
    pub const MASK_165 = mmio(Address + 0x00000294, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 664 CAN AF ram access register
    pub const MASK_166 = mmio(Address + 0x00000298, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 668 CAN AF ram access register
    pub const MASK_167 = mmio(Address + 0x0000029c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 672 CAN AF ram access register
    pub const MASK_168 = mmio(Address + 0x000002a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 676 CAN AF ram access register
    pub const MASK_169 = mmio(Address + 0x000002a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 680 CAN AF ram access register
    pub const MASK_170 = mmio(Address + 0x000002a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 684 CAN AF ram access register
    pub const MASK_171 = mmio(Address + 0x000002ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 688 CAN AF ram access register
    pub const MASK_172 = mmio(Address + 0x000002b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 692 CAN AF ram access register
    pub const MASK_173 = mmio(Address + 0x000002b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 696 CAN AF ram access register
    pub const MASK_174 = mmio(Address + 0x000002b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 700 CAN AF ram access register
    pub const MASK_175 = mmio(Address + 0x000002bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 704 CAN AF ram access register
    pub const MASK_176 = mmio(Address + 0x000002c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 708 CAN AF ram access register
    pub const MASK_177 = mmio(Address + 0x000002c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 712 CAN AF ram access register
    pub const MASK_178 = mmio(Address + 0x000002c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 716 CAN AF ram access register
    pub const MASK_179 = mmio(Address + 0x000002cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 720 CAN AF ram access register
    pub const MASK_180 = mmio(Address + 0x000002d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 724 CAN AF ram access register
    pub const MASK_181 = mmio(Address + 0x000002d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 728 CAN AF ram access register
    pub const MASK_182 = mmio(Address + 0x000002d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 732 CAN AF ram access register
    pub const MASK_183 = mmio(Address + 0x000002dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 736 CAN AF ram access register
    pub const MASK_184 = mmio(Address + 0x000002e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 740 CAN AF ram access register
    pub const MASK_185 = mmio(Address + 0x000002e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 744 CAN AF ram access register
    pub const MASK_186 = mmio(Address + 0x000002e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 748 CAN AF ram access register
    pub const MASK_187 = mmio(Address + 0x000002ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 752 CAN AF ram access register
    pub const MASK_188 = mmio(Address + 0x000002f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 756 CAN AF ram access register
    pub const MASK_189 = mmio(Address + 0x000002f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 760 CAN AF ram access register
    pub const MASK_190 = mmio(Address + 0x000002f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 764 CAN AF ram access register
    pub const MASK_191 = mmio(Address + 0x000002fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 768 CAN AF ram access register
    pub const MASK_192 = mmio(Address + 0x00000300, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 772 CAN AF ram access register
    pub const MASK_193 = mmio(Address + 0x00000304, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 776 CAN AF ram access register
    pub const MASK_194 = mmio(Address + 0x00000308, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 780 CAN AF ram access register
    pub const MASK_195 = mmio(Address + 0x0000030c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 784 CAN AF ram access register
    pub const MASK_196 = mmio(Address + 0x00000310, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 788 CAN AF ram access register
    pub const MASK_197 = mmio(Address + 0x00000314, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 792 CAN AF ram access register
    pub const MASK_198 = mmio(Address + 0x00000318, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 796 CAN AF ram access register
    pub const MASK_199 = mmio(Address + 0x0000031c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 800 CAN AF ram access register
    pub const MASK_200 = mmio(Address + 0x00000320, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 804 CAN AF ram access register
    pub const MASK_201 = mmio(Address + 0x00000324, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 808 CAN AF ram access register
    pub const MASK_202 = mmio(Address + 0x00000328, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 812 CAN AF ram access register
    pub const MASK_203 = mmio(Address + 0x0000032c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 816 CAN AF ram access register
    pub const MASK_204 = mmio(Address + 0x00000330, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 820 CAN AF ram access register
    pub const MASK_205 = mmio(Address + 0x00000334, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 824 CAN AF ram access register
    pub const MASK_206 = mmio(Address + 0x00000338, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 828 CAN AF ram access register
    pub const MASK_207 = mmio(Address + 0x0000033c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 832 CAN AF ram access register
    pub const MASK_208 = mmio(Address + 0x00000340, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 836 CAN AF ram access register
    pub const MASK_209 = mmio(Address + 0x00000344, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 840 CAN AF ram access register
    pub const MASK_210 = mmio(Address + 0x00000348, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 844 CAN AF ram access register
    pub const MASK_211 = mmio(Address + 0x0000034c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 848 CAN AF ram access register
    pub const MASK_212 = mmio(Address + 0x00000350, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 852 CAN AF ram access register
    pub const MASK_213 = mmio(Address + 0x00000354, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 856 CAN AF ram access register
    pub const MASK_214 = mmio(Address + 0x00000358, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 860 CAN AF ram access register
    pub const MASK_215 = mmio(Address + 0x0000035c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 864 CAN AF ram access register
    pub const MASK_216 = mmio(Address + 0x00000360, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 868 CAN AF ram access register
    pub const MASK_217 = mmio(Address + 0x00000364, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 872 CAN AF ram access register
    pub const MASK_218 = mmio(Address + 0x00000368, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 876 CAN AF ram access register
    pub const MASK_219 = mmio(Address + 0x0000036c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 880 CAN AF ram access register
    pub const MASK_220 = mmio(Address + 0x00000370, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 884 CAN AF ram access register
    pub const MASK_221 = mmio(Address + 0x00000374, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 888 CAN AF ram access register
    pub const MASK_222 = mmio(Address + 0x00000378, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 892 CAN AF ram access register
    pub const MASK_223 = mmio(Address + 0x0000037c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 896 CAN AF ram access register
    pub const MASK_224 = mmio(Address + 0x00000380, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 900 CAN AF ram access register
    pub const MASK_225 = mmio(Address + 0x00000384, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 904 CAN AF ram access register
    pub const MASK_226 = mmio(Address + 0x00000388, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 908 CAN AF ram access register
    pub const MASK_227 = mmio(Address + 0x0000038c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 912 CAN AF ram access register
    pub const MASK_228 = mmio(Address + 0x00000390, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 916 CAN AF ram access register
    pub const MASK_229 = mmio(Address + 0x00000394, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 920 CAN AF ram access register
    pub const MASK_230 = mmio(Address + 0x00000398, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 924 CAN AF ram access register
    pub const MASK_231 = mmio(Address + 0x0000039c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 928 CAN AF ram access register
    pub const MASK_232 = mmio(Address + 0x000003a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 932 CAN AF ram access register
    pub const MASK_233 = mmio(Address + 0x000003a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 936 CAN AF ram access register
    pub const MASK_234 = mmio(Address + 0x000003a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 940 CAN AF ram access register
    pub const MASK_235 = mmio(Address + 0x000003ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 944 CAN AF ram access register
    pub const MASK_236 = mmio(Address + 0x000003b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 948 CAN AF ram access register
    pub const MASK_237 = mmio(Address + 0x000003b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 952 CAN AF ram access register
    pub const MASK_238 = mmio(Address + 0x000003b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 956 CAN AF ram access register
    pub const MASK_239 = mmio(Address + 0x000003bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 960 CAN AF ram access register
    pub const MASK_240 = mmio(Address + 0x000003c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 964 CAN AF ram access register
    pub const MASK_241 = mmio(Address + 0x000003c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 968 CAN AF ram access register
    pub const MASK_242 = mmio(Address + 0x000003c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 972 CAN AF ram access register
    pub const MASK_243 = mmio(Address + 0x000003cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 976 CAN AF ram access register
    pub const MASK_244 = mmio(Address + 0x000003d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 980 CAN AF ram access register
    pub const MASK_245 = mmio(Address + 0x000003d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 984 CAN AF ram access register
    pub const MASK_246 = mmio(Address + 0x000003d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 988 CAN AF ram access register
    pub const MASK_247 = mmio(Address + 0x000003dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 992 CAN AF ram access register
    pub const MASK_248 = mmio(Address + 0x000003e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 996 CAN AF ram access register
    pub const MASK_249 = mmio(Address + 0x000003e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1000 CAN AF ram access register
    pub const MASK_250 = mmio(Address + 0x000003e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1004 CAN AF ram access register
    pub const MASK_251 = mmio(Address + 0x000003ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1008 CAN AF ram access register
    pub const MASK_252 = mmio(Address + 0x000003f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1012 CAN AF ram access register
    pub const MASK_253 = mmio(Address + 0x000003f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1016 CAN AF ram access register
    pub const MASK_254 = mmio(Address + 0x000003f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1020 CAN AF ram access register
    pub const MASK_255 = mmio(Address + 0x000003fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1024 CAN AF ram access register
    pub const MASK_256 = mmio(Address + 0x00000400, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1028 CAN AF ram access register
    pub const MASK_257 = mmio(Address + 0x00000404, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1032 CAN AF ram access register
    pub const MASK_258 = mmio(Address + 0x00000408, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1036 CAN AF ram access register
    pub const MASK_259 = mmio(Address + 0x0000040c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1040 CAN AF ram access register
    pub const MASK_260 = mmio(Address + 0x00000410, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1044 CAN AF ram access register
    pub const MASK_261 = mmio(Address + 0x00000414, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1048 CAN AF ram access register
    pub const MASK_262 = mmio(Address + 0x00000418, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1052 CAN AF ram access register
    pub const MASK_263 = mmio(Address + 0x0000041c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1056 CAN AF ram access register
    pub const MASK_264 = mmio(Address + 0x00000420, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1060 CAN AF ram access register
    pub const MASK_265 = mmio(Address + 0x00000424, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1064 CAN AF ram access register
    pub const MASK_266 = mmio(Address + 0x00000428, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1068 CAN AF ram access register
    pub const MASK_267 = mmio(Address + 0x0000042c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1072 CAN AF ram access register
    pub const MASK_268 = mmio(Address + 0x00000430, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1076 CAN AF ram access register
    pub const MASK_269 = mmio(Address + 0x00000434, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1080 CAN AF ram access register
    pub const MASK_270 = mmio(Address + 0x00000438, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1084 CAN AF ram access register
    pub const MASK_271 = mmio(Address + 0x0000043c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1088 CAN AF ram access register
    pub const MASK_272 = mmio(Address + 0x00000440, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1092 CAN AF ram access register
    pub const MASK_273 = mmio(Address + 0x00000444, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1096 CAN AF ram access register
    pub const MASK_274 = mmio(Address + 0x00000448, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1100 CAN AF ram access register
    pub const MASK_275 = mmio(Address + 0x0000044c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1104 CAN AF ram access register
    pub const MASK_276 = mmio(Address + 0x00000450, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1108 CAN AF ram access register
    pub const MASK_277 = mmio(Address + 0x00000454, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1112 CAN AF ram access register
    pub const MASK_278 = mmio(Address + 0x00000458, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1116 CAN AF ram access register
    pub const MASK_279 = mmio(Address + 0x0000045c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1120 CAN AF ram access register
    pub const MASK_280 = mmio(Address + 0x00000460, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1124 CAN AF ram access register
    pub const MASK_281 = mmio(Address + 0x00000464, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1128 CAN AF ram access register
    pub const MASK_282 = mmio(Address + 0x00000468, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1132 CAN AF ram access register
    pub const MASK_283 = mmio(Address + 0x0000046c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1136 CAN AF ram access register
    pub const MASK_284 = mmio(Address + 0x00000470, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1140 CAN AF ram access register
    pub const MASK_285 = mmio(Address + 0x00000474, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1144 CAN AF ram access register
    pub const MASK_286 = mmio(Address + 0x00000478, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1148 CAN AF ram access register
    pub const MASK_287 = mmio(Address + 0x0000047c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1152 CAN AF ram access register
    pub const MASK_288 = mmio(Address + 0x00000480, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1156 CAN AF ram access register
    pub const MASK_289 = mmio(Address + 0x00000484, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1160 CAN AF ram access register
    pub const MASK_290 = mmio(Address + 0x00000488, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1164 CAN AF ram access register
    pub const MASK_291 = mmio(Address + 0x0000048c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1168 CAN AF ram access register
    pub const MASK_292 = mmio(Address + 0x00000490, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1172 CAN AF ram access register
    pub const MASK_293 = mmio(Address + 0x00000494, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1176 CAN AF ram access register
    pub const MASK_294 = mmio(Address + 0x00000498, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1180 CAN AF ram access register
    pub const MASK_295 = mmio(Address + 0x0000049c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1184 CAN AF ram access register
    pub const MASK_296 = mmio(Address + 0x000004a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1188 CAN AF ram access register
    pub const MASK_297 = mmio(Address + 0x000004a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1192 CAN AF ram access register
    pub const MASK_298 = mmio(Address + 0x000004a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1196 CAN AF ram access register
    pub const MASK_299 = mmio(Address + 0x000004ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1200 CAN AF ram access register
    pub const MASK_300 = mmio(Address + 0x000004b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1204 CAN AF ram access register
    pub const MASK_301 = mmio(Address + 0x000004b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1208 CAN AF ram access register
    pub const MASK_302 = mmio(Address + 0x000004b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1212 CAN AF ram access register
    pub const MASK_303 = mmio(Address + 0x000004bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1216 CAN AF ram access register
    pub const MASK_304 = mmio(Address + 0x000004c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1220 CAN AF ram access register
    pub const MASK_305 = mmio(Address + 0x000004c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1224 CAN AF ram access register
    pub const MASK_306 = mmio(Address + 0x000004c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1228 CAN AF ram access register
    pub const MASK_307 = mmio(Address + 0x000004cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1232 CAN AF ram access register
    pub const MASK_308 = mmio(Address + 0x000004d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1236 CAN AF ram access register
    pub const MASK_309 = mmio(Address + 0x000004d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1240 CAN AF ram access register
    pub const MASK_310 = mmio(Address + 0x000004d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1244 CAN AF ram access register
    pub const MASK_311 = mmio(Address + 0x000004dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1248 CAN AF ram access register
    pub const MASK_312 = mmio(Address + 0x000004e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1252 CAN AF ram access register
    pub const MASK_313 = mmio(Address + 0x000004e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1256 CAN AF ram access register
    pub const MASK_314 = mmio(Address + 0x000004e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1260 CAN AF ram access register
    pub const MASK_315 = mmio(Address + 0x000004ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1264 CAN AF ram access register
    pub const MASK_316 = mmio(Address + 0x000004f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1268 CAN AF ram access register
    pub const MASK_317 = mmio(Address + 0x000004f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1272 CAN AF ram access register
    pub const MASK_318 = mmio(Address + 0x000004f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1276 CAN AF ram access register
    pub const MASK_319 = mmio(Address + 0x000004fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1280 CAN AF ram access register
    pub const MASK_320 = mmio(Address + 0x00000500, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1284 CAN AF ram access register
    pub const MASK_321 = mmio(Address + 0x00000504, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1288 CAN AF ram access register
    pub const MASK_322 = mmio(Address + 0x00000508, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1292 CAN AF ram access register
    pub const MASK_323 = mmio(Address + 0x0000050c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1296 CAN AF ram access register
    pub const MASK_324 = mmio(Address + 0x00000510, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1300 CAN AF ram access register
    pub const MASK_325 = mmio(Address + 0x00000514, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1304 CAN AF ram access register
    pub const MASK_326 = mmio(Address + 0x00000518, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1308 CAN AF ram access register
    pub const MASK_327 = mmio(Address + 0x0000051c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1312 CAN AF ram access register
    pub const MASK_328 = mmio(Address + 0x00000520, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1316 CAN AF ram access register
    pub const MASK_329 = mmio(Address + 0x00000524, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1320 CAN AF ram access register
    pub const MASK_330 = mmio(Address + 0x00000528, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1324 CAN AF ram access register
    pub const MASK_331 = mmio(Address + 0x0000052c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1328 CAN AF ram access register
    pub const MASK_332 = mmio(Address + 0x00000530, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1332 CAN AF ram access register
    pub const MASK_333 = mmio(Address + 0x00000534, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1336 CAN AF ram access register
    pub const MASK_334 = mmio(Address + 0x00000538, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1340 CAN AF ram access register
    pub const MASK_335 = mmio(Address + 0x0000053c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1344 CAN AF ram access register
    pub const MASK_336 = mmio(Address + 0x00000540, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1348 CAN AF ram access register
    pub const MASK_337 = mmio(Address + 0x00000544, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1352 CAN AF ram access register
    pub const MASK_338 = mmio(Address + 0x00000548, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1356 CAN AF ram access register
    pub const MASK_339 = mmio(Address + 0x0000054c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1360 CAN AF ram access register
    pub const MASK_340 = mmio(Address + 0x00000550, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1364 CAN AF ram access register
    pub const MASK_341 = mmio(Address + 0x00000554, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1368 CAN AF ram access register
    pub const MASK_342 = mmio(Address + 0x00000558, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1372 CAN AF ram access register
    pub const MASK_343 = mmio(Address + 0x0000055c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1376 CAN AF ram access register
    pub const MASK_344 = mmio(Address + 0x00000560, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1380 CAN AF ram access register
    pub const MASK_345 = mmio(Address + 0x00000564, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1384 CAN AF ram access register
    pub const MASK_346 = mmio(Address + 0x00000568, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1388 CAN AF ram access register
    pub const MASK_347 = mmio(Address + 0x0000056c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1392 CAN AF ram access register
    pub const MASK_348 = mmio(Address + 0x00000570, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1396 CAN AF ram access register
    pub const MASK_349 = mmio(Address + 0x00000574, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1400 CAN AF ram access register
    pub const MASK_350 = mmio(Address + 0x00000578, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1404 CAN AF ram access register
    pub const MASK_351 = mmio(Address + 0x0000057c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1408 CAN AF ram access register
    pub const MASK_352 = mmio(Address + 0x00000580, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1412 CAN AF ram access register
    pub const MASK_353 = mmio(Address + 0x00000584, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1416 CAN AF ram access register
    pub const MASK_354 = mmio(Address + 0x00000588, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1420 CAN AF ram access register
    pub const MASK_355 = mmio(Address + 0x0000058c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1424 CAN AF ram access register
    pub const MASK_356 = mmio(Address + 0x00000590, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1428 CAN AF ram access register
    pub const MASK_357 = mmio(Address + 0x00000594, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1432 CAN AF ram access register
    pub const MASK_358 = mmio(Address + 0x00000598, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1436 CAN AF ram access register
    pub const MASK_359 = mmio(Address + 0x0000059c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1440 CAN AF ram access register
    pub const MASK_360 = mmio(Address + 0x000005a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1444 CAN AF ram access register
    pub const MASK_361 = mmio(Address + 0x000005a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1448 CAN AF ram access register
    pub const MASK_362 = mmio(Address + 0x000005a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1452 CAN AF ram access register
    pub const MASK_363 = mmio(Address + 0x000005ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1456 CAN AF ram access register
    pub const MASK_364 = mmio(Address + 0x000005b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1460 CAN AF ram access register
    pub const MASK_365 = mmio(Address + 0x000005b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1464 CAN AF ram access register
    pub const MASK_366 = mmio(Address + 0x000005b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1468 CAN AF ram access register
    pub const MASK_367 = mmio(Address + 0x000005bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1472 CAN AF ram access register
    pub const MASK_368 = mmio(Address + 0x000005c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1476 CAN AF ram access register
    pub const MASK_369 = mmio(Address + 0x000005c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1480 CAN AF ram access register
    pub const MASK_370 = mmio(Address + 0x000005c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1484 CAN AF ram access register
    pub const MASK_371 = mmio(Address + 0x000005cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1488 CAN AF ram access register
    pub const MASK_372 = mmio(Address + 0x000005d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1492 CAN AF ram access register
    pub const MASK_373 = mmio(Address + 0x000005d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1496 CAN AF ram access register
    pub const MASK_374 = mmio(Address + 0x000005d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1500 CAN AF ram access register
    pub const MASK_375 = mmio(Address + 0x000005dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1504 CAN AF ram access register
    pub const MASK_376 = mmio(Address + 0x000005e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1508 CAN AF ram access register
    pub const MASK_377 = mmio(Address + 0x000005e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1512 CAN AF ram access register
    pub const MASK_378 = mmio(Address + 0x000005e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1516 CAN AF ram access register
    pub const MASK_379 = mmio(Address + 0x000005ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1520 CAN AF ram access register
    pub const MASK_380 = mmio(Address + 0x000005f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1524 CAN AF ram access register
    pub const MASK_381 = mmio(Address + 0x000005f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1528 CAN AF ram access register
    pub const MASK_382 = mmio(Address + 0x000005f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1532 CAN AF ram access register
    pub const MASK_383 = mmio(Address + 0x000005fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1536 CAN AF ram access register
    pub const MASK_384 = mmio(Address + 0x00000600, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1540 CAN AF ram access register
    pub const MASK_385 = mmio(Address + 0x00000604, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1544 CAN AF ram access register
    pub const MASK_386 = mmio(Address + 0x00000608, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1548 CAN AF ram access register
    pub const MASK_387 = mmio(Address + 0x0000060c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1552 CAN AF ram access register
    pub const MASK_388 = mmio(Address + 0x00000610, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1556 CAN AF ram access register
    pub const MASK_389 = mmio(Address + 0x00000614, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1560 CAN AF ram access register
    pub const MASK_390 = mmio(Address + 0x00000618, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1564 CAN AF ram access register
    pub const MASK_391 = mmio(Address + 0x0000061c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1568 CAN AF ram access register
    pub const MASK_392 = mmio(Address + 0x00000620, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1572 CAN AF ram access register
    pub const MASK_393 = mmio(Address + 0x00000624, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1576 CAN AF ram access register
    pub const MASK_394 = mmio(Address + 0x00000628, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1580 CAN AF ram access register
    pub const MASK_395 = mmio(Address + 0x0000062c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1584 CAN AF ram access register
    pub const MASK_396 = mmio(Address + 0x00000630, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1588 CAN AF ram access register
    pub const MASK_397 = mmio(Address + 0x00000634, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1592 CAN AF ram access register
    pub const MASK_398 = mmio(Address + 0x00000638, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1596 CAN AF ram access register
    pub const MASK_399 = mmio(Address + 0x0000063c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1600 CAN AF ram access register
    pub const MASK_400 = mmio(Address + 0x00000640, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1604 CAN AF ram access register
    pub const MASK_401 = mmio(Address + 0x00000644, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1608 CAN AF ram access register
    pub const MASK_402 = mmio(Address + 0x00000648, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1612 CAN AF ram access register
    pub const MASK_403 = mmio(Address + 0x0000064c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1616 CAN AF ram access register
    pub const MASK_404 = mmio(Address + 0x00000650, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1620 CAN AF ram access register
    pub const MASK_405 = mmio(Address + 0x00000654, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1624 CAN AF ram access register
    pub const MASK_406 = mmio(Address + 0x00000658, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1628 CAN AF ram access register
    pub const MASK_407 = mmio(Address + 0x0000065c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1632 CAN AF ram access register
    pub const MASK_408 = mmio(Address + 0x00000660, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1636 CAN AF ram access register
    pub const MASK_409 = mmio(Address + 0x00000664, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1640 CAN AF ram access register
    pub const MASK_410 = mmio(Address + 0x00000668, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1644 CAN AF ram access register
    pub const MASK_411 = mmio(Address + 0x0000066c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1648 CAN AF ram access register
    pub const MASK_412 = mmio(Address + 0x00000670, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1652 CAN AF ram access register
    pub const MASK_413 = mmio(Address + 0x00000674, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1656 CAN AF ram access register
    pub const MASK_414 = mmio(Address + 0x00000678, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1660 CAN AF ram access register
    pub const MASK_415 = mmio(Address + 0x0000067c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1664 CAN AF ram access register
    pub const MASK_416 = mmio(Address + 0x00000680, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1668 CAN AF ram access register
    pub const MASK_417 = mmio(Address + 0x00000684, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1672 CAN AF ram access register
    pub const MASK_418 = mmio(Address + 0x00000688, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1676 CAN AF ram access register
    pub const MASK_419 = mmio(Address + 0x0000068c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1680 CAN AF ram access register
    pub const MASK_420 = mmio(Address + 0x00000690, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1684 CAN AF ram access register
    pub const MASK_421 = mmio(Address + 0x00000694, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1688 CAN AF ram access register
    pub const MASK_422 = mmio(Address + 0x00000698, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1692 CAN AF ram access register
    pub const MASK_423 = mmio(Address + 0x0000069c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1696 CAN AF ram access register
    pub const MASK_424 = mmio(Address + 0x000006a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1700 CAN AF ram access register
    pub const MASK_425 = mmio(Address + 0x000006a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1704 CAN AF ram access register
    pub const MASK_426 = mmio(Address + 0x000006a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1708 CAN AF ram access register
    pub const MASK_427 = mmio(Address + 0x000006ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1712 CAN AF ram access register
    pub const MASK_428 = mmio(Address + 0x000006b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1716 CAN AF ram access register
    pub const MASK_429 = mmio(Address + 0x000006b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1720 CAN AF ram access register
    pub const MASK_430 = mmio(Address + 0x000006b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1724 CAN AF ram access register
    pub const MASK_431 = mmio(Address + 0x000006bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1728 CAN AF ram access register
    pub const MASK_432 = mmio(Address + 0x000006c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1732 CAN AF ram access register
    pub const MASK_433 = mmio(Address + 0x000006c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1736 CAN AF ram access register
    pub const MASK_434 = mmio(Address + 0x000006c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1740 CAN AF ram access register
    pub const MASK_435 = mmio(Address + 0x000006cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1744 CAN AF ram access register
    pub const MASK_436 = mmio(Address + 0x000006d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1748 CAN AF ram access register
    pub const MASK_437 = mmio(Address + 0x000006d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1752 CAN AF ram access register
    pub const MASK_438 = mmio(Address + 0x000006d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1756 CAN AF ram access register
    pub const MASK_439 = mmio(Address + 0x000006dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1760 CAN AF ram access register
    pub const MASK_440 = mmio(Address + 0x000006e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1764 CAN AF ram access register
    pub const MASK_441 = mmio(Address + 0x000006e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1768 CAN AF ram access register
    pub const MASK_442 = mmio(Address + 0x000006e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1772 CAN AF ram access register
    pub const MASK_443 = mmio(Address + 0x000006ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1776 CAN AF ram access register
    pub const MASK_444 = mmio(Address + 0x000006f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1780 CAN AF ram access register
    pub const MASK_445 = mmio(Address + 0x000006f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1784 CAN AF ram access register
    pub const MASK_446 = mmio(Address + 0x000006f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1788 CAN AF ram access register
    pub const MASK_447 = mmio(Address + 0x000006fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1792 CAN AF ram access register
    pub const MASK_448 = mmio(Address + 0x00000700, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1796 CAN AF ram access register
    pub const MASK_449 = mmio(Address + 0x00000704, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1800 CAN AF ram access register
    pub const MASK_450 = mmio(Address + 0x00000708, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1804 CAN AF ram access register
    pub const MASK_451 = mmio(Address + 0x0000070c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1808 CAN AF ram access register
    pub const MASK_452 = mmio(Address + 0x00000710, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1812 CAN AF ram access register
    pub const MASK_453 = mmio(Address + 0x00000714, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1816 CAN AF ram access register
    pub const MASK_454 = mmio(Address + 0x00000718, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1820 CAN AF ram access register
    pub const MASK_455 = mmio(Address + 0x0000071c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1824 CAN AF ram access register
    pub const MASK_456 = mmio(Address + 0x00000720, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1828 CAN AF ram access register
    pub const MASK_457 = mmio(Address + 0x00000724, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1832 CAN AF ram access register
    pub const MASK_458 = mmio(Address + 0x00000728, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1836 CAN AF ram access register
    pub const MASK_459 = mmio(Address + 0x0000072c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1840 CAN AF ram access register
    pub const MASK_460 = mmio(Address + 0x00000730, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1844 CAN AF ram access register
    pub const MASK_461 = mmio(Address + 0x00000734, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1848 CAN AF ram access register
    pub const MASK_462 = mmio(Address + 0x00000738, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1852 CAN AF ram access register
    pub const MASK_463 = mmio(Address + 0x0000073c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1856 CAN AF ram access register
    pub const MASK_464 = mmio(Address + 0x00000740, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1860 CAN AF ram access register
    pub const MASK_465 = mmio(Address + 0x00000744, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1864 CAN AF ram access register
    pub const MASK_466 = mmio(Address + 0x00000748, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1868 CAN AF ram access register
    pub const MASK_467 = mmio(Address + 0x0000074c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1872 CAN AF ram access register
    pub const MASK_468 = mmio(Address + 0x00000750, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1876 CAN AF ram access register
    pub const MASK_469 = mmio(Address + 0x00000754, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1880 CAN AF ram access register
    pub const MASK_470 = mmio(Address + 0x00000758, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1884 CAN AF ram access register
    pub const MASK_471 = mmio(Address + 0x0000075c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1888 CAN AF ram access register
    pub const MASK_472 = mmio(Address + 0x00000760, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1892 CAN AF ram access register
    pub const MASK_473 = mmio(Address + 0x00000764, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1896 CAN AF ram access register
    pub const MASK_474 = mmio(Address + 0x00000768, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1900 CAN AF ram access register
    pub const MASK_475 = mmio(Address + 0x0000076c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1904 CAN AF ram access register
    pub const MASK_476 = mmio(Address + 0x00000770, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1908 CAN AF ram access register
    pub const MASK_477 = mmio(Address + 0x00000774, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1912 CAN AF ram access register
    pub const MASK_478 = mmio(Address + 0x00000778, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1916 CAN AF ram access register
    pub const MASK_479 = mmio(Address + 0x0000077c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1920 CAN AF ram access register
    pub const MASK_480 = mmio(Address + 0x00000780, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1924 CAN AF ram access register
    pub const MASK_481 = mmio(Address + 0x00000784, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1928 CAN AF ram access register
    pub const MASK_482 = mmio(Address + 0x00000788, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1932 CAN AF ram access register
    pub const MASK_483 = mmio(Address + 0x0000078c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1936 CAN AF ram access register
    pub const MASK_484 = mmio(Address + 0x00000790, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1940 CAN AF ram access register
    pub const MASK_485 = mmio(Address + 0x00000794, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1944 CAN AF ram access register
    pub const MASK_486 = mmio(Address + 0x00000798, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1948 CAN AF ram access register
    pub const MASK_487 = mmio(Address + 0x0000079c, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1952 CAN AF ram access register
    pub const MASK_488 = mmio(Address + 0x000007a0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1956 CAN AF ram access register
    pub const MASK_489 = mmio(Address + 0x000007a4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1960 CAN AF ram access register
    pub const MASK_490 = mmio(Address + 0x000007a8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1964 CAN AF ram access register
    pub const MASK_491 = mmio(Address + 0x000007ac, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1968 CAN AF ram access register
    pub const MASK_492 = mmio(Address + 0x000007b0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1972 CAN AF ram access register
    pub const MASK_493 = mmio(Address + 0x000007b4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1976 CAN AF ram access register
    pub const MASK_494 = mmio(Address + 0x000007b8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1980 CAN AF ram access register
    pub const MASK_495 = mmio(Address + 0x000007bc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1984 CAN AF ram access register
    pub const MASK_496 = mmio(Address + 0x000007c0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1988 CAN AF ram access register
    pub const MASK_497 = mmio(Address + 0x000007c4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1992 CAN AF ram access register
    pub const MASK_498 = mmio(Address + 0x000007c8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 1996 CAN AF ram access register
    pub const MASK_499 = mmio(Address + 0x000007cc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2000 CAN AF ram access register
    pub const MASK_500 = mmio(Address + 0x000007d0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2004 CAN AF ram access register
    pub const MASK_501 = mmio(Address + 0x000007d4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2008 CAN AF ram access register
    pub const MASK_502 = mmio(Address + 0x000007d8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2012 CAN AF ram access register
    pub const MASK_503 = mmio(Address + 0x000007dc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2016 CAN AF ram access register
    pub const MASK_504 = mmio(Address + 0x000007e0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2020 CAN AF ram access register
    pub const MASK_505 = mmio(Address + 0x000007e4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2024 CAN AF ram access register
    pub const MASK_506 = mmio(Address + 0x000007e8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2028 CAN AF ram access register
    pub const MASK_507 = mmio(Address + 0x000007ec, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2032 CAN AF ram access register
    pub const MASK_508 = mmio(Address + 0x000007f0, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2036 CAN AF ram access register
    pub const MASK_509 = mmio(Address + 0x000007f4, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2040 CAN AF ram access register
    pub const MASK_510 = mmio(Address + 0x000007f8, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
    // byte offset: 2044 CAN AF ram access register
    pub const MASK_511 = mmio(Address + 0x000007fc, 32, packed struct {
        MASK: u32, // bit offset: 0 desc: CAN AF RAM mask
    });
};
pub const CANAF = extern struct {
    pub const Address: u32 = 0x4003c000;
    // byte offset: 0 Acceptance Filter Register
    pub const AFMR = mmio(Address + 0x00000000, 32, packed struct {
        ACCOFF: bool, // bit offset: 0 desc: if AccBP is 0, the Acceptance Filter is not operational. All Rx messages on all CAN buses are ignored.
        ACCBP: bool, // bit offset: 1 desc: All Rx messages are accepted on enabled CAN controllers. Software must set this bit before modifying the contents of any of the registers described below, and before modifying the contents of Lookup Table RAM in any way other than setting or clearing Disable bits in Standard Identifier entries. When both this bit and AccOff are 0, the Acceptance filter operates to screen received CAN Identifiers.
        EFCAN: bool, // bit offset: 2 desc: FullCAN mode
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Standard Frame Individual Start Address Register
    pub const SFF_SA = mmio(Address + 0x00000004, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SFF_SA: u9, // bit offset: 2 desc: The start address of the table of individual Standard Identifiers in AF Lookup RAM. If the table is empty, write the same value in this register and the SFF_GRP_sa register described below. For compatibility with possible future devices, write zeroes in bits 31:11 and 1:0 of this register. If the eFCAN bit in the AFMR is 1, this value also indicates the size of the table of Standard IDs which the Acceptance Filter will search and (if found) automatically store received messages in Acceptance Filter RAM.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Standard Frame Group Start Address Register
    pub const SFF_GRP_SA = mmio(Address + 0x00000008, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SFF_GRP_SA: u10, // bit offset: 2 desc: The start address of the table of grouped Standard Identifiers in AF Lookup RAM. If the table is empty, write the same value in this register and the EFF_sa register described below. The largest value that should be written to this register is 0x800, when only the Standard Individual table is used, and the last word (address 0x7FC) in AF Lookup Table RAM is used. For compatibility with possible future devices, please write zeroes in bits 31:12 and 1:0 of this register.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Extended Frame Start Address Register
    pub const EFF_SA = mmio(Address + 0x0000000c, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        EFF_SA: u9, // bit offset: 2 desc: The start address of the table of individual Extended Identifiers in AF Lookup RAM. If the table is empty, write the same value in this register and the EFF_GRP_sa register described below. The largest value that should be written to this register is 0x800, when both Extended Tables are empty and the last word (address 0x7FC) in AF Lookup Table RAM is used. For compatibility with possible future devices, please write zeroes in bits 31:11 and 1:0 of this register.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 Extended Frame Group Start Address Register
    pub const EFF_GRP_SA = mmio(Address + 0x00000010, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        EFF_GRP_SA: u10, // bit offset: 2 desc: The start address of the table of grouped Extended Identifiers in AF Lookup RAM. If the table is empty, write the same value in this register and the ENDofTable register described below. The largest value that should be written to this register is 0x800, when this table is empty and the last word (address 0x7FC) in AF Lookup Table RAM is used. For compatibility with possible future devices, please write zeroes in bits 31:12 and 1:0 of this register.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 End of AF Tables register
    pub const ENDOFTABLE = mmio(Address + 0x00000014, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ENDOFTABLE: u10, // bit offset: 2 desc: The address above the last active address in the last active AF table. For compatibility with possible future devices, please write zeroes in bits 31:12 and 1:0 of this register. If the eFCAN bit in the AFMR is 0, the largest value that should be written to this register is 0x800, which allows the last word (address 0x7FC) in AF Lookup Table RAM to be used. If the eFCAN bit in the AFMR is 1, this value marks the start of the area of Acceptance Filter RAM, into which the Acceptance Filter will automatically receive messages for selected IDs on selected CAN buses. In this case, the maximum value that should be written to this register is 0x800 minus 6 times the value in SFF_sa. This allows 12 bytes of message storage between this address and the end of Acceptance Filter RAM, for each Standard ID that is specified between the start of Acceptance Filter RAM, and the next active AF table.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 LUT Error Address register
    pub const LUTERRAD = mmio(Address + 0x00000018, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LUTERRAD: u9, // bit offset: 2 desc: It the LUT Error bit (below) is 1, this read-only field contains the address in AF Lookup Table RAM, at which the Acceptance Filter encountered an error in the content of the tables.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 LUT Error Register
    pub const LUTERR = mmio(Address + 0x0000001c, 32, packed struct {
        LUTERR: bool, // bit offset: 0 desc: This read-only bit is set to 1 if the Acceptance Filter encounters an error in the content of the tables in AF RAM. It is cleared when software reads the LUTerrAd register. This condition is ORed with the other CAN interrupts from the CAN controllers, to produce the request that is connected to the NVIC.
        padding31: u1 = 0,
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 FullCAN interrupt enable register
    pub const FCANIE = mmio(Address + 0x00000020, 32, packed struct {
        FCANIE: bool, // bit offset: 0 desc: Global FullCAN Interrupt Enable. When 1, this interrupt is enabled.
        padding31: u1 = 0,
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 FullCAN interrupt and capture register0
    pub const FCANIC0 = mmio(Address + 0x00000024, 32, packed struct {
        INTPND: u32, // bit offset: 0 desc: FullCan Interrupt Pending 0 = FullCan Interrupt Pending bit 0. 1 = FullCan Interrupt Pending bit 1. ... 31 = FullCan Interrupt Pending bit 31.
    });
    // byte offset: 40 FullCAN interrupt and capture register1
    pub const FCANIC1 = mmio(Address + 0x00000028, 32, packed struct {
        IntPnd32: u32, // bit offset: 0 desc: FullCan Interrupt Pending bit 32. 0 = FullCan Interrupt Pending bit 32. 1 = FullCan Interrupt Pending bit 33. ... 31 = FullCan Interrupt Pending bit 63.
    });
};
pub const CCAN = extern struct {
    pub const Address: u32 = 0x40040000;
    // byte offset: 0 CAN Central Transmit Status Register
    pub const TXSR = mmio(Address + 0x00000000, 32, packed struct {
        TS1: bool, // bit offset: 0 desc: When 1, the CAN controller 1 is sending a message (same as TS in the CAN1GSR).
        TS2: bool, // bit offset: 1 desc: When 1, the CAN controller 2 is sending a message (same as TS in the CAN2GSR)
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TBS1: bool, // bit offset: 8 desc: When 1, all 3 Tx Buffers of the CAN1 controller are available to the CPU (same as TBS in CAN1GSR).
        TBS2: bool, // bit offset: 9 desc: When 1, all 3 Tx Buffers of the CAN2 controller are available to the CPU (same as TBS in CAN2GSR).
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        TCS1: bool, // bit offset: 16 desc: When 1, all requested transmissions have been completed successfully by the CAN1 controller (same as TCS in CAN1GSR).
        TCS2: bool, // bit offset: 17 desc: When 1, all requested transmissions have been completed successfully by the CAN2 controller (same as TCS in CAN2GSR).
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 CAN Central Receive Status Register
    pub const RXSR = mmio(Address + 0x00000004, 32, packed struct {
        RS1: bool, // bit offset: 0 desc: When 1, CAN1 is receiving a message (same as RS in CAN1GSR).
        RS2: bool, // bit offset: 1 desc: When 1, CAN2 is receiving a message (same as RS in CAN2GSR).
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RB1: bool, // bit offset: 8 desc: When 1, a received message is available in the CAN1 controller (same as RBS in CAN1GSR).
        RB2: bool, // bit offset: 9 desc: When 1, a received message is available in the CAN2 controller (same as RBS in CAN2GSR).
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        DOS1: bool, // bit offset: 16 desc: When 1, a message was lost because the preceding message to CAN1 controller was not read out quickly enough (same as DOS in CAN1GSR).
        DOS2: bool, // bit offset: 17 desc: When 1, a message was lost because the preceding message to CAN2 controller was not read out quickly enough (same as DOS in CAN2GSR).
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 CAN Central Miscellaneous Register
    pub const MSR = mmio(Address + 0x00000008, 32, packed struct {
        E1: bool, // bit offset: 0 desc: When 1, one or both of the CAN1 Tx and Rx Error Counters has reached the limit set in the CAN1EWL register (same as ES in CAN1GSR)
        E2: bool, // bit offset: 1 desc: When 1, one or both of the CAN2 Tx and Rx Error Counters has reached the limit set in the CAN2EWL register (same as ES in CAN2GSR)
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        BS1: bool, // bit offset: 8 desc: When 1, the CAN1 controller is currently involved in bus activities (same as BS in CAN1GSR).
        BS2: bool, // bit offset: 9 desc: When 1, the CAN2 controller is currently involved in bus activities (same as BS in CAN2GSR).
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const CAN1 = extern struct {
    pub const Address: u32 = 0x40044000;
    // byte offset: 0 Controls the operating mode of the CAN Controller.
    pub const MOD = mmio(Address + 0x00000000, 32, packed struct {
        RM: bool, // bit offset: 0 desc: Reset Mode.
        LOM: bool, // bit offset: 1 desc: Listen Only Mode.
        STM: bool, // bit offset: 2 desc: Self Test Mode.
        TPM: bool, // bit offset: 3 desc: Transmit Priority Mode.
        SM: bool, // bit offset: 4 desc: Sleep Mode.
        RPM: bool, // bit offset: 5 desc: Receive Polarity Mode.
        reserved1: u1 = 0,
        TM: bool, // bit offset: 7 desc: Test Mode.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Command bits that affect the state of the CAN Controller
    pub const CMR = mmio(Address + 0x00000004, 32, packed struct {
        TR: bool, // bit offset: 0 desc: Transmission Request.
        AT: bool, // bit offset: 1 desc: Abort Transmission.
        RRB: bool, // bit offset: 2 desc: Release Receive Buffer.
        CDO: bool, // bit offset: 3 desc: Clear Data Overrun.
        SRR: bool, // bit offset: 4 desc: Self Reception Request.
        STB1: bool, // bit offset: 5 desc: Select Tx Buffer 1.
        STB2: bool, // bit offset: 6 desc: Select Tx Buffer 2.
        STB3: bool, // bit offset: 7 desc: Select Tx Buffer 3.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Global Controller Status and Error Counters. The error counters can only be written when RM in CANMOD is 1.
    pub const GSR = mmio(Address + 0x00000008, 32, packed struct {
        RBS: bool, // bit offset: 0 desc: Receive Buffer Status. After reading all messages and releasing their memory space with the command 'Release Receive Buffer,' this bit is cleared.
        DOS: bool, // bit offset: 1 desc: Data Overrun Status. If there is not enough space to store the message within the Receive Buffer, that message is dropped and the Data Overrun condition is signalled to the CPU in the moment this message becomes valid. If this message is not completed successfully (e.g. because of an error), no overrun condition is signalled.
        TBS: bool, // bit offset: 2 desc: Transmit Buffer Status.
        TCS: bool, // bit offset: 3 desc: Transmit Complete Status. The Transmission Complete Status bit is set '0' (incomplete) whenever the Transmission Request bit or the Self Reception Request bit is set '1' at least for one of the three Transmit Buffers. The Transmission Complete Status bit will remain '0' until all messages are transmitted successfully.
        RS: bool, // bit offset: 4 desc: Receive Status. If both the Receive Status and the Transmit Status bits are '0' (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to become idle again. After hardware reset 11 consecutive recessive bits have to be detected until idle status is reached. After Bus-off this will take 128 times of 11 consecutive recessive bits.
        TS: bool, // bit offset: 5 desc: Transmit Status. If both the Receive Status and the Transmit Status bits are '0' (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to become idle again. After hardware reset 11 consecutive recessive bits have to be detected until idle status is reached. After Bus-off this will take 128 times of 11 consecutive recessive bits.
        ES: bool, // bit offset: 6 desc: Error Status. Errors detected during reception or transmission will effect the error counters according to the CAN specification. The Error Status bit is set when at least one of the error counters has reached or exceeded the Error Warning Limit. An Error Warning Interrupt is generated, if enabled. The default value of the Error Warning Limit after hardware reset is 96 decimal, see also Section 21.7.7 CAN Error Warning Limit register (CAN1EWL - 0x4004 4018, CAN2EWL - 0x4004 8018).
        BS: bool, // bit offset: 7 desc: Bus Status. Mode bit '1' (present) and an Error Warning Interrupt is generated, if enabled. Afterwards the Transmit Error Counter is set to '127', and the Receive Error Counter is cleared. It will stay in this mode until the CPU clears the Reset Mode bit. Once this is completed the CAN Controller will wait the minimum protocol-defined time (128 occurrences of the Bus-Free signal) counting down the Transmit Error Counter. After that, the Bus Status bit is cleared (Bus-On), the Error Status bit is set '0' (ok), the Error Counters are reset, and an Error Warning Interrupt is generated, if enabled. Reading the TX Error Counter during this time gives information about the status of the Bus-Off recovery.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXERR: u8, // bit offset: 16 desc: The current value of the Rx Error Counter (an 8-bit value).
        TXERR: u8, // bit offset: 24 desc: The current value of the Tx Error Counter (an 8-bit value).
    });
    // byte offset: 12 Interrupt status, Arbitration Lost Capture, Error Code Capture
    pub const ICR = mmio(Address + 0x0000000c, 32, packed struct {
        RI: bool, // bit offset: 0 desc: Receive Interrupt. This bit is set whenever the RBS bit in CANxSR and the RIE bit in CANxIER are both 1, indicating that a new message was received and stored in the Receive Buffer. The Receive Interrupt Bit is not cleared upon a read access to the Interrupt Register. Giving the Command Release Receive Buffer will clear RI temporarily. If there is another message available within the Receive Buffer after the release command, RI is set again. Otherwise RI remains cleared.
        TI1: bool, // bit offset: 1 desc: Transmit Interrupt 1. This bit is set when the TBS1 bit in CANxSR goes from 0 to 1 (whenever a message out of TXB1 was successfully transmitted or aborted), indicating that Transmit buffer 1 is available, and the TIE1 bit in CANxIER is 1.
        EI: bool, // bit offset: 2 desc: Error Warning Interrupt. This bit is set on every change (set or clear) of either the Error Status or Bus Status bit in CANxSR and the EIE bit bit is set within the Interrupt Enable Register at the time of the change.
        DOI: bool, // bit offset: 3 desc: Data Overrun Interrupt. This bit is set when the DOS bit in CANxSR goes from 0 to 1 and the DOIE bit in CANxIER is 1.
        WUI: bool, // bit offset: 4 desc: Wake-Up Interrupt. This bit is set if the CAN controller is sleeping and bus activity is detected and the WUIE bit in CANxIER is 1. A Wake-Up Interrupt is also generated if the CPU tries to set the Sleep bit while the CAN controller is involved in bus activities or a CAN Interrupt is pending. The WUI flag can also get asserted when the according enable bit WUIE is not set. In this case a Wake-Up Interrupt does not get asserted.
        EPI: bool, // bit offset: 5 desc: Error Passive Interrupt. This bit is set if the EPIE bit in CANxIER is 1, and the CAN controller switches between Error Passive and Error Active mode in either direction. This is the case when the CAN Controller has reached the Error Passive Status (at least one error counter exceeds the CAN protocol defined level of 127) or if the CAN Controller is in Error Passive Status and enters the Error Active Status again.
        ALI: bool, // bit offset: 6 desc: Arbitration Lost Interrupt. This bit is set if the ALIE bit in CANxIER is 1, and the CAN controller loses arbitration while attempting to transmit. In this case the CAN node becomes a receiver.
        BEI: bool, // bit offset: 7 desc: Bus Error Interrupt -- this bit is set if the BEIE bit in CANxIER is 1, and the CAN controller detects an error on the bus.
        IDI: bool, // bit offset: 8 desc: ID Ready Interrupt -- this bit is set if the IDIE bit in CANxIER is 1, and a CAN Identifier has been received (a message was successfully transmitted or aborted). This bit is set whenever a message was successfully transmitted or aborted and the IDIE bit is set in the IER register.
        TI2: bool, // bit offset: 9 desc: Transmit Interrupt 2. This bit is set when the TBS2 bit in CANxSR goes from 0 to 1 (whenever a message out of TXB2 was successfully transmitted or aborted), indicating that Transmit buffer 2 is available, and the TIE2 bit in CANxIER is 1.
        TI3: bool, // bit offset: 10 desc: Transmit Interrupt 3. This bit is set when the TBS3 bit in CANxSR goes from 0 to 1 (whenever a message out of TXB3 was successfully transmitted or aborted), indicating that Transmit buffer 3 is available, and the TIE3 bit in CANxIER is 1.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ERRBIT4_0: u5, // bit offset: 16 desc: Error Code Capture: when the CAN controller detects a bus error, the location of the error within the frame is captured in this field. The value reflects an internal state variable, and as a result is not very linear: 00011 = Start of Frame 00010 = ID28 ... ID21 00110 = ID20 ... ID18 00100 = SRTR Bit 00101 = IDE bit 00111 = ID17 ... 13 01111 = ID12 ... ID5 01110 = ID4 ... ID0 01100 = RTR Bit 01101 = Reserved Bit 1 01001 = Reserved Bit 0 01011 = Data Length Code 01010 = Data Field 01000 = CRC Sequence 11000 = CRC Delimiter 11001 = Acknowledge Slot 11011 = Acknowledge Delimiter 11010 = End of Frame 10010 = Intermission Whenever a bus error occurs, the corresponding bus error interrupt is forced, if enabled. At the same time, the current position of the Bit Stream Processor is captured into the Error Code Capture Register. The content within this register is fixed until the user software has read out its content once. From now on, the capture mechanism is activated again, i.e. reading the CANxICR enables another Bus Error Interrupt.
        ERRDIR: bool, // bit offset: 21 desc: When the CAN controller detects a bus error, the direction of the current bit is captured in this bit.
        ERRC1_0: u2, // bit offset: 22 desc: When the CAN controller detects a bus error, the type of error is captured in this field:
        ALCBIT: u8, // bit offset: 24 desc: Each time arbitration is lost while trying to send on the CAN, the bit number within the frame is captured into this field. After the content of ALCBIT is read, the ALI bit is cleared and a new Arbitration Lost interrupt can occur. 00 = arbitration lost in the first bit (MS) of identifier ... 11 = arbitration lost in SRTS bit (RTR bit for standard frame messages) 12 = arbitration lost in IDE bit 13 = arbitration lost in 12th bit of identifier (extended frame only) ... 30 = arbitration lost in last bit of identifier (extended frame only) 31 = arbitration lost in RTR bit (extended frame only) On arbitration lost, the corresponding arbitration lost interrupt is forced, if enabled. At that time, the current bit position of the Bit Stream Processor is captured into the Arbitration Lost Capture Register. The content within this register is fixed until the user application has read out its contents once. From now on, the capture mechanism is activated again.
    });
    // byte offset: 16 Interrupt Enable
    pub const IER = mmio(Address + 0x00000010, 32, packed struct {
        RIE: bool, // bit offset: 0 desc: Receiver Interrupt Enable. When the Receive Buffer Status is 'full', the CAN Controller requests the respective interrupt.
        TIE1: bool, // bit offset: 1 desc: Transmit Interrupt Enable for Buffer1. When a message has been successfully transmitted out of TXB1 or Transmit Buffer 1 is accessible again (e.g. after an Abort Transmission command), the CAN Controller requests the respective interrupt.
        EIE: bool, // bit offset: 2 desc: Error Warning Interrupt Enable. If the Error or Bus Status change (see Status Register), the CAN Controller requests the respective interrupt.
        DOIE: bool, // bit offset: 3 desc: Data Overrun Interrupt Enable. If the Data Overrun Status bit is set (see Status Register), the CAN Controller requests the respective interrupt.
        WUIE: bool, // bit offset: 4 desc: Wake-Up Interrupt Enable. If the sleeping CAN controller wakes up, the respective interrupt is requested.
        EPIE: bool, // bit offset: 5 desc: Error Passive Interrupt Enable. If the error status of the CAN Controller changes from error active to error passive or vice versa, the respective interrupt is requested.
        ALIE: bool, // bit offset: 6 desc: Arbitration Lost Interrupt Enable. If the CAN Controller has lost arbitration, the respective interrupt is requested.
        BEIE: bool, // bit offset: 7 desc: Bus Error Interrupt Enable. If a bus error has been detected, the CAN Controller requests the respective interrupt.
        IDIE: bool, // bit offset: 8 desc: ID Ready Interrupt Enable. When a CAN identifier has been received, the CAN Controller requests the respective interrupt.
        TIE2: bool, // bit offset: 9 desc: Transmit Interrupt Enable for Buffer2. When a message has been successfully transmitted out of TXB2 or Transmit Buffer 2 is accessible again (e.g. after an Abort Transmission command), the CAN Controller requests the respective interrupt.
        TIE3: bool, // bit offset: 10 desc: Transmit Interrupt Enable for Buffer3. When a message has been successfully transmitted out of TXB3 or Transmit Buffer 3 is accessible again (e.g. after an Abort Transmission command), the CAN Controller requests the respective interrupt.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Bus Timing. Can only be written when RM in CANMOD is 1.
    pub const BTR = mmio(Address + 0x00000014, 32, packed struct {
        BRP: u10, // bit offset: 0 desc: Baud Rate Prescaler. The APB clock is divided by (this value plus one) to produce the CAN clock.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SJW: u2, // bit offset: 14 desc: The Synchronization Jump Width is (this value plus one) CAN clocks.
        TESG1: u4, // bit offset: 16 desc: The delay from the nominal Sync point to the sample point is (this value plus one) CAN clocks.
        TESG2: u3, // bit offset: 20 desc: The delay from the sample point to the next nominal sync point is (this value plus one) CAN clocks. The nominal CAN bit time is (this value plus the value in TSEG1 plus 3) CAN clocks.
        SAM: bool, // bit offset: 23 desc: Sampling
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Error Warning Limit. Can only be written when RM in CANMOD is 1.
    pub const EWL = mmio(Address + 0x00000018, 32, packed struct {
        EWL: u8, // bit offset: 0 desc: During CAN operation, this value is compared to both the Tx and Rx Error Counters. If either of these counter matches this value, the Error Status (ES) bit in CANSR is set.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Status Register
    pub const SR = mmio(Address + 0x0000001c, 32, packed struct {
        RBS_1: bool, // bit offset: 0 desc: Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
        DOS_1: bool, // bit offset: 1 desc: Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
        TBS1_1: bool, // bit offset: 2 desc: Transmit Buffer Status 1.
        TCS1_1: bool, // bit offset: 3 desc: Transmission Complete Status.
        RS_1: bool, // bit offset: 4 desc: Receive Status. This bit is identical to the RS bit in the GSR.
        TS1_1: bool, // bit offset: 5 desc: Transmit Status 1.
        ES_1: bool, // bit offset: 6 desc: Error Status. This bit is identical to the ES bit in the CANxGSR.
        BS_1: bool, // bit offset: 7 desc: Bus Status. This bit is identical to the BS bit in the CANxGSR.
        RBS_2: bool, // bit offset: 8 desc: Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
        DOS_2: bool, // bit offset: 9 desc: Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
        TBS2_2: bool, // bit offset: 10 desc: Transmit Buffer Status 2.
        TCS2_2: bool, // bit offset: 11 desc: Transmission Complete Status.
        RS_2: bool, // bit offset: 12 desc: Receive Status. This bit is identical to the RS bit in the GSR.
        TS2_2: bool, // bit offset: 13 desc: Transmit Status 2.
        ES_2: bool, // bit offset: 14 desc: Error Status. This bit is identical to the ES bit in the CANxGSR.
        BS_2: bool, // bit offset: 15 desc: Bus Status. This bit is identical to the BS bit in the CANxGSR.
        RBS_3: bool, // bit offset: 16 desc: Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
        DOS_3: bool, // bit offset: 17 desc: Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
        TBS3_3: bool, // bit offset: 18 desc: Transmit Buffer Status 3.
        TCS3_3: bool, // bit offset: 19 desc: Transmission Complete Status.
        RS_3: bool, // bit offset: 20 desc: Receive Status. This bit is identical to the RS bit in the GSR.
        TS3_3: bool, // bit offset: 21 desc: Transmit Status 3.
        ES_3: bool, // bit offset: 22 desc: Error Status. This bit is identical to the ES bit in the CANxGSR.
        BS_3: bool, // bit offset: 23 desc: Bus Status. This bit is identical to the BS bit in the CANxGSR.
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 Receive frame status. Can only be written when RM in CANMOD is 1.
    pub const RFS = mmio(Address + 0x00000020, 32, packed struct {
        IDINDEX: u10, // bit offset: 0 desc: ID Index. If the BP bit (below) is 0, this value is the zero-based number of the Lookup Table RAM entry at which the Acceptance Filter matched the received Identifier. Disabled entries in the Standard tables are included in this numbering, but will not be matched. See Section 21.17 Examples of acceptance filter tables and ID index values on page 587 for examples of ID Index values.
        BP: bool, // bit offset: 10 desc: If this bit is 1, the current message was received in AF Bypass mode, and the ID Index field (above) is meaningless.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: The field contains the Data Length Code (DLC) field of the current received message. When RTR = 0, this is related to the number of data bytes available in the CANRDA and CANRDB registers as follows: 0000-0111 = 0 to 7 bytes1000-1111 = 8 bytes With RTR = 1, this value indicates the number of data bytes requested to be sent back, with the same encoding.
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This bit contains the Remote Transmission Request bit of the current received message. 0 indicates a Data Frame, in which (if DLC is non-zero) data can be read from the CANRDA and possibly the CANRDB registers. 1 indicates a Remote frame, in which case the DLC value identifies the number of data bytes requested to be sent using the same Identifier.
        FF: bool, // bit offset: 31 desc: A 0 in this bit indicates that the current received message included an 11-bit Identifier, while a 1 indicates a 29-bit Identifier. This affects the contents of the CANid register described below.
    });
    // byte offset: 36 Received Identifier. Can only be written when RM in CANMOD is 1.
    pub const RID = mmio(Address + 0x00000024, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier field of the current received message. In CAN 2.0A, these bits are called ID10-0, while in CAN 2.0B they're called ID29-18.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Received data bytes 1-4. Can only be written when RM in CANMOD is 1.
    pub const RDA = mmio(Address + 0x00000028, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If the DLC field in CANRFS >= 0001, this contains the first Data byte of the current received message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If the DLC field in CANRFS >= 0010, this contains the first Data byte of the current received message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If the DLC field in CANRFS >= 0011, this contains the first Data byte of the current received message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If the DLC field in CANRFS >= 0100, this contains the first Data byte of the current received message.
    });
    // byte offset: 44 Received data bytes 5-8. Can only be written when RM in CANMOD is 1.
    pub const RDB = mmio(Address + 0x0000002c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If the DLC field in CANRFS >= 0101, this contains the first Data byte of the current received message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If the DLC field in CANRFS >= 0110, this contains the first Data byte of the current received message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If the DLC field in CANRFS >= 0111, this contains the first Data byte of the current received message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If the DLC field in CANRFS >= 1000, this contains the first Data byte of the current received message.
    });
    // byte offset: 48 Transmit frame info (Tx Buffer )
    pub const TFI1 = mmio(Address + 0x00000030, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 52 Transmit Identifier (Tx Buffer)
    pub const TID1 = mmio(Address + 0x00000034, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 56 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA1 = mmio(Address + 0x00000038, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 60 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB1 = mmio(Address + 0x0000003c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
    // byte offset: 64 Transmit frame info (Tx Buffer )
    pub const TFI2 = mmio(Address + 0x00000040, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 68 Transmit Identifier (Tx Buffer)
    pub const TID2 = mmio(Address + 0x00000044, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 72 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA2 = mmio(Address + 0x00000048, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 76 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB2 = mmio(Address + 0x0000004c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
    // byte offset: 80 Transmit frame info (Tx Buffer )
    pub const TFI3 = mmio(Address + 0x00000050, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 84 Transmit Identifier (Tx Buffer)
    pub const TID3 = mmio(Address + 0x00000054, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 88 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA3 = mmio(Address + 0x00000058, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 92 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB3 = mmio(Address + 0x0000005c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
};
pub const CAN2 = extern struct {
    pub const Address: u32 = 0x40048000;
    // byte offset: 0 Controls the operating mode of the CAN Controller.
    pub const MOD = mmio(Address + 0x00000000, 32, packed struct {
        RM: bool, // bit offset: 0 desc: Reset Mode.
        LOM: bool, // bit offset: 1 desc: Listen Only Mode.
        STM: bool, // bit offset: 2 desc: Self Test Mode.
        TPM: bool, // bit offset: 3 desc: Transmit Priority Mode.
        SM: bool, // bit offset: 4 desc: Sleep Mode.
        RPM: bool, // bit offset: 5 desc: Receive Polarity Mode.
        reserved1: u1 = 0,
        TM: bool, // bit offset: 7 desc: Test Mode.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Command bits that affect the state of the CAN Controller
    pub const CMR = mmio(Address + 0x00000004, 32, packed struct {
        TR: bool, // bit offset: 0 desc: Transmission Request.
        AT: bool, // bit offset: 1 desc: Abort Transmission.
        RRB: bool, // bit offset: 2 desc: Release Receive Buffer.
        CDO: bool, // bit offset: 3 desc: Clear Data Overrun.
        SRR: bool, // bit offset: 4 desc: Self Reception Request.
        STB1: bool, // bit offset: 5 desc: Select Tx Buffer 1.
        STB2: bool, // bit offset: 6 desc: Select Tx Buffer 2.
        STB3: bool, // bit offset: 7 desc: Select Tx Buffer 3.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Global Controller Status and Error Counters. The error counters can only be written when RM in CANMOD is 1.
    pub const GSR = mmio(Address + 0x00000008, 32, packed struct {
        RBS: bool, // bit offset: 0 desc: Receive Buffer Status. After reading all messages and releasing their memory space with the command 'Release Receive Buffer,' this bit is cleared.
        DOS: bool, // bit offset: 1 desc: Data Overrun Status. If there is not enough space to store the message within the Receive Buffer, that message is dropped and the Data Overrun condition is signalled to the CPU in the moment this message becomes valid. If this message is not completed successfully (e.g. because of an error), no overrun condition is signalled.
        TBS: bool, // bit offset: 2 desc: Transmit Buffer Status.
        TCS: bool, // bit offset: 3 desc: Transmit Complete Status. The Transmission Complete Status bit is set '0' (incomplete) whenever the Transmission Request bit or the Self Reception Request bit is set '1' at least for one of the three Transmit Buffers. The Transmission Complete Status bit will remain '0' until all messages are transmitted successfully.
        RS: bool, // bit offset: 4 desc: Receive Status. If both the Receive Status and the Transmit Status bits are '0' (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to become idle again. After hardware reset 11 consecutive recessive bits have to be detected until idle status is reached. After Bus-off this will take 128 times of 11 consecutive recessive bits.
        TS: bool, // bit offset: 5 desc: Transmit Status. If both the Receive Status and the Transmit Status bits are '0' (idle), the CAN-Bus is idle. If both bits are set, the controller is waiting to become idle again. After hardware reset 11 consecutive recessive bits have to be detected until idle status is reached. After Bus-off this will take 128 times of 11 consecutive recessive bits.
        ES: bool, // bit offset: 6 desc: Error Status. Errors detected during reception or transmission will effect the error counters according to the CAN specification. The Error Status bit is set when at least one of the error counters has reached or exceeded the Error Warning Limit. An Error Warning Interrupt is generated, if enabled. The default value of the Error Warning Limit after hardware reset is 96 decimal, see also Section 21.7.7 CAN Error Warning Limit register (CAN1EWL - 0x4004 4018, CAN2EWL - 0x4004 8018).
        BS: bool, // bit offset: 7 desc: Bus Status. Mode bit '1' (present) and an Error Warning Interrupt is generated, if enabled. Afterwards the Transmit Error Counter is set to '127', and the Receive Error Counter is cleared. It will stay in this mode until the CPU clears the Reset Mode bit. Once this is completed the CAN Controller will wait the minimum protocol-defined time (128 occurrences of the Bus-Free signal) counting down the Transmit Error Counter. After that, the Bus Status bit is cleared (Bus-On), the Error Status bit is set '0' (ok), the Error Counters are reset, and an Error Warning Interrupt is generated, if enabled. Reading the TX Error Counter during this time gives information about the status of the Bus-Off recovery.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXERR: u8, // bit offset: 16 desc: The current value of the Rx Error Counter (an 8-bit value).
        TXERR: u8, // bit offset: 24 desc: The current value of the Tx Error Counter (an 8-bit value).
    });
    // byte offset: 12 Interrupt status, Arbitration Lost Capture, Error Code Capture
    pub const ICR = mmio(Address + 0x0000000c, 32, packed struct {
        RI: bool, // bit offset: 0 desc: Receive Interrupt. This bit is set whenever the RBS bit in CANxSR and the RIE bit in CANxIER are both 1, indicating that a new message was received and stored in the Receive Buffer. The Receive Interrupt Bit is not cleared upon a read access to the Interrupt Register. Giving the Command Release Receive Buffer will clear RI temporarily. If there is another message available within the Receive Buffer after the release command, RI is set again. Otherwise RI remains cleared.
        TI1: bool, // bit offset: 1 desc: Transmit Interrupt 1. This bit is set when the TBS1 bit in CANxSR goes from 0 to 1 (whenever a message out of TXB1 was successfully transmitted or aborted), indicating that Transmit buffer 1 is available, and the TIE1 bit in CANxIER is 1.
        EI: bool, // bit offset: 2 desc: Error Warning Interrupt. This bit is set on every change (set or clear) of either the Error Status or Bus Status bit in CANxSR and the EIE bit bit is set within the Interrupt Enable Register at the time of the change.
        DOI: bool, // bit offset: 3 desc: Data Overrun Interrupt. This bit is set when the DOS bit in CANxSR goes from 0 to 1 and the DOIE bit in CANxIER is 1.
        WUI: bool, // bit offset: 4 desc: Wake-Up Interrupt. This bit is set if the CAN controller is sleeping and bus activity is detected and the WUIE bit in CANxIER is 1. A Wake-Up Interrupt is also generated if the CPU tries to set the Sleep bit while the CAN controller is involved in bus activities or a CAN Interrupt is pending. The WUI flag can also get asserted when the according enable bit WUIE is not set. In this case a Wake-Up Interrupt does not get asserted.
        EPI: bool, // bit offset: 5 desc: Error Passive Interrupt. This bit is set if the EPIE bit in CANxIER is 1, and the CAN controller switches between Error Passive and Error Active mode in either direction. This is the case when the CAN Controller has reached the Error Passive Status (at least one error counter exceeds the CAN protocol defined level of 127) or if the CAN Controller is in Error Passive Status and enters the Error Active Status again.
        ALI: bool, // bit offset: 6 desc: Arbitration Lost Interrupt. This bit is set if the ALIE bit in CANxIER is 1, and the CAN controller loses arbitration while attempting to transmit. In this case the CAN node becomes a receiver.
        BEI: bool, // bit offset: 7 desc: Bus Error Interrupt -- this bit is set if the BEIE bit in CANxIER is 1, and the CAN controller detects an error on the bus.
        IDI: bool, // bit offset: 8 desc: ID Ready Interrupt -- this bit is set if the IDIE bit in CANxIER is 1, and a CAN Identifier has been received (a message was successfully transmitted or aborted). This bit is set whenever a message was successfully transmitted or aborted and the IDIE bit is set in the IER register.
        TI2: bool, // bit offset: 9 desc: Transmit Interrupt 2. This bit is set when the TBS2 bit in CANxSR goes from 0 to 1 (whenever a message out of TXB2 was successfully transmitted or aborted), indicating that Transmit buffer 2 is available, and the TIE2 bit in CANxIER is 1.
        TI3: bool, // bit offset: 10 desc: Transmit Interrupt 3. This bit is set when the TBS3 bit in CANxSR goes from 0 to 1 (whenever a message out of TXB3 was successfully transmitted or aborted), indicating that Transmit buffer 3 is available, and the TIE3 bit in CANxIER is 1.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ERRBIT4_0: u5, // bit offset: 16 desc: Error Code Capture: when the CAN controller detects a bus error, the location of the error within the frame is captured in this field. The value reflects an internal state variable, and as a result is not very linear: 00011 = Start of Frame 00010 = ID28 ... ID21 00110 = ID20 ... ID18 00100 = SRTR Bit 00101 = IDE bit 00111 = ID17 ... 13 01111 = ID12 ... ID5 01110 = ID4 ... ID0 01100 = RTR Bit 01101 = Reserved Bit 1 01001 = Reserved Bit 0 01011 = Data Length Code 01010 = Data Field 01000 = CRC Sequence 11000 = CRC Delimiter 11001 = Acknowledge Slot 11011 = Acknowledge Delimiter 11010 = End of Frame 10010 = Intermission Whenever a bus error occurs, the corresponding bus error interrupt is forced, if enabled. At the same time, the current position of the Bit Stream Processor is captured into the Error Code Capture Register. The content within this register is fixed until the user software has read out its content once. From now on, the capture mechanism is activated again, i.e. reading the CANxICR enables another Bus Error Interrupt.
        ERRDIR: bool, // bit offset: 21 desc: When the CAN controller detects a bus error, the direction of the current bit is captured in this bit.
        ERRC1_0: u2, // bit offset: 22 desc: When the CAN controller detects a bus error, the type of error is captured in this field:
        ALCBIT: u8, // bit offset: 24 desc: Each time arbitration is lost while trying to send on the CAN, the bit number within the frame is captured into this field. After the content of ALCBIT is read, the ALI bit is cleared and a new Arbitration Lost interrupt can occur. 00 = arbitration lost in the first bit (MS) of identifier ... 11 = arbitration lost in SRTS bit (RTR bit for standard frame messages) 12 = arbitration lost in IDE bit 13 = arbitration lost in 12th bit of identifier (extended frame only) ... 30 = arbitration lost in last bit of identifier (extended frame only) 31 = arbitration lost in RTR bit (extended frame only) On arbitration lost, the corresponding arbitration lost interrupt is forced, if enabled. At that time, the current bit position of the Bit Stream Processor is captured into the Arbitration Lost Capture Register. The content within this register is fixed until the user application has read out its contents once. From now on, the capture mechanism is activated again.
    });
    // byte offset: 16 Interrupt Enable
    pub const IER = mmio(Address + 0x00000010, 32, packed struct {
        RIE: bool, // bit offset: 0 desc: Receiver Interrupt Enable. When the Receive Buffer Status is 'full', the CAN Controller requests the respective interrupt.
        TIE1: bool, // bit offset: 1 desc: Transmit Interrupt Enable for Buffer1. When a message has been successfully transmitted out of TXB1 or Transmit Buffer 1 is accessible again (e.g. after an Abort Transmission command), the CAN Controller requests the respective interrupt.
        EIE: bool, // bit offset: 2 desc: Error Warning Interrupt Enable. If the Error or Bus Status change (see Status Register), the CAN Controller requests the respective interrupt.
        DOIE: bool, // bit offset: 3 desc: Data Overrun Interrupt Enable. If the Data Overrun Status bit is set (see Status Register), the CAN Controller requests the respective interrupt.
        WUIE: bool, // bit offset: 4 desc: Wake-Up Interrupt Enable. If the sleeping CAN controller wakes up, the respective interrupt is requested.
        EPIE: bool, // bit offset: 5 desc: Error Passive Interrupt Enable. If the error status of the CAN Controller changes from error active to error passive or vice versa, the respective interrupt is requested.
        ALIE: bool, // bit offset: 6 desc: Arbitration Lost Interrupt Enable. If the CAN Controller has lost arbitration, the respective interrupt is requested.
        BEIE: bool, // bit offset: 7 desc: Bus Error Interrupt Enable. If a bus error has been detected, the CAN Controller requests the respective interrupt.
        IDIE: bool, // bit offset: 8 desc: ID Ready Interrupt Enable. When a CAN identifier has been received, the CAN Controller requests the respective interrupt.
        TIE2: bool, // bit offset: 9 desc: Transmit Interrupt Enable for Buffer2. When a message has been successfully transmitted out of TXB2 or Transmit Buffer 2 is accessible again (e.g. after an Abort Transmission command), the CAN Controller requests the respective interrupt.
        TIE3: bool, // bit offset: 10 desc: Transmit Interrupt Enable for Buffer3. When a message has been successfully transmitted out of TXB3 or Transmit Buffer 3 is accessible again (e.g. after an Abort Transmission command), the CAN Controller requests the respective interrupt.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Bus Timing. Can only be written when RM in CANMOD is 1.
    pub const BTR = mmio(Address + 0x00000014, 32, packed struct {
        BRP: u10, // bit offset: 0 desc: Baud Rate Prescaler. The APB clock is divided by (this value plus one) to produce the CAN clock.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SJW: u2, // bit offset: 14 desc: The Synchronization Jump Width is (this value plus one) CAN clocks.
        TESG1: u4, // bit offset: 16 desc: The delay from the nominal Sync point to the sample point is (this value plus one) CAN clocks.
        TESG2: u3, // bit offset: 20 desc: The delay from the sample point to the next nominal sync point is (this value plus one) CAN clocks. The nominal CAN bit time is (this value plus the value in TSEG1 plus 3) CAN clocks.
        SAM: bool, // bit offset: 23 desc: Sampling
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Error Warning Limit. Can only be written when RM in CANMOD is 1.
    pub const EWL = mmio(Address + 0x00000018, 32, packed struct {
        EWL: u8, // bit offset: 0 desc: During CAN operation, this value is compared to both the Tx and Rx Error Counters. If either of these counter matches this value, the Error Status (ES) bit in CANSR is set.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Status Register
    pub const SR = mmio(Address + 0x0000001c, 32, packed struct {
        RBS_1: bool, // bit offset: 0 desc: Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
        DOS_1: bool, // bit offset: 1 desc: Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
        TBS1_1: bool, // bit offset: 2 desc: Transmit Buffer Status 1.
        TCS1_1: bool, // bit offset: 3 desc: Transmission Complete Status.
        RS_1: bool, // bit offset: 4 desc: Receive Status. This bit is identical to the RS bit in the GSR.
        TS1_1: bool, // bit offset: 5 desc: Transmit Status 1.
        ES_1: bool, // bit offset: 6 desc: Error Status. This bit is identical to the ES bit in the CANxGSR.
        BS_1: bool, // bit offset: 7 desc: Bus Status. This bit is identical to the BS bit in the CANxGSR.
        RBS_2: bool, // bit offset: 8 desc: Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
        DOS_2: bool, // bit offset: 9 desc: Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
        TBS2_2: bool, // bit offset: 10 desc: Transmit Buffer Status 2.
        TCS2_2: bool, // bit offset: 11 desc: Transmission Complete Status.
        RS_2: bool, // bit offset: 12 desc: Receive Status. This bit is identical to the RS bit in the GSR.
        TS2_2: bool, // bit offset: 13 desc: Transmit Status 2.
        ES_2: bool, // bit offset: 14 desc: Error Status. This bit is identical to the ES bit in the CANxGSR.
        BS_2: bool, // bit offset: 15 desc: Bus Status. This bit is identical to the BS bit in the CANxGSR.
        RBS_3: bool, // bit offset: 16 desc: Receive Buffer Status. This bit is identical to the RBS bit in the CANxGSR.
        DOS_3: bool, // bit offset: 17 desc: Data Overrun Status. This bit is identical to the DOS bit in the CANxGSR.
        TBS3_3: bool, // bit offset: 18 desc: Transmit Buffer Status 3.
        TCS3_3: bool, // bit offset: 19 desc: Transmission Complete Status.
        RS_3: bool, // bit offset: 20 desc: Receive Status. This bit is identical to the RS bit in the GSR.
        TS3_3: bool, // bit offset: 21 desc: Transmit Status 3.
        ES_3: bool, // bit offset: 22 desc: Error Status. This bit is identical to the ES bit in the CANxGSR.
        BS_3: bool, // bit offset: 23 desc: Bus Status. This bit is identical to the BS bit in the CANxGSR.
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 Receive frame status. Can only be written when RM in CANMOD is 1.
    pub const RFS = mmio(Address + 0x00000020, 32, packed struct {
        IDINDEX: u10, // bit offset: 0 desc: ID Index. If the BP bit (below) is 0, this value is the zero-based number of the Lookup Table RAM entry at which the Acceptance Filter matched the received Identifier. Disabled entries in the Standard tables are included in this numbering, but will not be matched. See Section 21.17 Examples of acceptance filter tables and ID index values on page 587 for examples of ID Index values.
        BP: bool, // bit offset: 10 desc: If this bit is 1, the current message was received in AF Bypass mode, and the ID Index field (above) is meaningless.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: The field contains the Data Length Code (DLC) field of the current received message. When RTR = 0, this is related to the number of data bytes available in the CANRDA and CANRDB registers as follows: 0000-0111 = 0 to 7 bytes1000-1111 = 8 bytes With RTR = 1, this value indicates the number of data bytes requested to be sent back, with the same encoding.
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This bit contains the Remote Transmission Request bit of the current received message. 0 indicates a Data Frame, in which (if DLC is non-zero) data can be read from the CANRDA and possibly the CANRDB registers. 1 indicates a Remote frame, in which case the DLC value identifies the number of data bytes requested to be sent using the same Identifier.
        FF: bool, // bit offset: 31 desc: A 0 in this bit indicates that the current received message included an 11-bit Identifier, while a 1 indicates a 29-bit Identifier. This affects the contents of the CANid register described below.
    });
    // byte offset: 36 Received Identifier. Can only be written when RM in CANMOD is 1.
    pub const RID = mmio(Address + 0x00000024, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier field of the current received message. In CAN 2.0A, these bits are called ID10-0, while in CAN 2.0B they're called ID29-18.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Received data bytes 1-4. Can only be written when RM in CANMOD is 1.
    pub const RDA = mmio(Address + 0x00000028, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If the DLC field in CANRFS >= 0001, this contains the first Data byte of the current received message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If the DLC field in CANRFS >= 0010, this contains the first Data byte of the current received message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If the DLC field in CANRFS >= 0011, this contains the first Data byte of the current received message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If the DLC field in CANRFS >= 0100, this contains the first Data byte of the current received message.
    });
    // byte offset: 44 Received data bytes 5-8. Can only be written when RM in CANMOD is 1.
    pub const RDB = mmio(Address + 0x0000002c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If the DLC field in CANRFS >= 0101, this contains the first Data byte of the current received message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If the DLC field in CANRFS >= 0110, this contains the first Data byte of the current received message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If the DLC field in CANRFS >= 0111, this contains the first Data byte of the current received message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If the DLC field in CANRFS >= 1000, this contains the first Data byte of the current received message.
    });
    // byte offset: 48 Transmit frame info (Tx Buffer )
    pub const TFI1 = mmio(Address + 0x00000030, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 48 Transmit frame info (Tx Buffer )
    pub const TFI1 = mmio(Address + 0x00000030, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 52 Transmit Identifier (Tx Buffer)
    pub const TID1 = mmio(Address + 0x00000034, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 52 Transmit Identifier (Tx Buffer)
    pub const TID1 = mmio(Address + 0x00000034, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 56 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA1 = mmio(Address + 0x00000038, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 56 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA1 = mmio(Address + 0x00000038, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 60 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB1 = mmio(Address + 0x0000003c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
    // byte offset: 60 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB1 = mmio(Address + 0x0000003c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
    // byte offset: 64 Transmit frame info (Tx Buffer )
    pub const TFI2 = mmio(Address + 0x00000040, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 64 Transmit frame info (Tx Buffer )
    pub const TFI2 = mmio(Address + 0x00000040, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 68 Transmit Identifier (Tx Buffer)
    pub const TID2 = mmio(Address + 0x00000044, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 68 Transmit Identifier (Tx Buffer)
    pub const TID2 = mmio(Address + 0x00000044, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 72 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA2 = mmio(Address + 0x00000048, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 72 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA2 = mmio(Address + 0x00000048, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 76 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB2 = mmio(Address + 0x0000004c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
    // byte offset: 76 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB2 = mmio(Address + 0x0000004c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
    // byte offset: 80 Transmit frame info (Tx Buffer )
    pub const TFI3 = mmio(Address + 0x00000050, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 80 Transmit frame info (Tx Buffer )
    pub const TFI3 = mmio(Address + 0x00000050, 32, packed struct {
        PRIO: u8, // bit offset: 0 desc: If the TPM (Transmit Priority Mode) bit in the CANxMOD register is set to 1, enabled Tx Buffers contend for the right to send their messages based on this field. The buffer with the lowest TX Priority value wins the prioritization and is sent first.
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        DLC: u4, // bit offset: 16 desc: Data Length Code. This value is sent in the DLC field of the next transmit message. In addition, if RTR = 0, this value controls the number of Data bytes sent in the next transmit message, from the CANxTDA and CANxTDB registers: 0000-0111 = 0-7 bytes 1xxx = 8 bytes
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RTR: bool, // bit offset: 30 desc: This value is sent in the RTR bit of the next transmit message. If this bit is 0, the number of data bytes called out by the DLC field are sent from the CANxTDA and CANxTDB registers. If this bit is 1, a Remote Frame is sent, containing a request for that number of bytes.
        FF: bool, // bit offset: 31 desc: If this bit is 0, the next transmit message will be sent with an 11-bit Identifier (standard frame format), while if it's 1, the message will be sent with a 29-bit Identifier (extended frame format).
    });
    // byte offset: 84 Transmit Identifier (Tx Buffer)
    pub const TID3 = mmio(Address + 0x00000054, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 84 Transmit Identifier (Tx Buffer)
    pub const TID3 = mmio(Address + 0x00000054, 32, packed struct {
        ID: u11, // bit offset: 0 desc: The 11-bit Identifier to be sent in the next transmit message.
    });
    // byte offset: 88 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA3 = mmio(Address + 0x00000058, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 88 Transmit data bytes 1-4 (Tx Buffer)
    pub const TDA3 = mmio(Address + 0x00000058, 32, packed struct {
        DATA1: u8, // bit offset: 0 desc: Data 1. If RTR = 0 and DLC >= 0001 in the corresponding CANxTFI, this byte is sent as the first Data byte of the next transmit message.
        DATA2: u8, // bit offset: 8 desc: Data 2. If RTR = 0 and DLC >= 0010 in the corresponding CANxTFI, this byte is sent as the 2nd Data byte of the next transmit message.
        DATA3: u8, // bit offset: 16 desc: Data 3. If RTR = 0 and DLC >= 0011 in the corresponding CANxTFI, this byte is sent as the 3rd Data byte of the next transmit message.
        DATA4: u8, // bit offset: 24 desc: Data 4. If RTR = 0 and DLC >= 0100 in the corresponding CANxTFI, this byte is sent as the 4th Data byte of the next transmit message.
    });
    // byte offset: 92 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB3 = mmio(Address + 0x0000005c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
    // byte offset: 92 Transmit data bytes 5-8 (Tx Buffer )
    pub const TDB3 = mmio(Address + 0x0000005c, 32, packed struct {
        DATA5: u8, // bit offset: 0 desc: Data 5. If RTR = 0 and DLC >= 0101 in the corresponding CANTFI, this byte is sent as the 5th Data byte of the next transmit message.
        DATA6: u8, // bit offset: 8 desc: Data 6. If RTR = 0 and DLC >= 0110 in the corresponding CANTFI, this byte is sent as the 6th Data byte of the next transmit message.
        DATA7: u8, // bit offset: 16 desc: Data 7. If RTR = 0 and DLC >= 0111 in the corresponding CANTFI, this byte is sent as the 7th Data byte of the next transmit message.
        DATA8: u8, // bit offset: 24 desc: Data 8. If RTR = 0 and DLC >= 1000 in the corresponding CANTFI, this byte is sent as the 8th Data byte of the next transmit message.
    });
};
pub const I2C1 = extern struct {
    pub const Address: u32 = 0x4005c000;
    // byte offset: 0 I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
    pub const CONSET = mmio(Address + 0x00000000, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        AA: bool, // bit offset: 2 desc: Assert acknowledge flag.
        SI: bool, // bit offset: 3 desc: I2C interrupt flag.
        STO: bool, // bit offset: 4 desc: STOP flag.
        STA: bool, // bit offset: 5 desc: START flag.
        I2EN: bool, // bit offset: 6 desc: I2C interface enable.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
    pub const STAT = mmio(Address + 0x00000004, 32, packed struct {
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        Status: u5, // bit offset: 3 desc: These bits give the actual status information about the I 2C interface.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
    pub const DAT = mmio(Address + 0x00000008, 32, packed struct {
        Data: u8, // bit offset: 0 desc: This register holds data values that have been received or are to be transmitted.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR0 = mmio(Address + 0x0000000c, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
    pub const SCLH = mmio(Address + 0x00000010, 32, packed struct {
        SCLH: u16, // bit offset: 0 desc: Count for SCL HIGH time period selection.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
    pub const SCLL = mmio(Address + 0x00000014, 32, packed struct {
        SCLL: u16, // bit offset: 0 desc: Count for SCL low time period selection.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
    pub const CONCLR = mmio(Address + 0x00000018, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        AAC: bool, // bit offset: 2 desc: Assert acknowledge Clear bit.
        SIC: bool, // bit offset: 3 desc: I2C interrupt Clear bit.
        reserved2: u1 = 0,
        STAC: bool, // bit offset: 5 desc: START flag Clear bit.
        I2ENC: bool, // bit offset: 6 desc: I2C interface Disable bit.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Monitor mode control register.
    pub const MMCTRL = mmio(Address + 0x0000001c, 32, packed struct {
        MM_ENA: bool, // bit offset: 0 desc: Monitor mode enable.
        ENA_SCL: bool, // bit offset: 1 desc: SCL output enable.
        MATCH_ALL: bool, // bit offset: 2 desc: Select interrupt register match.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR1 = mmio(Address + 0x00000020, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 32 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR1 = mmio(Address + 0x00000020, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 36 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR2 = mmio(Address + 0x00000024, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 36 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR2 = mmio(Address + 0x00000024, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 40 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR3 = mmio(Address + 0x00000028, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 40 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR3 = mmio(Address + 0x00000028, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 44 Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
    pub const DATA_BUFFER = mmio(Address + 0x0000002c, 32, packed struct {
        Data: u8, // bit offset: 0 desc: This register holds contents of the 8 MSBs of the DAT shift register.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 I2C Slave address mask register
    pub const MASK_0 = mmio(Address + 0x00000030, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 48 I2C Slave address mask register
    pub const MASK_0 = mmio(Address + 0x00000030, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 52 I2C Slave address mask register
    pub const MASK_1 = mmio(Address + 0x00000034, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 52 I2C Slave address mask register
    pub const MASK_1 = mmio(Address + 0x00000034, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 56 I2C Slave address mask register
    pub const MASK_2 = mmio(Address + 0x00000038, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 56 I2C Slave address mask register
    pub const MASK_2 = mmio(Address + 0x00000038, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 60 I2C Slave address mask register
    pub const MASK_3 = mmio(Address + 0x0000003c, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 60 I2C Slave address mask register
    pub const MASK_3 = mmio(Address + 0x0000003c, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
};
pub const SSP0 = extern struct {
    pub const Address: u32 = 0x40088000;
    // byte offset: 0 Control Register 0. Selects the serial clock rate, bus type, and data size.
    pub const CR0 = mmio(Address + 0x00000000, 32, packed struct {
        DSS: u4, // bit offset: 0 desc: Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used.
        FRF: u2, // bit offset: 4 desc: Frame Format.
        CPOL: bool, // bit offset: 6 desc: Clock Out Polarity. This bit is only used in SPI mode.
        CPHA: bool, // bit offset: 7 desc: Clock Out Phase. This bit is only used in SPI mode.
        SCR: u8, // bit offset: 8 desc: Serial Clock Rate. The number of prescaler-output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X [SCR+1]).
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Control Register 1. Selects master/slave and other modes.
    pub const CR1 = mmio(Address + 0x00000004, 32, packed struct {
        LBM: bool, // bit offset: 0 desc: Loop Back Mode.
        SSE: bool, // bit offset: 1 desc: SSP Enable.
        MS: bool, // bit offset: 2 desc: Master/Slave Mode.This bit can only be written when the SSE bit is 0.
        SOD: bool, // bit offset: 3 desc: Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SSP controller from driving the transmit data line (MISO).
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
    pub const DR = mmio(Address + 0x00000008, 32, packed struct {
        DATA: u16, // bit offset: 0 desc: Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SSP controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bits, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SSP controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bits, the data is right-justified in this field with higher order bits filled with 0s.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Status Register
    pub const SR = mmio(Address + 0x0000000c, 32, packed struct {
        TFE: bool, // bit offset: 0 desc: Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not.
        TNF: bool, // bit offset: 1 desc: Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not.
        RNE: bool, // bit offset: 2 desc: Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not.
        RFF: bool, // bit offset: 3 desc: Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not.
        BSY: bool, // bit offset: 4 desc: Busy. This bit is 0 if the SSPn controller is idle, or 1 if it is currently sending/receiving a frame and/or the Tx FIFO is not empty.
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 Clock Prescale Register
    pub const CPSR = mmio(Address + 0x00000010, 32, packed struct {
        CPSDVSR: u8, // bit offset: 0 desc: This even value between 2 and 254, by which PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Interrupt Mask Set and Clear Register
    pub const IMSC = mmio(Address + 0x00000014, 32, packed struct {
        RORIM: bool, // bit offset: 0 desc: Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.
        RTIM: bool, // bit offset: 1 desc: Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
        RXIM: bool, // bit offset: 2 desc: Software should set this bit to enable interrupt when the Rx FIFO is at least half full.
        TXIM: bool, // bit offset: 3 desc: Software should set this bit to enable interrupt when the Tx FIFO is at least half empty.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Raw Interrupt Status Register
    pub const RIS = mmio(Address + 0x00000018, 32, packed struct {
        RORRIS: bool, // bit offset: 0 desc: This bit is 1 if another frame was completely received while the RxFIFO was full. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.
        RTRIS: bool, // bit offset: 1 desc: This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
        RXRIS: bool, // bit offset: 2 desc: This bit is 1 if the Rx FIFO is at least half full.
        TXRIS: bool, // bit offset: 3 desc: This bit is 1 if the Tx FIFO is at least half empty.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Masked Interrupt Status Register
    pub const MIS = mmio(Address + 0x0000001c, 32, packed struct {
        RORMIS: bool, // bit offset: 0 desc: This bit is 1 if another frame was completely received while the RxFIFO was full, and this interrupt is enabled.
        RTMIS: bool, // bit offset: 1 desc: This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out period, and this interrupt is enabled. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR X [SCR+1]).
        RXMIS: bool, // bit offset: 2 desc: This bit is 1 if the Rx FIFO is at least half full, and this interrupt is enabled.
        TXMIS: bool, // bit offset: 3 desc: This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is enabled.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 SSPICR Interrupt Clear Register
    pub const ICR = mmio(Address + 0x00000020, 32, packed struct {
        RORIC: bool, // bit offset: 0 desc: Writing a 1 to this bit clears the frame was received when RxFIFO was full interrupt.
        RTIC: bool, // bit offset: 1 desc: Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read for a time-out period interrupt. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR / [SCR+1]).
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 SSP0 DMA control register
    pub const DMACR = mmio(Address + 0x00000024, 32, packed struct {
        RXDMAE: bool, // bit offset: 0 desc: Receive DMA Enable. When this bit is set to one 1, DMA for the receive FIFO is enabled, otherwise receive DMA is disabled.
        TXDMAE: bool, // bit offset: 1 desc: Transmit DMA Enable. When this bit is set to one 1, DMA for the transmit FIFO is enabled, otherwise transmit DMA is disabled
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const DAC = extern struct {
    pub const Address: u32 = 0x4008c000;
    // byte offset: 0 D/A Converter Register. This register contains the digital value to be converted to analog and a power control bit.
    pub const CR = mmio(Address + 0x00000000, 32, packed struct {
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        VALUE: u10, // bit offset: 6 desc: After the selected settling time after this field is written with a new VALUE, the voltage on the DAC_OUT pin (with respect to VSSA) is VALUE x ((VREFP - V REFN)/1024) + VREFN.
        BIAS: bool, // bit offset: 16 desc: Settling time The settling times noted in the description of the BIAS bit are valid for a capacitance load on the DAC_OUT pin not exceeding 100 pF. A load impedance value greater than that value will cause settling time longer than the specified time. One or more graphs of load impedance vs. settling time will be included in the final data sheet.
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 DAC Control register. This register controls DMA and timer operation.
    pub const CTRL = mmio(Address + 0x00000004, 32, packed struct {
        INT_DMA_REQ: bool, // bit offset: 0 desc: DMA interrupt request
        DBLBUF_ENA: bool, // bit offset: 1 desc: Double buffering
        CNT_ENA: bool, // bit offset: 2 desc: Time-out counter operation
        DMA_ENA: bool, // bit offset: 3 desc: DMA access
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 DAC Counter Value register. This register contains the reload value for the DAC DMA/Interrupt timer.
    pub const CNTVAL = mmio(Address + 0x00000008, 32, packed struct {
        VALUE: u16, // bit offset: 0 desc: 16-bit reload value for the DAC interrupt/DMA timer.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const TIMER2 = extern struct {
    pub const Address: u32 = 0x40090000;
    // byte offset: 0 Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
    pub const IR = mmio(Address + 0x00000000, 32, packed struct {
        MR0INT: bool, // bit offset: 0 desc: Interrupt flag for match channel 0.
        MR1INT: bool, // bit offset: 1 desc: Interrupt flag for match channel 1.
        MR2INT: bool, // bit offset: 2 desc: Interrupt flag for match channel 2.
        MR3INT: bool, // bit offset: 3 desc: Interrupt flag for match channel 3.
        CR0INT: bool, // bit offset: 4 desc: Interrupt flag for capture channel 0 event.
        CR1INT: bool, // bit offset: 5 desc: Interrupt flag for capture channel 1 event.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    pub const TCR = mmio(Address + 0x00000004, 32, packed struct {
        CEN: bool, // bit offset: 0 desc: When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled.
        CRST: bool, // bit offset: 1 desc: When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    pub const TC = mmio(Address + 0x00000008, 32, packed struct {
        TC: u32, // bit offset: 0 desc: Timer counter value.
    });
    // byte offset: 12 Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
    pub const PR = mmio(Address + 0x0000000c, 32, packed struct {
        PM: u32, // bit offset: 0 desc: Prescale counter maximum value.
    });
    // byte offset: 16 Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    pub const PC = mmio(Address + 0x00000010, 32, packed struct {
        PC: u32, // bit offset: 0 desc: Prescale counter value.
    });
    // byte offset: 20 Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    pub const MCR = mmio(Address + 0x00000014, 32, packed struct {
        MR0I: bool, // bit offset: 0 desc: Interrupt on MR0
        MR0R: bool, // bit offset: 1 desc: Reset on MR0
        MR0S: bool, // bit offset: 2 desc: Stop on MR0
        MR1I: bool, // bit offset: 3 desc: Interrupt on MR1
        MR1R: bool, // bit offset: 4 desc: Reset on MR1
        MR1S: bool, // bit offset: 5 desc: Stop on MR1
        MR2I: bool, // bit offset: 6 desc: Interrupt on MR2
        MR2R: bool, // bit offset: 7 desc: Reset on MR2
        MR2S: bool, // bit offset: 8 desc: Stop on MR2.
        MR3I: bool, // bit offset: 9 desc: Interrupt on MR3
        MR3R: bool, // bit offset: 10 desc: Reset on MR3
        MR3S: bool, // bit offset: 11 desc: Stop on MR3
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 24 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 40 Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    pub const CCR = mmio(Address + 0x00000028, 32, packed struct {
        CAP0RE: bool, // bit offset: 0 desc: Capture on CAPn.0 rising edge
        CAP0FE: bool, // bit offset: 1 desc: Capture on CAPn.0 falling edge
        CAP0I: bool, // bit offset: 2 desc: Interrupt on CAPn.0 event
        CAP1RE: bool, // bit offset: 3 desc: Capture on CAPn.1 rising edge
        CAP1FE: bool, // bit offset: 4 desc: Capture on CAPn.1 falling edge
        CAP1I: bool, // bit offset: 5 desc: Interrupt on CAPn.1 event
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 44 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 48 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 48 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 60 External Match Register. The EMR controls the external match pins.
    pub const EMR = mmio(Address + 0x0000003c, 32, packed struct {
        EM0: bool, // bit offset: 0 desc: External Match 0. When a match occurs between the TC and MR0, this bit can either toggle, go low, go high, or do nothing, depending on bits 5:4 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM1: bool, // bit offset: 1 desc: External Match 1. When a match occurs between the TC and MR1, this bit can either toggle, go low, go high, or do nothing, depending on bits 7:6 of this register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner (0 = low, 1 = high).
        EM2: bool, // bit offset: 2 desc: External Match 2. When a match occurs between the TC and MR2, this bit can either toggle, go low, go high, or do nothing, depending on bits 9:8 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM3: bool, // bit offset: 3 desc: External Match 3. When a match occurs between the TC and MR3, this bit can either toggle, go low, go high, or do nothing, depending on bits 11:10 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EMC0: u2, // bit offset: 4 desc: External Match Control 0. Determines the functionality of External Match 0.
        EMC1: u2, // bit offset: 6 desc: External Match Control 1. Determines the functionality of External Match 1.
        EMC2: u2, // bit offset: 8 desc: External Match Control 2. Determines the functionality of External Match 2.
        EMC3: u2, // bit offset: 10 desc: External Match Control 3. Determines the functionality of External Match 3.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    pub const CTCR = mmio(Address + 0x00000070, 32, packed struct {
        CTMODE: u2, // bit offset: 0 desc: Counter/Timer Mode This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale Register.
        CINSEL: u2, // bit offset: 2 desc: Count Input Select When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected for a particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture Control Register (TnCCR) must be programmed as 000. However, capture and/or interrupt can be selected for the other 3 CAPn inputs in the same timer.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const TIMER3 = extern struct {
    pub const Address: u32 = 0x40094000;
    // byte offset: 0 Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending.
    pub const IR = mmio(Address + 0x00000000, 32, packed struct {
        MR0INT: bool, // bit offset: 0 desc: Interrupt flag for match channel 0.
        MR1INT: bool, // bit offset: 1 desc: Interrupt flag for match channel 1.
        MR2INT: bool, // bit offset: 2 desc: Interrupt flag for match channel 2.
        MR3INT: bool, // bit offset: 3 desc: Interrupt flag for match channel 3.
        CR0INT: bool, // bit offset: 4 desc: Interrupt flag for capture channel 0 event.
        CR1INT: bool, // bit offset: 5 desc: Interrupt flag for capture channel 1 event.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    pub const TCR = mmio(Address + 0x00000004, 32, packed struct {
        CEN: bool, // bit offset: 0 desc: When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled.
        CRST: bool, // bit offset: 1 desc: When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    pub const TC = mmio(Address + 0x00000008, 32, packed struct {
        TC: u32, // bit offset: 0 desc: Timer counter value.
    });
    // byte offset: 12 Prescale Register. When the Prescale Counter (PC) is equal to this value, the next clock increments the TC and clears the PC.
    pub const PR = mmio(Address + 0x0000000c, 32, packed struct {
        PM: u32, // bit offset: 0 desc: Prescale counter maximum value.
    });
    // byte offset: 16 Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    pub const PC = mmio(Address + 0x00000010, 32, packed struct {
        PC: u32, // bit offset: 0 desc: Prescale counter value.
    });
    // byte offset: 20 Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    pub const MCR = mmio(Address + 0x00000014, 32, packed struct {
        MR0I: bool, // bit offset: 0 desc: Interrupt on MR0
        MR0R: bool, // bit offset: 1 desc: Reset on MR0
        MR0S: bool, // bit offset: 2 desc: Stop on MR0
        MR1I: bool, // bit offset: 3 desc: Interrupt on MR1
        MR1R: bool, // bit offset: 4 desc: Reset on MR1
        MR1S: bool, // bit offset: 5 desc: Stop on MR1
        MR2I: bool, // bit offset: 6 desc: Interrupt on MR2
        MR2R: bool, // bit offset: 7 desc: Reset on MR2
        MR2S: bool, // bit offset: 8 desc: Stop on MR2.
        MR3I: bool, // bit offset: 9 desc: Interrupt on MR3
        MR3R: bool, // bit offset: 10 desc: Reset on MR3
        MR3S: bool, // bit offset: 11 desc: Stop on MR3
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 24 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_0 = mmio(Address + 0x00000018, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 28 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 32 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_2 = mmio(Address + 0x00000020, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 36 Match Register 0. MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC.
    pub const MR_3 = mmio(Address + 0x00000024, 32, packed struct {
        MATCH: u32, // bit offset: 0 desc: Timer counter match value.
    });
    // byte offset: 40 Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    pub const CCR = mmio(Address + 0x00000028, 32, packed struct {
        CAP0RE: bool, // bit offset: 0 desc: Capture on CAPn.0 rising edge
        CAP0FE: bool, // bit offset: 1 desc: Capture on CAPn.0 falling edge
        CAP0I: bool, // bit offset: 2 desc: Interrupt on CAPn.0 event
        CAP1RE: bool, // bit offset: 3 desc: Capture on CAPn.1 rising edge
        CAP1FE: bool, // bit offset: 4 desc: Capture on CAPn.1 falling edge
        CAP1I: bool, // bit offset: 5 desc: Interrupt on CAPn.1 event
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 44 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_0 = mmio(Address + 0x0000002c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 48 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 48 Capture Register 0. CR0 is loaded with the value of TC when there is an event on the CAPn.0 input.
    pub const CR_1 = mmio(Address + 0x00000030, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Timer counter capture value.
    });
    // byte offset: 60 External Match Register. The EMR controls the external match pins.
    pub const EMR = mmio(Address + 0x0000003c, 32, packed struct {
        EM0: bool, // bit offset: 0 desc: External Match 0. When a match occurs between the TC and MR0, this bit can either toggle, go low, go high, or do nothing, depending on bits 5:4 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM1: bool, // bit offset: 1 desc: External Match 1. When a match occurs between the TC and MR1, this bit can either toggle, go low, go high, or do nothing, depending on bits 7:6 of this register. This bit can be driven onto a MATn.1 pin, in a positive-logic manner (0 = low, 1 = high).
        EM2: bool, // bit offset: 2 desc: External Match 2. When a match occurs between the TC and MR2, this bit can either toggle, go low, go high, or do nothing, depending on bits 9:8 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EM3: bool, // bit offset: 3 desc: External Match 3. When a match occurs between the TC and MR3, this bit can either toggle, go low, go high, or do nothing, depending on bits 11:10 of this register. This bit can be driven onto a MATn.0 pin, in a positive-logic manner (0 = low, 1 = high).
        EMC0: u2, // bit offset: 4 desc: External Match Control 0. Determines the functionality of External Match 0.
        EMC1: u2, // bit offset: 6 desc: External Match Control 1. Determines the functionality of External Match 1.
        EMC2: u2, // bit offset: 8 desc: External Match Control 2. Determines the functionality of External Match 2.
        EMC3: u2, // bit offset: 10 desc: External Match Control 3. Determines the functionality of External Match 3.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    pub const CTCR = mmio(Address + 0x00000070, 32, packed struct {
        CTMODE: u2, // bit offset: 0 desc: Counter/Timer Mode This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: the TC is incremented when the Prescale Counter matches the Prescale Register.
        CINSEL: u2, // bit offset: 2 desc: Count Input Select When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected for a particular CAPn input in the TnCTCR, the 3 bits for that input in the Capture Control Register (TnCCR) must be programmed as 000. However, capture and/or interrupt can be selected for the other 3 CAPn inputs in the same timer.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const UART2 = extern struct {
    pub const Address: u32 = 0x40098000;
    // byte offset: 0 Receiver Buffer Register. Contains the next received character to be read (DLAB =0).
    pub const RBR = mmio(Address + 0x00000000, 32, packed struct {
        RBR: u8, // bit offset: 0 desc: The UARTn Receiver Buffer Register contains the oldest received byte in the UARTn Rx FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 Transmit Holding Regiter. The next character to be transmitted is written here (DLAB =0).
    pub const THR = mmio(Address + 0x00000000, 32, packed struct {
        THR: u8, // bit offset: 0 desc: Writing to the UARTn Transmit Holding Register causes the data to be stored in the UARTn transmit FIFO. The byte will be sent when it reaches the bottom of the FIFO and the transmitter is available.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
    pub const DLL = mmio(Address + 0x00000000, 32, packed struct {
        DLLSB: u8, // bit offset: 0 desc: The UARTn Divisor Latch LSB Register, along with the UnDLM register, determines the baud rate of the UARTn.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
    pub const DLM = mmio(Address + 0x00000004, 32, packed struct {
        DLMSB: u8, // bit offset: 0 desc: The UARTn Divisor Latch MSB Register, along with the U0DLL register, determines the baud rate of the UARTn.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts (DLAB =0).
    pub const IER = mmio(Address + 0x00000004, 32, packed struct {
        RBRIE: bool, // bit offset: 0 desc: RBR Interrupt Enable. Enables the Receive Data Available interrupt for UARTn. It also controls the Character Receive Time-out interrupt.
        THREIE: bool, // bit offset: 1 desc: THRE Interrupt Enable. Enables the THRE interrupt for UARTn. The status of this can be read from UnLSR[5].
        RXIE: bool, // bit offset: 2 desc: RX Line Status Interrupt Enable. Enables the UARTn RX line status interrupts. The status of this interrupt can be read from UnLSR[4:1].
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABEOINTEN: bool, // bit offset: 8 desc: Enables the end of auto-baud interrupt.
        ABTOINTEN: bool, // bit offset: 9 desc: Enables the auto-baud time-out interrupt.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Interrupt ID Register. Identifies which interrupt(s) are pending.
    pub const IIR = mmio(Address + 0x00000008, 32, packed struct {
        INTSTATUS: bool, // bit offset: 0 desc: Interrupt status. Note that UnIIR[0] is active low. The pending interrupt can be determined by evaluating UnIIR[3:1].
        INTID: u3, // bit offset: 1 desc: Interrupt identification. UnIER[3:1] identifies an interrupt corresponding to the UARTn Rx or TX FIFO. All other combinations of UnIER[3:1] not listed below are reserved (000,100,101,111).
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        FIFOENABLE: u2, // bit offset: 6 desc: Copies of UnFCR[0].
        ABEOINT: bool, // bit offset: 8 desc: End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled.
        ABTOINT: bool, // bit offset: 9 desc: Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 FIFO Control Register. Controls UART FIFO usage and modes.
    pub const FCR = mmio(Address + 0x00000008, 32, packed struct {
        FIFOEN: bool, // bit offset: 0 desc: FIFO Enable.
        RXFIFORES: bool, // bit offset: 1 desc: RX FIFO Reset.
        TXFIFORES: bool, // bit offset: 2 desc: TX FIFO Reset.
        DMAMODE: bool, // bit offset: 3 desc: DMA Mode Select. When the FIFO enable (bit 0 of this register) is set, this bit selects the DMA mode. See Section 18.6.6.1.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXTRIGLVL: u2, // bit offset: 6 desc: RX Trigger Level. These two bits determine how many receiver UARTn FIFO characters must be written before an interrupt or DMA request is activated.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Line Control Register. Contains controls for frame formatting and break generation.
    pub const LCR = mmio(Address + 0x0000000c, 32, packed struct {
        WLS: u2, // bit offset: 0 desc: Word Length Select.
        SBS: bool, // bit offset: 2 desc: Stop Bit Select
        PE: bool, // bit offset: 3 desc: Parity Enable.
        PS: u2, // bit offset: 4 desc: Parity Select
        BC: bool, // bit offset: 6 desc: Break Control
        DLAB: bool, // bit offset: 7 desc: Divisor Latch Access Bit
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Line Status Register. Contains flags for transmit and receive status, including line errors.
    pub const LSR = mmio(Address + 0x00000014, 32, packed struct {
        RDR: bool, // bit offset: 0 desc: Receiver Data Ready. UnLSR[0] is set when the UnRBR holds an unread character and is cleared when the UARTn RBR FIFO is empty.
        OE: bool, // bit offset: 1 desc: Overrun Error. The overrun error condition is set as soon as it occurs. An UnLSR read clears UnLSR[1]. UnLSR[1] is set when UARTn RSR has a new character assembled and the UARTn RBR FIFO is full. In this case, the UARTn RBR FIFO will not be overwritten and the character in the UARTn RSR will be lost.
        PE: bool, // bit offset: 2 desc: Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. An UnLSR read clears UnLSR[2]. Time of parity error detection is dependent on UnFCR[0]. Note: A parity error is associated with the character at the top of the UARTn RBR FIFO.
        FE: bool, // bit offset: 3 desc: Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. An UnLSR read clears UnLSR[3]. The time of the framing error detection is dependent on UnFCR[0]. Upon detection of a framing error, the Rx will attempt to resynchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UARTn RBR FIFO.
        BI: bool, // bit offset: 4 desc: Break Interrupt. When RXDn is held in the spacing state (all zeroes) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXDn goes to marking state (all ones). An UnLSR read clears this status bit. The time of break detection is dependent on UnFCR[0]. Note: The break interrupt is associated with the character at the top of the UARTn RBR FIFO.
        THRE: bool, // bit offset: 5 desc: Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UARTn THR and is cleared on a UnTHR write.
        TEMT: bool, // bit offset: 6 desc: Transmitter Empty. TEMT is set when both UnTHR and UnTSR are empty; TEMT is cleared when either the UnTSR or the UnTHR contain valid data.
        RXFE: bool, // bit offset: 7 desc: Error in RX FIFO . UnLSR[7] is set when a character with a Rx error such as framing error, parity error or break interrupt, is loaded into the UnRBR. This bit is cleared when the UnLSR register is read and there are no subsequent errors in the UARTn FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Scratch Pad Register. 8-bit temporary storage for software.
    pub const SCR = mmio(Address + 0x0000001c, 32, packed struct {
        PAD: u8, // bit offset: 0 desc: A readable, writable byte.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 Auto-baud Control Register. Contains controls for the auto-baud feature.
    pub const ACR = mmio(Address + 0x00000020, 32, packed struct {
        START: bool, // bit offset: 0 desc: Start bit. This bit is automatically cleared after auto-baud completion.
        MODE: bool, // bit offset: 1 desc: Auto-baud mode select bit.
        AUTORESTART: bool, // bit offset: 2 desc: Restart bit.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABEOINTCLR: bool, // bit offset: 8 desc: End of auto-baud interrupt clear bit (write-only accessible). Writing a 1 will clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
        ABTOINTCLR: bool, // bit offset: 9 desc: Auto-baud time-out interrupt clear bit (write-only accessible). Writing a 1 will clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Fractional Divider Register. Generates a clock input for the baud rate divider.
    pub const FDR = mmio(Address + 0x00000028, 32, packed struct {
        DIVADDVAL: u4, // bit offset: 0 desc: Baud-rate generation pre-scaler divisor value. If this field is 0, fractional baud-rate generator will not impact the UARTn baudrate.
        MULVAL: u4, // bit offset: 4 desc: Baud-rate pre-scaler multiplier value. This field must be greater or equal 1 for UARTn to operate properly, regardless of whether the fractional baud-rate generator is used or not.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 Transmit Enable Register. Turns off UART transmitter for use with software flow control.
    pub const TER = mmio(Address + 0x00000030, 32, packed struct {
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TXEN: bool, // bit offset: 7 desc: When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit is cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software implementing software-handshaking can clear this bit when it receives an XOFF character (DC3). Software can set this bit again when it receives an XON (DC1) character.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 76 RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
    pub const RS485CTRL = mmio(Address + 0x0000004c, 32, packed struct {
        NMMEN: bool, // bit offset: 0 desc: NMM enable.
        RXDIS: bool, // bit offset: 1 desc: Receiver enable.
        AADEN: bool, // bit offset: 2 desc: AAD enable.
        reserved1: u1 = 0,
        DCTRL: bool, // bit offset: 4 desc: Direction control enable.
        OINV: bool, // bit offset: 5 desc: Direction control pin polarity. This bit reverses the polarity of the direction control signal on the Un_OE pin.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 80 RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
    pub const RS485ADRMATCH = mmio(Address + 0x00000050, 32, packed struct {
        ADRMATCH: u8, // bit offset: 0 desc: Contains the address match value.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 84 RS-485/EIA-485 direction control delay.
    pub const RS485DLY = mmio(Address + 0x00000054, 32, packed struct {
        DLY: u8, // bit offset: 0 desc: Contains the direction control (UnOE) delay value. This register works in conjunction with an 8-bit counter.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const UART3 = extern struct {
    pub const Address: u32 = 0x4009c000;
    // byte offset: 0 Receiver Buffer Register. Contains the next received character to be read (DLAB =0).
    pub const RBR = mmio(Address + 0x00000000, 32, packed struct {
        RBR: u8, // bit offset: 0 desc: The UARTn Receiver Buffer Register contains the oldest received byte in the UARTn Rx FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 Transmit Holding Regiter. The next character to be transmitted is written here (DLAB =0).
    pub const THR = mmio(Address + 0x00000000, 32, packed struct {
        THR: u8, // bit offset: 0 desc: Writing to the UARTn Transmit Holding Register causes the data to be stored in the UARTn transmit FIFO. The byte will be sent when it reaches the bottom of the FIFO and the transmitter is available.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 0 Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
    pub const DLL = mmio(Address + 0x00000000, 32, packed struct {
        DLLSB: u8, // bit offset: 0 desc: The UARTn Divisor Latch LSB Register, along with the UnDLM register, determines the baud rate of the UARTn.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider (DLAB =1).
    pub const DLM = mmio(Address + 0x00000004, 32, packed struct {
        DLMSB: u8, // bit offset: 0 desc: The UARTn Divisor Latch MSB Register, along with the U0DLL register, determines the baud rate of the UARTn.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts (DLAB =0).
    pub const IER = mmio(Address + 0x00000004, 32, packed struct {
        RBRIE: bool, // bit offset: 0 desc: RBR Interrupt Enable. Enables the Receive Data Available interrupt for UARTn. It also controls the Character Receive Time-out interrupt.
        THREIE: bool, // bit offset: 1 desc: THRE Interrupt Enable. Enables the THRE interrupt for UARTn. The status of this can be read from UnLSR[5].
        RXIE: bool, // bit offset: 2 desc: RX Line Status Interrupt Enable. Enables the UARTn RX line status interrupts. The status of this interrupt can be read from UnLSR[4:1].
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABEOINTEN: bool, // bit offset: 8 desc: Enables the end of auto-baud interrupt.
        ABTOINTEN: bool, // bit offset: 9 desc: Enables the auto-baud time-out interrupt.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Interrupt ID Register. Identifies which interrupt(s) are pending.
    pub const IIR = mmio(Address + 0x00000008, 32, packed struct {
        INTSTATUS: bool, // bit offset: 0 desc: Interrupt status. Note that UnIIR[0] is active low. The pending interrupt can be determined by evaluating UnIIR[3:1].
        INTID: u3, // bit offset: 1 desc: Interrupt identification. UnIER[3:1] identifies an interrupt corresponding to the UARTn Rx or TX FIFO. All other combinations of UnIER[3:1] not listed below are reserved (000,100,101,111).
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        FIFOENABLE: u2, // bit offset: 6 desc: Copies of UnFCR[0].
        ABEOINT: bool, // bit offset: 8 desc: End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled.
        ABTOINT: bool, // bit offset: 9 desc: Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 FIFO Control Register. Controls UART FIFO usage and modes.
    pub const FCR = mmio(Address + 0x00000008, 32, packed struct {
        FIFOEN: bool, // bit offset: 0 desc: FIFO Enable.
        RXFIFORES: bool, // bit offset: 1 desc: RX FIFO Reset.
        TXFIFORES: bool, // bit offset: 2 desc: TX FIFO Reset.
        DMAMODE: bool, // bit offset: 3 desc: DMA Mode Select. When the FIFO enable (bit 0 of this register) is set, this bit selects the DMA mode. See Section 18.6.6.1.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXTRIGLVL: u2, // bit offset: 6 desc: RX Trigger Level. These two bits determine how many receiver UARTn FIFO characters must be written before an interrupt or DMA request is activated.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Line Control Register. Contains controls for frame formatting and break generation.
    pub const LCR = mmio(Address + 0x0000000c, 32, packed struct {
        WLS: u2, // bit offset: 0 desc: Word Length Select.
        SBS: bool, // bit offset: 2 desc: Stop Bit Select
        PE: bool, // bit offset: 3 desc: Parity Enable.
        PS: u2, // bit offset: 4 desc: Parity Select
        BC: bool, // bit offset: 6 desc: Break Control
        DLAB: bool, // bit offset: 7 desc: Divisor Latch Access Bit
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Line Status Register. Contains flags for transmit and receive status, including line errors.
    pub const LSR = mmio(Address + 0x00000014, 32, packed struct {
        RDR: bool, // bit offset: 0 desc: Receiver Data Ready. UnLSR[0] is set when the UnRBR holds an unread character and is cleared when the UARTn RBR FIFO is empty.
        OE: bool, // bit offset: 1 desc: Overrun Error. The overrun error condition is set as soon as it occurs. An UnLSR read clears UnLSR[1]. UnLSR[1] is set when UARTn RSR has a new character assembled and the UARTn RBR FIFO is full. In this case, the UARTn RBR FIFO will not be overwritten and the character in the UARTn RSR will be lost.
        PE: bool, // bit offset: 2 desc: Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. An UnLSR read clears UnLSR[2]. Time of parity error detection is dependent on UnFCR[0]. Note: A parity error is associated with the character at the top of the UARTn RBR FIFO.
        FE: bool, // bit offset: 3 desc: Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. An UnLSR read clears UnLSR[3]. The time of the framing error detection is dependent on UnFCR[0]. Upon detection of a framing error, the Rx will attempt to resynchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UARTn RBR FIFO.
        BI: bool, // bit offset: 4 desc: Break Interrupt. When RXDn is held in the spacing state (all zeroes) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXDn goes to marking state (all ones). An UnLSR read clears this status bit. The time of break detection is dependent on UnFCR[0]. Note: The break interrupt is associated with the character at the top of the UARTn RBR FIFO.
        THRE: bool, // bit offset: 5 desc: Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UARTn THR and is cleared on a UnTHR write.
        TEMT: bool, // bit offset: 6 desc: Transmitter Empty. TEMT is set when both UnTHR and UnTSR are empty; TEMT is cleared when either the UnTSR or the UnTHR contain valid data.
        RXFE: bool, // bit offset: 7 desc: Error in RX FIFO . UnLSR[7] is set when a character with a Rx error such as framing error, parity error or break interrupt, is loaded into the UnRBR. This bit is cleared when the UnLSR register is read and there are no subsequent errors in the UARTn FIFO.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Scratch Pad Register. 8-bit temporary storage for software.
    pub const SCR = mmio(Address + 0x0000001c, 32, packed struct {
        PAD: u8, // bit offset: 0 desc: A readable, writable byte.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 Auto-baud Control Register. Contains controls for the auto-baud feature.
    pub const ACR = mmio(Address + 0x00000020, 32, packed struct {
        START: bool, // bit offset: 0 desc: Start bit. This bit is automatically cleared after auto-baud completion.
        MODE: bool, // bit offset: 1 desc: Auto-baud mode select bit.
        AUTORESTART: bool, // bit offset: 2 desc: Restart bit.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        ABEOINTCLR: bool, // bit offset: 8 desc: End of auto-baud interrupt clear bit (write-only accessible). Writing a 1 will clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
        ABTOINTCLR: bool, // bit offset: 9 desc: Auto-baud time-out interrupt clear bit (write-only accessible). Writing a 1 will clear the corresponding interrupt in the UnIIR. Writing a 0 has no impact.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 Fractional Divider Register. Generates a clock input for the baud rate divider.
    pub const FDR = mmio(Address + 0x00000028, 32, packed struct {
        DIVADDVAL: u4, // bit offset: 0 desc: Baud-rate generation pre-scaler divisor value. If this field is 0, fractional baud-rate generator will not impact the UARTn baudrate.
        MULVAL: u4, // bit offset: 4 desc: Baud-rate pre-scaler multiplier value. This field must be greater or equal 1 for UARTn to operate properly, regardless of whether the fractional baud-rate generator is used or not.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 Transmit Enable Register. Turns off UART transmitter for use with software flow control.
    pub const TER = mmio(Address + 0x00000030, 32, packed struct {
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TXEN: bool, // bit offset: 7 desc: When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit is cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software implementing software-handshaking can clear this bit when it receives an XOFF character (DC3). Software can set this bit again when it receives an XON (DC1) character.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 76 RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
    pub const RS485CTRL = mmio(Address + 0x0000004c, 32, packed struct {
        NMMEN: bool, // bit offset: 0 desc: NMM enable.
        RXDIS: bool, // bit offset: 1 desc: Receiver enable.
        AADEN: bool, // bit offset: 2 desc: AAD enable.
        reserved1: u1 = 0,
        DCTRL: bool, // bit offset: 4 desc: Direction control enable.
        OINV: bool, // bit offset: 5 desc: Direction control pin polarity. This bit reverses the polarity of the direction control signal on the Un_OE pin.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 80 RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
    pub const RS485ADRMATCH = mmio(Address + 0x00000050, 32, packed struct {
        ADRMATCH: u8, // bit offset: 0 desc: Contains the address match value.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 84 RS-485/EIA-485 direction control delay.
    pub const RS485DLY = mmio(Address + 0x00000054, 32, packed struct {
        DLY: u8, // bit offset: 0 desc: Contains the direction control (UnOE) delay value. This register works in conjunction with an 8-bit counter.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const I2C2 = extern struct {
    pub const Address: u32 = 0x400a0000;
    // byte offset: 0 I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
    pub const CONSET = mmio(Address + 0x00000000, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        AA: bool, // bit offset: 2 desc: Assert acknowledge flag.
        SI: bool, // bit offset: 3 desc: I2C interrupt flag.
        STO: bool, // bit offset: 4 desc: STOP flag.
        STA: bool, // bit offset: 5 desc: START flag.
        I2EN: bool, // bit offset: 6 desc: I2C interface enable.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
    pub const STAT = mmio(Address + 0x00000004, 32, packed struct {
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        Status: u5, // bit offset: 3 desc: These bits give the actual status information about the I 2C interface.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
    pub const DAT = mmio(Address + 0x00000008, 32, packed struct {
        Data: u8, // bit offset: 0 desc: This register holds data values that have been received or are to be transmitted.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR0 = mmio(Address + 0x0000000c, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
    pub const SCLH = mmio(Address + 0x00000010, 32, packed struct {
        SCLH: u16, // bit offset: 0 desc: Count for SCL HIGH time period selection.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
    pub const SCLL = mmio(Address + 0x00000014, 32, packed struct {
        SCLL: u16, // bit offset: 0 desc: Count for SCL low time period selection.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
    pub const CONCLR = mmio(Address + 0x00000018, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        AAC: bool, // bit offset: 2 desc: Assert acknowledge Clear bit.
        SIC: bool, // bit offset: 3 desc: I2C interrupt Clear bit.
        reserved2: u1 = 0,
        STAC: bool, // bit offset: 5 desc: START flag Clear bit.
        I2ENC: bool, // bit offset: 6 desc: I2C interface Disable bit.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Monitor mode control register.
    pub const MMCTRL = mmio(Address + 0x0000001c, 32, packed struct {
        MM_ENA: bool, // bit offset: 0 desc: Monitor mode enable.
        ENA_SCL: bool, // bit offset: 1 desc: SCL output enable.
        MATCH_ALL: bool, // bit offset: 2 desc: Select interrupt register match.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR1 = mmio(Address + 0x00000020, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 32 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR1 = mmio(Address + 0x00000020, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 36 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR2 = mmio(Address + 0x00000024, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 36 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR2 = mmio(Address + 0x00000024, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 40 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR3 = mmio(Address + 0x00000028, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 40 I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    pub const ADR3 = mmio(Address + 0x00000028, 32, packed struct {
        GC: bool, // bit offset: 0 desc: General Call enable bit.
        Address: u7, // bit offset: 1 desc: The I2C device address for slave mode.
    });
    // byte offset: 44 Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
    pub const DATA_BUFFER = mmio(Address + 0x0000002c, 32, packed struct {
        Data: u8, // bit offset: 0 desc: This register holds contents of the 8 MSBs of the DAT shift register.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 I2C Slave address mask register
    pub const MASK_0 = mmio(Address + 0x00000030, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 48 I2C Slave address mask register
    pub const MASK_0 = mmio(Address + 0x00000030, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 52 I2C Slave address mask register
    pub const MASK_1 = mmio(Address + 0x00000034, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 52 I2C Slave address mask register
    pub const MASK_1 = mmio(Address + 0x00000034, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 56 I2C Slave address mask register
    pub const MASK_2 = mmio(Address + 0x00000038, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 56 I2C Slave address mask register
    pub const MASK_2 = mmio(Address + 0x00000038, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 60 I2C Slave address mask register
    pub const MASK_3 = mmio(Address + 0x0000003c, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
    // byte offset: 60 I2C Slave address mask register
    pub const MASK_3 = mmio(Address + 0x0000003c, 32, packed struct {
        reserved1: u1 = 0,
        MASK: u7, // bit offset: 1 desc: Mask bits.
    });
};
pub const I2S = extern struct {
    pub const Address: u32 = 0x400a8000;
    // byte offset: 0 I2S Digital Audio Output Register. Contains control bits for the I2S transmit channel.
    pub const DAO = mmio(Address + 0x00000000, 32, packed struct {
        WORDWIDTH: u2, // bit offset: 0 desc: Selects the number of bytes in data as follows:
        MONO: bool, // bit offset: 2 desc: When 1, data is of monaural format. When 0, the data is in stereo format.
        STOP: bool, // bit offset: 3 desc: When 1, disables accesses on FIFOs, places the transmit channel in mute mode.
        RESET: bool, // bit offset: 4 desc: When 1, asynchronously resets the transmit channel and FIFO.
        WS_SEL: bool, // bit offset: 5 desc: When 0, the interface is in master mode. When 1, the interface is in slave mode. See Section 34.7.2 for a summary of useful combinations for this bit with TXMODE.
        WS_HALFPERIOD: u9, // bit offset: 6 desc: Word select half period minus 1, i.e. WS 64clk period -> ws_halfperiod = 31.
        MUTE: bool, // bit offset: 15 desc: When 1, the transmit channel sends only zeroes.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 I2S Digital Audio Input Register. Contains control bits for the I2S receive channel.
    pub const DAI = mmio(Address + 0x00000004, 32, packed struct {
        WORDWIDTH: u2, // bit offset: 0 desc: Selects the number of bytes in data as follows:
        MONO: bool, // bit offset: 2 desc: When 1, data is of monaural format. When 0, the data is in stereo format.
        STOP: bool, // bit offset: 3 desc: When 1, disables accesses on FIFOs, places the transmit channel in mute mode.
        RESET: bool, // bit offset: 4 desc: When 1, asynchronously reset the transmit channel and FIFO.
        WS_SEL: bool, // bit offset: 5 desc: When 0, the interface is in master mode. When 1, the interface is in slave mode. See Section 34.7.2 for a summary of useful combinations for this bit with RXMODE.
        WS_HALFPERIOD: u9, // bit offset: 6 desc: Word select half period minus 1, i.e. WS 64clk period -> ws_halfperiod = 31.
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 I2S Transmit FIFO. Access register for the 8 x 32-bit transmitter FIFO.
    pub const TXFIFO = mmio(Address + 0x00000008, 32, packed struct {
        I2STXFIFO: u32, // bit offset: 0 desc: 8 x 32-bit transmit FIFO.
    });
    // byte offset: 12 I2S Receive FIFO. Access register for the 8 x 32-bit receiver FIFO.
    pub const RXFIFO = mmio(Address + 0x0000000c, 32, packed struct {
        I2SRXFIFO: u32, // bit offset: 0 desc: 8 x 32-bit transmit FIFO.
    });
    // byte offset: 16 I2S Status Feedback Register. Contains status information about the I2S interface.
    pub const STATE = mmio(Address + 0x00000010, 32, packed struct {
        IRQ: bool, // bit offset: 0 desc: This bit reflects the presence of Receive Interrupt or Transmit Interrupt. This is determined by comparing the current FIFO levels to the rx_depth_irq and tx_depth_irq fields in the IRQ register.
        DMAREQ1: bool, // bit offset: 1 desc: This bit reflects the presence of Receive or Transmit DMA Request 1. This is determined by comparing the current FIFO levels to the rx_depth_dma1 and tx_depth_dma1 fields in the DMA1 register.
        DMAREQ2: bool, // bit offset: 2 desc: This bit reflects the presence of Receive or Transmit DMA Request 2. This is determined by comparing the current FIFO levels to the rx_depth_dma2 and tx_depth_dma2 fields in the DMA2 register.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RX_LEVEL: u4, // bit offset: 8 desc: Reflects the current level of the Receive FIFO.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        TX_LEVEL: u4, // bit offset: 16 desc: Reflects the current level of the Transmit FIFO.
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 I2S DMA Configuration Register 1. Contains control information for DMA request 1.
    pub const DMA1 = mmio(Address + 0x00000014, 32, packed struct {
        RX_DMA1_ENABLE: bool, // bit offset: 0 desc: When 1, enables DMA1 for I2S receive.
        TX_DMA1_ENABLE: bool, // bit offset: 1 desc: When 1, enables DMA1 for I2S transmit.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RX_DEPTH_DMA1: u4, // bit offset: 8 desc: Set the FIFO level that triggers a receive DMA request on DMA1.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        TX_DEPTH_DMA1: u4, // bit offset: 16 desc: Set the FIFO level that triggers a transmit DMA request on DMA1.
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 I2S DMA Configuration Register 2. Contains control information for DMA request 2.
    pub const DMA2 = mmio(Address + 0x00000018, 32, packed struct {
        RX_DMA2_ENABLE: bool, // bit offset: 0 desc: When 1, enables DMA1 for I2S receive.
        TX_DMA2_ENABLE: bool, // bit offset: 1 desc: When 1, enables DMA1 for I2S transmit.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RX_DEPTH_DMA2: u4, // bit offset: 8 desc: Set the FIFO level that triggers a receive DMA request on DMA2.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        TX_DEPTH_DMA2: u4, // bit offset: 16 desc: Set the FIFO level that triggers a transmit DMA request on DMA2.
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 I2S Interrupt Request Control Register. Contains bits that control how the I2S interrupt request is generated.
    pub const IRQ = mmio(Address + 0x0000001c, 32, packed struct {
        RX_IRQ_ENABLE: bool, // bit offset: 0 desc: When 1, enables I2S receive interrupt.
        TX_IRQ_ENABLE: bool, // bit offset: 1 desc: When 1, enables I2S transmit interrupt.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RX_DEPTH_IRQ: u4, // bit offset: 8 desc: Set the FIFO level on which to create an irq request.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        TX_DEPTH_IRQ: u4, // bit offset: 16 desc: Set the FIFO level on which to create an irq request.
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 I2S Transmit MCLK divider. This register determines the I2S TX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
    pub const TXRATE = mmio(Address + 0x00000020, 32, packed struct {
        Y_DIVIDER: u8, // bit offset: 0 desc: I2S transmit MCLK rate denominator. This value is used to divide PCLK to produce the transmit MCLK. Eight bits of fractional divide supports a wide range of possibilities. A value of 0 stops the clock.
        X_DIVIDER: u8, // bit offset: 8 desc: I2S transmit MCLK rate numerator. This value is used to multiply PCLK by to produce the transmit MCLK. A value of 0 stops the clock. Eight bits of fractional divide supports a wide range of possibilities. Note: the resulting ratio X/Y is divided by 2.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 I2S Receive MCLK divider. This register determines the I2S RX MCLK rate by specifying the value to divide PCLK by in order to produce MCLK.
    pub const RXRATE = mmio(Address + 0x00000024, 32, packed struct {
        Y_DIVIDER: u8, // bit offset: 0 desc: I2S receive MCLK rate denominator. This value is used to divide PCLK to produce the receive MCLK. Eight bits of fractional divide supports a wide range of possibilities. A value of 0 stops the clock.
        X_DIVIDER: u8, // bit offset: 8 desc: I2S receive MCLK rate numerator. This value is used to multiply PCLK by to produce the receive MCLK. A value of 0 stops the clock. Eight bits of fractional divide supports a wide range of possibilities. Note: the resulting ratio X/Y is divided by 2.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 I2S Transmit bit rate divider. This register determines the I2S transmit bit rate by specifying the value to divide TX_MCLK by in order to produce the transmit bit clock.
    pub const TXBITRATE = mmio(Address + 0x00000028, 32, packed struct {
        TX_BITRATE: u6, // bit offset: 0 desc: I2S transmit bit rate. This value plus one is used to divide TX_MCLK to produce the transmit bit clock.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 I2S Receive bit rate divider. This register determines the I2S receive bit rate by specifying the value to divide RX_MCLK by in order to produce the receive bit clock.
    pub const RXBITRATE = mmio(Address + 0x0000002c, 32, packed struct {
        RX_BITRATE: u6, // bit offset: 0 desc: I2S receive bit rate. This value plus one is used to divide RX_MCLK to produce the receive bit clock.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 I2S Transmit mode control.
    pub const TXMODE = mmio(Address + 0x00000030, 32, packed struct {
        TXCLKSEL: u2, // bit offset: 0 desc: Clock source selection for the transmit bit clock divider.
        TX4PIN: bool, // bit offset: 2 desc: Transmit 4-pin mode selection. When 1, enables 4-pin mode.
        TXMCENA: bool, // bit offset: 3 desc: Enable for the TX_MCLK output. When 0, output of TX_MCLK is not enabled. When 1, output of TX_MCLK is enabled.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 52 I2S Receive mode control.
    pub const RXMODE = mmio(Address + 0x00000034, 32, packed struct {
        RXCLKSEL: u2, // bit offset: 0 desc: Clock source selection for the receive bit clock divider.
        RX4PIN: bool, // bit offset: 2 desc: Receive 4-pin mode selection. When 1, enables 4-pin mode.
        RXMCENA: bool, // bit offset: 3 desc: Enable for the RX_MCLK output. When 0, output of RX_MCLK is not enabled. When 1, output of RX_MCLK is enabled.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const RITIMER = extern struct {
    pub const Address: u32 = 0x400b0000;
    // byte offset: 0 Compare register
    pub const COMPVAL = mmio(Address + 0x00000000, 32, packed struct {
        RICOMP: u32, // bit offset: 0 desc: Compare register. Holds the compare value which is compared to the counter.
    });
    // byte offset: 4 Mask register. This register holds the 32-bit mask value. A 1 written to any bit will force a compare on the corresponding bit of the counter and compare register.
    pub const MASK = mmio(Address + 0x00000004, 32, packed struct {
        RIMASK: u32, // bit offset: 0 desc: Mask register. This register holds the 32-bit mask value. A one written to any bit overrides the result of the comparison for the corresponding bit of the counter and compare register (causes the comparison of the register bits to be always true).
    });
    // byte offset: 8 Control register.
    pub const CTRL = mmio(Address + 0x00000008, 32, packed struct {
        RITINT: bool, // bit offset: 0 desc: Interrupt flag
        RITENCLR: bool, // bit offset: 1 desc: Timer enable clear
        RITENBR: bool, // bit offset: 2 desc: Timer enable for debug
        RITEN: bool, // bit offset: 3 desc: Timer enable.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 32-bit counter
    pub const COUNTER = mmio(Address + 0x0000000c, 32, packed struct {
        RICOUNTER: u32, // bit offset: 0 desc: 32-bit up counter. Counts continuously unless RITEN bit in RICTRL register is cleared or debug mode is entered (if enabled by the RITNEBR bit in RICTRL). Can be loaded to any value in software.
    });
};
pub const MCPWM = extern struct {
    pub const Address: u32 = 0x400b8000;
    // byte offset: 0 PWM Control read address
    pub const CON = mmio(Address + 0x00000000, 32, packed struct {
        RUN0: bool, // bit offset: 0 desc: Stops/starts timer channel 0.
        CENTER0: bool, // bit offset: 1 desc: Edge/center aligned operation for channel 0.
        POLA0: bool, // bit offset: 2 desc: Selects polarity of the MCOA0 and MCOB0 pins.
        DTE0: bool, // bit offset: 3 desc: Controls the dead-time feature for channel 0.
        DISUP0: bool, // bit offset: 4 desc: Enable/disable updates of functional registers for channel 0 (see Section 24.8.2).
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RUN1: bool, // bit offset: 8 desc: Stops/starts timer channel 1.
        CENTER1: bool, // bit offset: 9 desc: Edge/center aligned operation for channel 1.
        POLA1: bool, // bit offset: 10 desc: Selects polarity of the MCOA1 and MCOB1 pins.
        DTE1: bool, // bit offset: 11 desc: Controls the dead-time feature for channel 1.
        DISUP1: bool, // bit offset: 12 desc: Enable/disable updates of functional registers for channel 1 (see Section 24.8.2).
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RUN2: bool, // bit offset: 16 desc: Stops/starts timer channel 2.
        CENTER2: bool, // bit offset: 17 desc: Edge/center aligned operation for channel 2.
        POLA2: bool, // bit offset: 18 desc: Selects polarity of the MCOA2 and MCOB2 pins.
        DTE2: bool, // bit offset: 19 desc: Controls the dead-time feature for channel 1.
        DISUP2: bool, // bit offset: 20 desc: Enable/disable updates of functional registers for channel 2 (see Section 24.8.2).
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        INVBDC: bool, // bit offset: 29 desc: Controls the polarity of the MCOB outputs for all 3 channels. This bit is typically set to 1 only in 3-phase DC mode.
        ACMODE: bool, // bit offset: 30 desc: 3-phase AC mode select (see Section 24.8.7).
        DCMODE: bool, // bit offset: 31 desc: 3-phase DC mode select (see Section 24.8.6).
    });
    // byte offset: 4 PWM Control set address
    pub const CON_SET = mmio(Address + 0x00000004, 32, packed struct {
        RUN0_SET: bool, // bit offset: 0 desc: Writing a one sets the corresponding bit in the CON register.
        CENTER0_SET: bool, // bit offset: 1 desc: Writing a one sets the corresponding bit in the CON register.
        POLA0_SET: bool, // bit offset: 2 desc: Writing a one sets the corresponding bit in the CON register.
        DTE0_SET: bool, // bit offset: 3 desc: Writing a one sets the corresponding bit in the CON register.
        DISUP0_SET: bool, // bit offset: 4 desc: Writing a one sets the corresponding bit in the CON register.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RUN1_SET: bool, // bit offset: 8 desc: Writing a one sets the corresponding bit in the CON register.
        CENTER1_SET: bool, // bit offset: 9 desc: Writing a one sets the corresponding bit in the CON register.
        POLA1_SET: bool, // bit offset: 10 desc: Writing a one sets the corresponding bit in the CON register.
        DTE1_SET: bool, // bit offset: 11 desc: Writing a one sets the corresponding bit in the CON register.
        DISUP1_SET: bool, // bit offset: 12 desc: Writing a one sets the corresponding bit in the CON register.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RUN2_SET: bool, // bit offset: 16 desc: Writing a one sets the corresponding bit in the CON register.
        CENTER2_SET: bool, // bit offset: 17 desc: Writing a one sets the corresponding bit in the CON register.
        POLA2_SET: bool, // bit offset: 18 desc: Writing a one sets the corresponding bit in the CON register.
        DTE2_SET: bool, // bit offset: 19 desc: Writing a one sets the corresponding bit in the CON register.
        DISUP2_SET: bool, // bit offset: 20 desc: Writing a one sets the corresponding bit in the CON register.
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        INVBDC_SET: bool, // bit offset: 29 desc: Writing a one sets the corresponding bit in the CON register.
        ACMODE_SET: bool, // bit offset: 30 desc: Writing a one sets the corresponding bit in the CON register.
        DCMODE_SET: bool, // bit offset: 31 desc: Writing a one sets the corresponding bit in the CON register.
    });
    // byte offset: 8 PWM Control clear address
    pub const CON_CLR = mmio(Address + 0x00000008, 32, packed struct {
        RUN0_CLR: bool, // bit offset: 0 desc: Writing a one clears the corresponding bit in the CON register.
        CENTER0_CLR: bool, // bit offset: 1 desc: Writing a one clears the corresponding bit in the CON register.
        POLA0_CLR: bool, // bit offset: 2 desc: Writing a one clears the corresponding bit in the CON register.
        DTE0_CLR: bool, // bit offset: 3 desc: Writing a one clears the corresponding bit in the CON register.
        DISUP0_CLR: bool, // bit offset: 4 desc: Writing a one clears the corresponding bit in the CON register.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RUN1_CLR: bool, // bit offset: 8 desc: Writing a one clears the corresponding bit in the CON register.
        CENTER1_CLR: bool, // bit offset: 9 desc: Writing a one clears the corresponding bit in the CON register.
        POLA1_CLR: bool, // bit offset: 10 desc: Writing a one clears the corresponding bit in the CON register.
        DTE1_CLR: bool, // bit offset: 11 desc: Writing a one clears the corresponding bit in the CON register.
        DISUP1_CLR: bool, // bit offset: 12 desc: Writing a one clears the corresponding bit in the CON register.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        RUN2_CLR: bool, // bit offset: 16 desc: Writing a one clears the corresponding bit in the CON register.
        CENTER2_CLR: bool, // bit offset: 17 desc: Writing a one clears the corresponding bit in the CON register.
        POLA2_CLR: bool, // bit offset: 18 desc: Writing a one clears the corresponding bit in the CON register.
        DTE2_CLR: bool, // bit offset: 19 desc: Writing a one clears the corresponding bit in the CON register.
        DISUP2_CLR: bool, // bit offset: 20 desc: Writing a one clears the corresponding bit in the CON register.
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        INVBDC_CLR: bool, // bit offset: 29 desc: Writing a one clears the corresponding bit in the CON register.
        ACMOD_CLR: bool, // bit offset: 30 desc: Writing a one clears the corresponding bit in the CON register.
        DCMODE_CLR: bool, // bit offset: 31 desc: Writing a one clears the corresponding bit in the CON register.
    });
    // byte offset: 12 Capture Control read address
    pub const CAPCON = mmio(Address + 0x0000000c, 32, packed struct {
        CAP0MCI0_RE: bool, // bit offset: 0 desc: A 1 in this bit enables a channel 0 capture event on a rising edge on MCI0.
        CAP0MCI0_FE: bool, // bit offset: 1 desc: A 1 in this bit enables a channel 0 capture event on a falling edge on MCI0.
        CAP0MCI1_RE: bool, // bit offset: 2 desc: A 1 in this bit enables a channel 0 capture event on a rising edge on MCI1.
        CAP0MCI1_FE: bool, // bit offset: 3 desc: A 1 in this bit enables a channel 0 capture event on a falling edge on MCI1.
        CAP0MCI2_RE: bool, // bit offset: 4 desc: A 1 in this bit enables a channel 0 capture event on a rising edge on MCI2.
        CAP0MCI2_FE: bool, // bit offset: 5 desc: A 1 in this bit enables a channel 0 capture event on a falling edge on MCI2.
        CAP1MCI0_RE: bool, // bit offset: 6 desc: A 1 in this bit enables a channel 1 capture event on a rising edge on MCI0.
        CAP1MCI0_FE: bool, // bit offset: 7 desc: A 1 in this bit enables a channel 1 capture event on a falling edge on MCI0.
        CAP1MCI1_RE: bool, // bit offset: 8 desc: A 1 in this bit enables a channel 1 capture event on a rising edge on MCI1.
        CAP1MCI1_FE: bool, // bit offset: 9 desc: A 1 in this bit enables a channel 1 capture event on a falling edge on MCI1.
        CAP1MCI2_RE: bool, // bit offset: 10 desc: A 1 in this bit enables a channel 1 capture event on a rising edge on MCI2.
        CAP1MCI2_FE: bool, // bit offset: 11 desc: A 1 in this bit enables a channel 1 capture event on a falling edge on MCI2.
        CAP2MCI0_RE: bool, // bit offset: 12 desc: A 1 in this bit enables a channel 2 capture event on a rising edge on MCI0.
        CAP2MCI0_FE: bool, // bit offset: 13 desc: A 1 in this bit enables a channel 2 capture event on a falling edge on MCI0.
        CAP2MCI1_RE: bool, // bit offset: 14 desc: A 1 in this bit enables a channel 2 capture event on a rising edge on MCI1.
        CAP2MCI1_FE: bool, // bit offset: 15 desc: A 1 in this bit enables a channel 2 capture event on a falling edge on MCI1.
        CAP2MCI2_RE: bool, // bit offset: 16 desc: A 1 in this bit enables a channel 2 capture event on a rising edge on MCI2.
        CAP2MCI2_FE: bool, // bit offset: 17 desc: A 1 in this bit enables a channel 2 capture event on a falling edge on MCI2.
        RT0: bool, // bit offset: 18 desc: If this bit is 1, TC0 is reset by a channel 0 capture event.
        RT1: bool, // bit offset: 19 desc: If this bit is 1, TC1 is reset by a channel 1 capture event.
        RT2: bool, // bit offset: 20 desc: If this bit is 1, TC2 is reset by a channel 2 capture event.
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 Capture Control set address
    pub const CAPCON_SET = mmio(Address + 0x00000010, 32, packed struct {
        CAP0MCI0_RE_SET: bool, // bit offset: 0 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP0MCI0_FE_SET: bool, // bit offset: 1 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP0MCI1_RE_SET: bool, // bit offset: 2 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP0MCI1_FE_SET: bool, // bit offset: 3 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP0MCI2_RE_SET: bool, // bit offset: 4 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP0MCI2_FE_SET: bool, // bit offset: 5 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP1MCI0_RE_SET: bool, // bit offset: 6 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP1MCI0_FE_SET: bool, // bit offset: 7 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP1MCI1_RE_SET: bool, // bit offset: 8 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP1MCI1_FE_SET: bool, // bit offset: 9 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP1MCI2_RE_SET: bool, // bit offset: 10 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP1MCI2_FE_SET: bool, // bit offset: 11 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP2MCI0_RE_SET: bool, // bit offset: 12 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP2MCI0_FE_SET: bool, // bit offset: 13 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP2MCI1_RE_SET: bool, // bit offset: 14 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP2MCI1_FE_SET: bool, // bit offset: 15 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP2MCI2_RE_SET: bool, // bit offset: 16 desc: Writing a one sets the corresponding bits in the CAPCON register.
        CAP2MCI2_FE_SET: bool, // bit offset: 17 desc: Writing a one sets the corresponding bits in the CAPCON register.
        RT0_SET: bool, // bit offset: 18 desc: Writing a one sets the corresponding bits in the CAPCON register.
        RT1_SET: bool, // bit offset: 19 desc: Writing a one sets the corresponding bits in the CAPCON register.
        RT2_SET: bool, // bit offset: 20 desc: Writing a one sets the corresponding bits in the CAPCON register.
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Event Control clear address
    pub const CAPCON_CLR = mmio(Address + 0x00000014, 32, packed struct {
        CAP0MCI0_RE_CLR: bool, // bit offset: 0 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP0MCI0_FE_CLR: bool, // bit offset: 1 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP0MCI1_RE_CLR: bool, // bit offset: 2 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP0MCI1_FE_CLR: bool, // bit offset: 3 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP0MCI2_RE_CLR: bool, // bit offset: 4 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP0MCI2_FE_CLR: bool, // bit offset: 5 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP1MCI0_RE_CLR: bool, // bit offset: 6 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP1MCI0_FE_CLR: bool, // bit offset: 7 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP1MCI1_RE_CLR: bool, // bit offset: 8 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP1MCI1_FE_CLR: bool, // bit offset: 9 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP1MCI2_RE_CLR: bool, // bit offset: 10 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP1MCI2_FE_CLR: bool, // bit offset: 11 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP2MCI0_RE_CLR: bool, // bit offset: 12 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP2MCI0_FE_CLR: bool, // bit offset: 13 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP2MCI1_RE_CLR: bool, // bit offset: 14 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP2MCI1_FE_CLR: bool, // bit offset: 15 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP2MCI2_RE_CLR: bool, // bit offset: 16 desc: Writing a one clears the corresponding bits in the CAPCON register.
        CAP2MCI2_FE_CLR: bool, // bit offset: 17 desc: Writing a one clears the corresponding bits in the CAPCON register.
        RT0_CLR: bool, // bit offset: 18 desc: Writing a one clears the corresponding bits in the CAPCON register.
        RT1_CLR: bool, // bit offset: 19 desc: Writing a one clears the corresponding bits in the CAPCON register.
        RT2_CLR: bool, // bit offset: 20 desc: Writing a one clears the corresponding bits in the CAPCON register.
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 Timer Counter register
    pub const TC_0 = mmio(Address + 0x00000018, 32, packed struct {
        MCTC: u32, // bit offset: 0 desc: Timer/Counter value.
    });
    // byte offset: 28 Timer Counter register
    pub const TC_1 = mmio(Address + 0x0000001c, 32, packed struct {
        MCTC: u32, // bit offset: 0 desc: Timer/Counter value.
    });
    // byte offset: 32 Timer Counter register
    pub const TC_2 = mmio(Address + 0x00000020, 32, packed struct {
        MCTC: u32, // bit offset: 0 desc: Timer/Counter value.
    });
    // byte offset: 36 Limit register
    pub const LIM_0 = mmio(Address + 0x00000024, 32, packed struct {
        MCLIM: u32, // bit offset: 0 desc: Limit value.
    });
    // byte offset: 40 Limit register
    pub const LIM_1 = mmio(Address + 0x00000028, 32, packed struct {
        MCLIM: u32, // bit offset: 0 desc: Limit value.
    });
    // byte offset: 44 Limit register
    pub const LIM_2 = mmio(Address + 0x0000002c, 32, packed struct {
        MCLIM: u32, // bit offset: 0 desc: Limit value.
    });
    // byte offset: 48 Match register
    pub const MAT_0 = mmio(Address + 0x00000030, 32, packed struct {
        MCMAT: u32, // bit offset: 0 desc: Match value.
    });
    // byte offset: 52 Match register
    pub const MAT_1 = mmio(Address + 0x00000034, 32, packed struct {
        MCMAT: u32, // bit offset: 0 desc: Match value.
    });
    // byte offset: 56 Match register
    pub const MAT_2 = mmio(Address + 0x00000038, 32, packed struct {
        MCMAT: u32, // bit offset: 0 desc: Match value.
    });
    // byte offset: 60 Dead time register
    pub const DT = mmio(Address + 0x0000003c, 32, packed struct {
        DT0: u10, // bit offset: 0 desc: Dead time for channel 0.[1]
        DT1: u10, // bit offset: 10 desc: Dead time for channel 1.[2]
        DT2: u10, // bit offset: 20 desc: Dead time for channel 2.[2]
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 64 Communication Pattern register
    pub const CP = mmio(Address + 0x00000040, 32, packed struct {
        CCPA0: bool, // bit offset: 0 desc: Communication pattern output A, channel 0.
        CCPB0: bool, // bit offset: 1 desc: Communication pattern output B, channel 0.
        CCPA1: bool, // bit offset: 2 desc: Communication pattern output A, channel 1.
        CCPB1: bool, // bit offset: 3 desc: Communication pattern output B, channel 1.
        CCPA2: bool, // bit offset: 4 desc: Communication pattern output A, channel 2.
        CCPB2: bool, // bit offset: 5 desc: Communication pattern output B, channel 2.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 68 Capture register
    pub const CAP_0 = mmio(Address + 0x00000044, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Current TC value at a capture event.
    });
    // byte offset: 72 Capture register
    pub const CAP_1 = mmio(Address + 0x00000048, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Current TC value at a capture event.
    });
    // byte offset: 76 Capture register
    pub const CAP_2 = mmio(Address + 0x0000004c, 32, packed struct {
        CAP: u32, // bit offset: 0 desc: Current TC value at a capture event.
    });
    // byte offset: 80 Interrupt Enable read address
    pub const INTEN = mmio(Address + 0x00000050, 32, packed struct {
        ILIM0: bool, // bit offset: 0 desc: Limit interrupt for channel 0.
        IMAT0: bool, // bit offset: 1 desc: Match interrupt for channel 0.
        ICAP0: bool, // bit offset: 2 desc: Capture interrupt for channel 0.
        reserved1: u1 = 0,
        ILIM1: bool, // bit offset: 4 desc: Limit interrupt for channel 1.
        IMAT1: bool, // bit offset: 5 desc: Match interrupt for channel 1.
        ICAP1: bool, // bit offset: 6 desc: Capture interrupt for channel 1.
        reserved2: u1 = 0,
        ILIM2: bool, // bit offset: 8 desc: Limit interrupt for channel 2.
        IMAT2: bool, // bit offset: 9 desc: Match interrupt for channel 2.
        ICAP2: bool, // bit offset: 10 desc: Capture interrupt for channel 2.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        ABORT: bool, // bit offset: 15 desc: Fast abort interrupt.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 84 Interrupt Enable set address
    pub const INTEN_SET = mmio(Address + 0x00000054, 32, packed struct {
        ILIM0_SET: bool, // bit offset: 0 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        IMAT0_SET: bool, // bit offset: 1 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        ICAP0_SET: bool, // bit offset: 2 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        reserved1: u1 = 0,
        ILIM1_SET: bool, // bit offset: 4 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        IMAT1_SET: bool, // bit offset: 5 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        ICAP1_SET: bool, // bit offset: 6 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        ILIM2_SET: bool, // bit offset: 9 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        IMAT2_SET: bool, // bit offset: 10 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        ICAP2_SET: bool, // bit offset: 11 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        ABORT_SET: bool, // bit offset: 15 desc: Writing a one sets the corresponding bit in INTEN, thus enabling the interrupt.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 88 Interrupt Enable clear address
    pub const INTEN_CLR = mmio(Address + 0x00000058, 32, packed struct {
        ILIM0_CLR: bool, // bit offset: 0 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        IMAT0_CLR: bool, // bit offset: 1 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        ICAP0_CLR: bool, // bit offset: 2 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        reserved1: u1 = 0,
        ILIM1_CLR: bool, // bit offset: 4 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        IMAT1_CLR: bool, // bit offset: 5 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        ICAP1_CLR: bool, // bit offset: 6 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        reserved2: u1 = 0,
        ILIM2_CLR: bool, // bit offset: 8 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        IMAT2_CLR: bool, // bit offset: 9 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        ICAP2_CLR: bool, // bit offset: 10 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        ABORT_CLR: bool, // bit offset: 15 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 92 Count Control read address
    pub const CNTCON = mmio(Address + 0x0000005c, 32, packed struct {
        TC0MCI0_RE: bool, // bit offset: 0 desc: Counter 0 rising edge mode, channel 0.
        TC0MCI0_FE: bool, // bit offset: 1 desc: Counter 0 falling edge mode, channel 0.
        TC0MCI1_RE: bool, // bit offset: 2 desc: Counter 0 rising edge mode, channel 1.
        TC0MCI1_FE: bool, // bit offset: 3 desc: Counter 0 falling edge mode, channel 1.
        TC0MCI2_RE: bool, // bit offset: 4 desc: Counter 0 rising edge mode, channel 2.
        TC0MCI2_FE: bool, // bit offset: 5 desc: Counter 0 falling edge mode, channel 2.
        TC1MCI0_RE: bool, // bit offset: 6 desc: Counter 1 rising edge mode, channel 0.
        TC1MCI0_FE: bool, // bit offset: 7 desc: Counter 1 falling edge mode, channel 0.
        TC1MCI1_RE: bool, // bit offset: 8 desc: Counter 1 rising edge mode, channel 1.
        TC1MCI1_FE: bool, // bit offset: 9 desc: Counter 1 falling edge mode, channel 1.
        TC1MCI2_RE: bool, // bit offset: 10 desc: Counter 1 rising edge mode, channel 2.
        TC1MCI2_FE: bool, // bit offset: 11 desc: Counter 1 falling edge mode, channel 2.
        TC2MCI0_RE: bool, // bit offset: 12 desc: Counter 2 rising edge mode, channel 0.
        TC2MCI0_FE: bool, // bit offset: 13 desc: Counter 2 falling edge mode, channel 0.
        TC2MCI1_RE: bool, // bit offset: 14 desc: Counter 2 rising edge mode, channel 1.
        TC2MCI1_FE: bool, // bit offset: 15 desc: Counter 2 falling edge mode, channel 1.
        TC2MCI2_RE: bool, // bit offset: 16 desc: Counter 2 rising edge mode, channel 2.
        TC2MCI2_FE: bool, // bit offset: 17 desc: Counter 2 falling edge mode, channel 2.
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        CNTR0: bool, // bit offset: 29 desc: Channel 0 counter/timer mode.
        CNTR1: bool, // bit offset: 30 desc: Channel 1 counter/timer mode.
        CNTR2: bool, // bit offset: 31 desc: Channel 2 counter/timer mode.
    });
    // byte offset: 96 Count Control set address
    pub const CNTCON_SET = mmio(Address + 0x00000060, 32, packed struct {
        TC0MCI0_RE_SET: bool, // bit offset: 0 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC0MCI0_FE_SET: bool, // bit offset: 1 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC0MCI1_RE_SET: bool, // bit offset: 2 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC0MCI1_FE_SET: bool, // bit offset: 3 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC0MCI2_RE_SET: bool, // bit offset: 4 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC0MCI2_FE_SET: bool, // bit offset: 5 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC1MCI0_RE_SET: bool, // bit offset: 6 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC1MCI0_FE_SET: bool, // bit offset: 7 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC1MCI1_RE_SET: bool, // bit offset: 8 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC1MCI1_FE_SET: bool, // bit offset: 9 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC1MCI2_RE_SET: bool, // bit offset: 10 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC1MCI2_FE_SET: bool, // bit offset: 11 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC2MCI0_RE_SET: bool, // bit offset: 12 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC2MCI0_FE_SET: bool, // bit offset: 13 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC2MCI1_RE_SET: bool, // bit offset: 14 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC2MCI1_FE_SET: bool, // bit offset: 15 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC2MCI2_RE_SET: bool, // bit offset: 16 desc: Writing a one sets the corresponding bit in the CNTCON register.
        TC2MCI2_FE_SET: bool, // bit offset: 17 desc: Writing a one sets the corresponding bit in the CNTCON register.
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        CNTR0_SET: bool, // bit offset: 29 desc: Writing a one sets the corresponding bit in the CNTCON register.
        CNTR1_SET: bool, // bit offset: 30 desc: Writing a one sets the corresponding bit in the CNTCON register.
        CNTR2_SET: bool, // bit offset: 31 desc: Writing a one sets the corresponding bit in the CNTCON register.
    });
    // byte offset: 100 Count Control clear address
    pub const CNTCON_CLR = mmio(Address + 0x00000064, 32, packed struct {
        TC0MCI0_RE_CLR: bool, // bit offset: 0 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC0MCI0_FE_CLR: bool, // bit offset: 1 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC0MCI1_RE_CLR: bool, // bit offset: 2 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC0MCI1_FE_CLR: bool, // bit offset: 3 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC0MCI2_RE: bool, // bit offset: 4 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC0MCI2_FE_CLR: bool, // bit offset: 5 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC1MCI0_RE_CLR: bool, // bit offset: 6 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC1MCI0_FE_CLR: bool, // bit offset: 7 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC1MCI1_RE_CLR: bool, // bit offset: 8 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC1MCI1_FE_CLR: bool, // bit offset: 9 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC1MCI2_RE_CLR: bool, // bit offset: 10 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC1MCI2_FE_CLR: bool, // bit offset: 11 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC2MCI0_RE_CLR: bool, // bit offset: 12 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC2MCI0_FE_CLR: bool, // bit offset: 13 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC2MCI1_RE_CLR: bool, // bit offset: 14 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC2MCI1_FE_CLR: bool, // bit offset: 15 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC2MCI2_RE_CLR: bool, // bit offset: 16 desc: Writing a one clears the corresponding bit in the CNTCON register.
        TC2MCI2_FE_CLR: bool, // bit offset: 17 desc: Writing a one clears the corresponding bit in the CNTCON register.
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        CNTR0_CLR: bool, // bit offset: 29 desc: Writing a one clears the corresponding bit in the CNTCON register.
        CNTR1_CLR: bool, // bit offset: 30 desc: Writing a one clears the corresponding bit in the CNTCON register.
        CNTR2_CLR: bool, // bit offset: 31 desc: Writing a one clears the corresponding bit in the CNTCON register.
    });
    // byte offset: 104 Interrupt flags read address
    pub const INTF = mmio(Address + 0x00000068, 32, packed struct {
        ILIM0_F: bool, // bit offset: 0 desc: Limit interrupt flag for channel 0.
        IMAT0_F: bool, // bit offset: 1 desc: Match interrupt flag for channel 0.
        ICAP0_F: bool, // bit offset: 2 desc: Capture interrupt flag for channel 0.
        reserved1: u1 = 0,
        ILIM1_F: bool, // bit offset: 4 desc: Limit interrupt flag for channel 1.
        IMAT1_F: bool, // bit offset: 5 desc: Match interrupt flag for channel 1.
        ICAP1_F: bool, // bit offset: 6 desc: Capture interrupt flag for channel 1.
        reserved2: u1 = 0,
        ILIM2_F: bool, // bit offset: 8 desc: Limit interrupt flag for channel 2.
        IMAT2_F: bool, // bit offset: 9 desc: Match interrupt flag for channel 2.
        ICAP2_F: bool, // bit offset: 10 desc: Capture interrupt flag for channel 2.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        ABORT_F: bool, // bit offset: 15 desc: Fast abort interrupt flag.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 108 Interrupt flags set address
    pub const INTF_SET = mmio(Address + 0x0000006c, 32, packed struct {
        ILIM0_F_SET: bool, // bit offset: 0 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        IMAT0_F_SET: bool, // bit offset: 1 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        ICAP0_F_SET: bool, // bit offset: 2 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        reserved1: u1 = 0,
        ILIM1_F_SET: bool, // bit offset: 4 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        IMAT1_F_SET: bool, // bit offset: 5 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        ICAP1_F_SET: bool, // bit offset: 6 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        reserved2: u1 = 0,
        ILIM2_F_SET: bool, // bit offset: 8 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        IMAT2_F_SET: bool, // bit offset: 9 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        ICAP2_F_SET: bool, // bit offset: 10 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        ABORT_F_SET: bool, // bit offset: 15 desc: Writing a one sets the corresponding bit in the INTF register, thus possibly simulating hardware interrupt.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 112 Interrupt flags clear address
    pub const INTF_CLR = mmio(Address + 0x00000070, 32, packed struct {
        ILIM0_F_CLR: bool, // bit offset: 0 desc: Writing a one clears the corresponding bit in the INTF register, thus clearing the corresponding interrupt request.
        IMAT0_F_CLR: bool, // bit offset: 1 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        ICAP0_F_CLR: bool, // bit offset: 2 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        reserved1: u1 = 0,
        ILIM1_F_CLR: bool, // bit offset: 4 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        IMAT1_F_CLR: bool, // bit offset: 5 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        ICAP1_F_CLR: bool, // bit offset: 6 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        reserved2: u1 = 0,
        ILIM2_F_CLR: bool, // bit offset: 8 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        IMAT2_F_CLR: bool, // bit offset: 9 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        ICAP2_F_CLR: bool, // bit offset: 10 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        ABORT_F_CLR: bool, // bit offset: 15 desc: Writing a one clears the corresponding bit in INTEN, thus disabling the interrupt.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 116 Capture clear address
    pub const CAP_CLR = mmio(Address + 0x00000074, 32, packed struct {
        CAP_CLR0: bool, // bit offset: 0 desc: Writing a 1 to this bit clears the CAP0 register.
        CAP_CLR1: bool, // bit offset: 1 desc: Writing a 1 to this bit clears the CAP1 register.
        CAP_CLR2: bool, // bit offset: 2 desc: Writing a 1 to this bit clears the CAP2 register.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const QEI = extern struct {
    pub const Address: u32 = 0x400bc000;
    // byte offset: 0 Control register
    pub const CON = mmio(Address + 0x00000000, 32, packed struct {
        RESP: bool, // bit offset: 0 desc: Reset position counter. When set = 1, resets the position counter to all zeros. Autoclears when the position counter is cleared.
        RESPI: bool, // bit offset: 1 desc: Reset position counter on index. When set = 1, resets the position counter to all zeros once only the first time an index pulse occurs. Autoclears when the position counter is cleared.
        RESV: bool, // bit offset: 2 desc: Reset velocity. When set = 1, resets the velocity counter to all zeros, reloads the velocity timer, and presets the velocity compare register. Autoclears when the velocity counter is cleared.
        RESI: bool, // bit offset: 3 desc: Reset index counter. When set = 1, resets the index counter to all zeros. Autoclears when the index counter is cleared.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 Status register
    pub const STAT = mmio(Address + 0x00000004, 32, packed struct {
        DIR: bool, // bit offset: 0 desc: Direction bit. In combination with DIRINV bit indicates forward or reverse direction. See Table 597.
        padding31: u1 = 0,
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Configuration register
    pub const CONF = mmio(Address + 0x00000008, 32, packed struct {
        DIRINV: bool, // bit offset: 0 desc: Direction invert. When 1, complements the DIR bit.
        SIGMODE: bool, // bit offset: 1 desc: Signal Mode. When 0, PhA and PhB function as quadrature encoder inputs. When 1, PhA functions as the direction signal and PhB functions as the clock signal.
        CAPMODE: bool, // bit offset: 2 desc: Capture Mode. When 0, only PhA edges are counted (2X). When 1, BOTH PhA and PhB edges are counted (4X), increasing resolution but decreasing range.
        INVINX: bool, // bit offset: 3 desc: Invert Index. When 1, inverts the sense of the index input.
        CRESPI: bool, // bit offset: 4 desc: Continuously reset the position counter on index. When 1, resets the position counter to all zeros whenever an index pulse occurs after the next position increase (recalibration).
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        INXGATE: u4, // bit offset: 16 desc: Index gating configuration: When INXGATE[16] = 1, pass the index when PHA = 1 and PHB = 0, otherwise block index. When INXGATE[17] = 1, pass the index when PHA = 1 and PHB = 1, otherwise block index. When INXGATE[18] = 1, pass the index when PHA = 0 and PHB = 1, otherwise block index. When INXGATE[19] = 1, pass the index when PHA = 0 and PHB = 0, otherwise block index.
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Position register
    pub const POS = mmio(Address + 0x0000000c, 32, packed struct {
        POS: u32, // bit offset: 0 desc: Current position value.
    });
    // byte offset: 16 Maximum position register
    pub const MAXPOS = mmio(Address + 0x00000010, 32, packed struct {
        MAXPOS: u32, // bit offset: 0 desc: Current maximum position value.
    });
    // byte offset: 20 Position compare register 0
    pub const CMPOS0 = mmio(Address + 0x00000014, 32, packed struct {
        PCMP0: u32, // bit offset: 0 desc: Position compare value 0.
    });
    // byte offset: 24 Position compare register 1
    pub const CMPOS1 = mmio(Address + 0x00000018, 32, packed struct {
        PCMP1: u32, // bit offset: 0 desc: Position compare value 1.
    });
    // byte offset: 28 Position compare register 2
    pub const CMPOS2 = mmio(Address + 0x0000001c, 32, packed struct {
        PCMP2: u32, // bit offset: 0 desc: Position compare value 2.
    });
    // byte offset: 32 Index count register 0
    pub const INXCNT = mmio(Address + 0x00000020, 32, packed struct {
        ENCPOS: u32, // bit offset: 0 desc: Current index counter value.
    });
    // byte offset: 36 Index compare register 0
    pub const INXCMP0 = mmio(Address + 0x00000024, 32, packed struct {
        ICMP0: u32, // bit offset: 0 desc: Index compare value 0.
    });
    // byte offset: 40 Velocity timer reload register
    pub const LOAD = mmio(Address + 0x00000028, 32, packed struct {
        VELLOAD: u32, // bit offset: 0 desc: Current velocity timer load value.
    });
    // byte offset: 44 Velocity timer register
    pub const TIME = mmio(Address + 0x0000002c, 32, packed struct {
        VELVAL: u32, // bit offset: 0 desc: Current velocity timer value.
    });
    // byte offset: 48 Velocity counter register
    pub const VEL = mmio(Address + 0x00000030, 32, packed struct {
        VELPC: u32, // bit offset: 0 desc: Current velocity pulse count.
    });
    // byte offset: 52 Velocity capture register
    pub const CAP = mmio(Address + 0x00000034, 32, packed struct {
        VELCAP: u32, // bit offset: 0 desc: Last velocity capture.
    });
    // byte offset: 56 Velocity compare register
    pub const VELCOMP = mmio(Address + 0x00000038, 32, packed struct {
        VELPC: u32, // bit offset: 0 desc: Compare velocity pulse count.
    });
    // byte offset: 60 Digital filter register
    pub const FILTER = mmio(Address + 0x0000003c, 32, packed struct {
        FILTA: u32, // bit offset: 0 desc: Digital filter sampling delay.
    });
    // byte offset: 4056 Interrupt enable clear register
    pub const IEC = mmio(Address + 0x00000fd8, 32, packed struct {
        INX_INT: bool, // bit offset: 0 desc: Writing a 1 disables the INX_Int interrupt in the QEIIE register.
        TIM_INT: bool, // bit offset: 1 desc: Writing a 1 disables the TIN_Int interrupt in the QEIIE register.
        VELC_INT: bool, // bit offset: 2 desc: Writing a 1 disables the VELC_Int interrupt in the QEIIE register.
        DIR_INT: bool, // bit offset: 3 desc: Writing a 1 disables the DIR_Int interrupt in the QEIIE register.
        ERR_INT: bool, // bit offset: 4 desc: Writing a 1 disables the ERR_Int interrupt in the QEIIE register.
        ENCLK_INT: bool, // bit offset: 5 desc: Writing a 1 disables the ENCLK_Int interrupt in the QEIIE register.
        POS0_INT: bool, // bit offset: 6 desc: Writing a 1 disables the POS0_Int interrupt in the QEIIE register.
        POS1_INT: bool, // bit offset: 7 desc: Writing a 1 disables the POS1_Int interrupt in the QEIIE register.
        POS2_INT: bool, // bit offset: 8 desc: Writing a 1 disables the POS2_Int interrupt in the QEIIE register.
        REV0_INT: bool, // bit offset: 9 desc: Writing a 1 disables the REV0_Int interrupt in the QEIIE register.
        POS0REV_INT: bool, // bit offset: 10 desc: Writing a 1 disables the POS0REV_Int interrupt in the QEIIE register.
        POS1REV_INT: bool, // bit offset: 11 desc: Writing a 1 disables the POS1REV_Int interrupt in the QEIIE register.
        POS2REV_INT: bool, // bit offset: 12 desc: Writing a 1 disables the POS2REV_Int interrupt in the QEIIE register.
        REV1_INT: bool, // bit offset: 13 desc: Writing a 1 disables the REV1_Int interrupt in the QEIIE register.
        REV2_INT: bool, // bit offset: 14 desc: Writing a 1 disables the REV2_Int interrupt in the QEIIE register.
        MAXPOS_INT: bool, // bit offset: 15 desc: Writing a 1 disables the MAXPOS_Int interrupt in the QEIIE register.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4060 Interrupt enable set register
    pub const IES = mmio(Address + 0x00000fdc, 32, packed struct {
        INX_INT: bool, // bit offset: 0 desc: Writing a 1 enables the INX_Int interrupt in the QEIIE register.
        TIM_INT: bool, // bit offset: 1 desc: Writing a 1 enables the TIN_Int interrupt in the QEIIE register.
        VELC_INT: bool, // bit offset: 2 desc: Writing a 1 enables the VELC_Int interrupt in the QEIIE register.
        DIR_INT: bool, // bit offset: 3 desc: Writing a 1 enables the DIR_Int interrupt in the QEIIE register.
        ERR_INT: bool, // bit offset: 4 desc: Writing a 1 enables the ERR_Int interrupt in the QEIIE register.
        ENCLK_INT: bool, // bit offset: 5 desc: Writing a 1 enables the ENCLK_Int interrupt in the QEIIE register.
        POS0_INT: bool, // bit offset: 6 desc: Writing a 1 enables the POS0_Int interrupt in the QEIIE register.
        POS1_INT: bool, // bit offset: 7 desc: Writing a 1 enables the POS1_Int interrupt in the QEIIE register.
        POS2_INT: bool, // bit offset: 8 desc: Writing a 1 enables the POS2_Int interrupt in the QEIIE register.
        REV0_INT: bool, // bit offset: 9 desc: Writing a 1 enables the REV0_Int interrupt in the QEIIE register.
        POS0REV_INT: bool, // bit offset: 10 desc: Writing a 1 enables the POS0REV_Int interrupt in the QEIIE register.
        POS1REV_INT: bool, // bit offset: 11 desc: Writing a 1 enables the POS1REV_Int interrupt in the QEIIE register.
        POS2REV_INT: bool, // bit offset: 12 desc: Writing a 1 enables the POS2REV_Int interrupt in the QEIIE register.
        REV1_INT: bool, // bit offset: 13 desc: Writing a 1 enables the REV1_Int interrupt in the QEIIE register.
        REV2_INT: bool, // bit offset: 14 desc: Writing a 1 enables the REV2_Int interrupt in the QEIIE register.
        MAXPOS_INT: bool, // bit offset: 15 desc: Writing a 1 enables the MAXPOS_Int interrupt in the QEIIE register.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4064 Interrupt status register
    pub const INTSTAT = mmio(Address + 0x00000fe0, 32, packed struct {
        INX_INT: bool, // bit offset: 0 desc: Indicates that an index pulse was detected.
        TIM_INT: bool, // bit offset: 1 desc: Indicates that a velocity timer overflow occurred
        VELC_INT: bool, // bit offset: 2 desc: Indicates that captured velocity is less than compare velocity.
        DIR_INT: bool, // bit offset: 3 desc: Indicates that a change of direction was detected.
        ERR_INT: bool, // bit offset: 4 desc: Indicates that an encoder phase error was detected.
        ENCLK_INT: bool, // bit offset: 5 desc: Indicates that and encoder clock pulse was detected.
        POS0_INT: bool, // bit offset: 6 desc: Indicates that the position 0 compare value is equal to the current position.
        POS1_INT: bool, // bit offset: 7 desc: Indicates that the position 1compare value is equal to the current position.
        POS2_INT: bool, // bit offset: 8 desc: Indicates that the position 2 compare value is equal to the current position.
        REV0_INT: bool, // bit offset: 9 desc: Indicates that the index compare 0 value is equal to the current index count.
        POS0REV_INT: bool, // bit offset: 10 desc: Combined position 0 and revolution count interrupt. Set when both the POS0_Int bit is set and the REV0_Int is set.
        POS1REV_INT: bool, // bit offset: 11 desc: Combined position 1 and revolution count interrupt. Set when both the POS1_Int bit is set and the REV1_Int is set.
        POS2REV_INT: bool, // bit offset: 12 desc: Combined position 2 and revolution count interrupt. Set when both the POS2_Int bit is set and the REV2_Int is set.
        REV1_INT: bool, // bit offset: 13 desc: Indicates that the index compare 1value is equal to the current index count.
        REV2_INT: bool, // bit offset: 14 desc: Indicates that the index compare 2 value is equal to the current index count.
        MAXPOS_INT: bool, // bit offset: 15 desc: Indicates that the current position count goes through the MAXPOS value to zero in the forward direction, or through zero to MAXPOS in the reverse direction.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4068 Interrupt enable register
    pub const IE = mmio(Address + 0x00000fe4, 32, packed struct {
        INX_INT: bool, // bit offset: 0 desc: When 1, the INX_Int interrupt is enabled.
        TIM_INT: bool, // bit offset: 1 desc: When 1, the TIN_Int interrupt is enabled.
        VELC_INT: bool, // bit offset: 2 desc: When 1, the VELC_Int interrupt is enabled.
        DIR_INT: bool, // bit offset: 3 desc: When 1, the DIR_Int interrupt is enabled.
        ERR_INT: bool, // bit offset: 4 desc: When 1, the ERR_Int interrupt is enabled.
        ENCLK_INT: bool, // bit offset: 5 desc: When 1, the ENCLK_Int interrupt is enabled.
        POS0_INT: bool, // bit offset: 6 desc: When 1, the POS0_Int interrupt is enabled.
        POS1_INT: bool, // bit offset: 7 desc: When 1, the POS1_Int interrupt is enabled.
        POS2_INT: bool, // bit offset: 8 desc: When 1, the POS2_Int interrupt is enabled.
        REV0_INT: bool, // bit offset: 9 desc: When 1, the REV0_Int interrupt is enabled.
        POS0REV_INT: bool, // bit offset: 10 desc: When 1, the POS0REV_Int interrupt is enabled.
        POS1REV_INT: bool, // bit offset: 11 desc: When 1, the POS1REV_Int interrupt is enabled.
        POS2REV_INT: bool, // bit offset: 12 desc: When 1, the POS2REV_Int interrupt is enabled.
        REV1_INT: bool, // bit offset: 13 desc: When 1, the REV1_Int interrupt is enabled.
        REV2_INT: bool, // bit offset: 14 desc: When 1, the REV2_Int interrupt is enabled.
        MAXPOS_INT: bool, // bit offset: 15 desc: When 1, the MAXPOS_Int interrupt is enabled.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4072 Interrupt status clear register
    pub const CLR = mmio(Address + 0x00000fe8, 32, packed struct {
        INX_INT: bool, // bit offset: 0 desc: Writing a 1 clears the INX_Int bit in QEIINTSTAT.
        TIM_INT: bool, // bit offset: 1 desc: Writing a 1 clears the TIN_Int bit in QEIINTSTAT.
        VELC_INT: bool, // bit offset: 2 desc: Writing a 1 clears the VELC_Int bit in QEIINTSTAT.
        DIR_INT: bool, // bit offset: 3 desc: Writing a 1 clears the DIR_Int bit in QEIINTSTAT.
        ERR_INT: bool, // bit offset: 4 desc: Writing a 1 clears the ERR_Int bit in QEIINTSTAT.
        ENCLK_INT: bool, // bit offset: 5 desc: Writing a 1 clears the ENCLK_Int bit in QEIINTSTAT.
        POS0_INT: bool, // bit offset: 6 desc: Writing a 1 clears the POS0_Int bit in QEIINTSTAT.
        POS1_INT: bool, // bit offset: 7 desc: Writing a 1 clears the POS1_Int bit in QEIINTSTAT.
        POS2_INT: bool, // bit offset: 8 desc: Writing a 1 clears the POS2_Int bit in QEIINTSTAT.
        REV0_INT: bool, // bit offset: 9 desc: Writing a 1 clears the REV0_Int bit in QEIINTSTAT.
        POS0REV_INT: bool, // bit offset: 10 desc: Writing a 1 clears the POS0REV_Int bit in QEIINTSTAT.
        POS1REV_INT: bool, // bit offset: 11 desc: Writing a 1 clears the POS1REV_Int bit in QEIINTSTAT.
        POS2REV_INT: bool, // bit offset: 12 desc: Writing a 1 clears the POS2REV_Int bit in QEIINTSTAT.
        REV1_INT: bool, // bit offset: 13 desc: Writing a 1 clears the REV1_Int bit in QEIINTSTAT.
        REV2_INT: bool, // bit offset: 14 desc: Writing a 1 clears the REV2_Int bit in QEIINTSTAT.
        MAXPOS_INT: bool, // bit offset: 15 desc: Writing a 1 clears the MAXPOS_Int bit in QEIINTSTAT.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4076 Interrupt status set register
    pub const SET = mmio(Address + 0x00000fec, 32, packed struct {
        INX_INT: bool, // bit offset: 0 desc: Writing a 1 sets the INX_Int bit in QEIINTSTAT.
        TIM_INT: bool, // bit offset: 1 desc: Writing a 1 sets the TIN_Int bit in QEIINTSTAT.
        VELC_INT: bool, // bit offset: 2 desc: Writing a 1 sets the VELC_Int bit in QEIINTSTAT.
        DIR_INT: bool, // bit offset: 3 desc: Writing a 1 sets the DIR_Int bit in QEIINTSTAT.
        ERR_INT: bool, // bit offset: 4 desc: Writing a 1 sets the ERR_Int bit in QEIINTSTAT.
        ENCLK_INT: bool, // bit offset: 5 desc: Writing a 1 sets the ENCLK_Int bit in QEIINTSTAT.
        POS0_INT: bool, // bit offset: 6 desc: Writing a 1 sets the POS0_Int bit in QEIINTSTAT.
        POS1_INT: bool, // bit offset: 7 desc: Writing a 1 sets the POS1_Int bit in QEIINTSTAT.
        POS2_INT: bool, // bit offset: 8 desc: Writing a 1 sets the POS2_Int bit in QEIINTSTAT.
        REV0_INT: bool, // bit offset: 9 desc: Writing a 1 sets the REV0_Int bit in QEIINTSTAT.
        POS0REV_INT: bool, // bit offset: 10 desc: Writing a 1 sets the POS0REV_Int bit in QEIINTSTAT.
        POS1REV_INT: bool, // bit offset: 11 desc: Writing a 1 sets the POS1REV_Int bit in QEIINTSTAT.
        POS2REV_INT: bool, // bit offset: 12 desc: Writing a 1 sets the POS2REV_Int bit in QEIINTSTAT.
        REV1_INT: bool, // bit offset: 13 desc: Writing a 1 sets the REV1_Int bit in QEIINTSTAT.
        REV2_INT: bool, // bit offset: 14 desc: Writing a 1 sets the REV2_Int bit in QEIINTSTAT.
        MAXPOS_INT: bool, // bit offset: 15 desc: Writing a 1 sets the MAXPOS_Int bit in QEIINTSTAT.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const SYSCON = extern struct {
    pub const Address: u32 = 0x400fc000;
    // byte offset: 0 Flash Accelerator Configuration Register. Controls flash access timing.
    pub const FLASHCFG = mmio(Address + 0x00000000, 32, packed struct {
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        FLASHTIM: u4, // bit offset: 12 desc: Flash access time. The value of this field plus 1 gives the number of CPU clocks used for a flash access. Warning: improper setting of this value may result in incorrect operation of the device. Other values are reserved.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 128 PLL0 Control Register
    pub const PLL0CON = mmio(Address + 0x00000080, 32, packed struct {
        PLLE0: bool, // bit offset: 0 desc: PLL0 Enable. When one, and after a valid PLL0 feed, this bit will activate PLL0 and allow it to lock to the requested frequency. See PLL0STAT register.
        PLLC0: bool, // bit offset: 1 desc: PLL0 Connect. Setting PLLC0 to one after PLL0 has been enabled and locked, then followed by a valid PLL0 feed sequence causes PLL0 to become the clock source for the CPU, AHB peripherals, and used to derive the clocks for APB peripherals. The PLL0 output may potentially be used to clock the USB subsystem if the frequency is 48 MHz. See PLL0STAT register.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 132 PLL0 Configuration Register
    pub const PLL0CFG = mmio(Address + 0x00000084, 32, packed struct {
        MSEL0: u15, // bit offset: 0 desc: PLL0 Multiplier value. Supplies the value M in PLL0 frequency calculations. The value stored here is M - 1. Note: Not all values of M are needed, and therefore some are not supported by hardware.
        reserved1: u1 = 0,
        NSEL0: u8, // bit offset: 16 desc: PLL0 Pre-Divider value. Supplies the value N in PLL0 frequency calculations. The value stored here is N - 1. Supported values for N are 1 through 32.
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 136 PLL0 Status Register
    pub const PLL0STAT = mmio(Address + 0x00000088, 32, packed struct {
        MSEL0: u15, // bit offset: 0 desc: Read-back for the PLL0 Multiplier value. This is the value currently used by PLL0, and is one less than the actual multiplier.
        reserved1: u1 = 0,
        NSEL0: u8, // bit offset: 16 desc: Read-back for the PLL0 Pre-Divider value. This is the value currently used by PLL0, and is one less than the actual divider.
        PLLE0_STAT: bool, // bit offset: 24 desc: Read-back for the PLL0 Enable bit. This bit reflects the state of the PLEC0 bit in PLL0CON after a valid PLL0 feed. When one, PLL0 is currently enabled. When zero, PLL0 is turned off. This bit is automatically cleared when Power-down mode is entered.
        PLLC0_STAT: bool, // bit offset: 25 desc: Read-back for the PLL0 Connect bit. This bit reflects the state of the PLLC0 bit in PLL0CON after a valid PLL0 feed. When PLLC0 and PLLE0 are both one, PLL0 is connected as the clock source for the CPU. When either PLLC0 or PLLE0 is zero, PLL0 is bypassed. This bit is automatically cleared when Power-down mode is entered.
        PLOCK0: bool, // bit offset: 26 desc: Reflects the PLL0 Lock status. When zero, PLL0 is not locked. When one, PLL0 is locked onto the requested frequency. See text for details.
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 140 PLL0 Feed Register
    pub const PLL0FEED = mmio(Address + 0x0000008c, 32, packed struct {
        PLL0FEED: u8, // bit offset: 0 desc: The PLL0 feed sequence must be written to this register in order for PLL0 configuration and control register changes to take effect.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 160 PLL1 Control Register
    pub const PLL1CON = mmio(Address + 0x000000a0, 32, packed struct {
        PLLE1: bool, // bit offset: 0 desc: PLL1 Enable. When one, and after a valid PLL1 feed, this bit will activate PLL1 and allow it to lock to the requested frequency.
        PLLC1: bool, // bit offset: 1 desc: PLL1 Connect. Setting PLLC to one after PLL1 has been enabled and locked, then followed by a valid PLL1 feed sequence causes PLL1 to become the clock source for the USB subsystem via the USB clock divider. See PLL1STAT register.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 164 PLL1 Configuration Register
    pub const PLL1CFG = mmio(Address + 0x000000a4, 32, packed struct {
        MSEL1: u5, // bit offset: 0 desc: PLL1 Multiplier value. Supplies the value M in the PLL1 frequency calculations.
        PSEL1: u2, // bit offset: 5 desc: PLL1 Divider value. Supplies the value P in the PLL1 frequency calculations.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 168 PLL1 Status Register
    pub const PLL1STAT = mmio(Address + 0x000000a8, 32, packed struct {
        MSEL1: u5, // bit offset: 0 desc: Read-back for the PLL1 Multiplier value. This is the value currently used by PLL1.
        PSEL1: u2, // bit offset: 5 desc: Read-back for the PLL1 Divider value. This is the value currently used by PLL1.
        reserved1: u1 = 0,
        PLLE1_STAT: bool, // bit offset: 8 desc: Read-back for the PLL1 Enable bit. When one, PLL1 is currently activated. When zero, PLL1 is turned off. This bit is automatically cleared when Power-down mode is activated.
        PLLC1_STAT: bool, // bit offset: 9 desc: Read-back for the PLL1 Connect bit. When PLLC and PLLE are both one, PLL1 is connected as the clock source for the microcontroller. When either PLLC or PLLE is zero, PLL1 is bypassed and the oscillator clock is used directly by the microcontroller. This bit is automatically cleared when Power-down mode is activated.
        PLOCK1: bool, // bit offset: 10 desc: Reflects the PLL1 Lock status. When zero, PLL1 is not locked. When one, PLL1 is locked onto the requested frequency.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 172 PLL1 Feed Register
    pub const PLL1FEED = mmio(Address + 0x000000ac, 32, packed struct {
        PLL1FEED: u8, // bit offset: 0 desc: The PLL1 feed sequence must be written to this register in order for PLL1 configuration and control register changes to take effect.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 192 Power Control Register
    pub const PCON = mmio(Address + 0x000000c0, 32, packed struct {
        PM0: bool, // bit offset: 0 desc: Power mode control bit 0. This bit controls entry to the Power-down mode.
        PM1: bool, // bit offset: 1 desc: Power mode control bit 1. This bit controls entry to the Deep Power-down mode.
        BODRPM: bool, // bit offset: 2 desc: Brown-Out Reduced Power Mode. When BODRPM is 1, the Brown-Out Detect circuitry will be turned off when chip Power-down mode or Deep Sleep mode is entered, resulting in a further reduction in power usage. However, the possibility of using Brown-Out Detect as a wake-up source from the reduced power mode will be lost. When 0, the Brown-Out Detect function remains active during Power-down and Deep Sleep modes. See the System Control Block chapter for details of Brown-Out detection.
        BOGD: bool, // bit offset: 3 desc: Brown-Out Global Disable. When BOGD is 1, the Brown-Out Detect circuitry is fully disabled at all times, and does not consume power. When 0, the Brown-Out Detect circuitry is enabled. See the System Control Block chapter for details of Brown-Out detection. Note: the Brown-Out Reset Disable (BORD, in this register) and the Brown-Out Interrupt (xx) must be disabled when software changes the value of this bit.
        BORD: bool, // bit offset: 4 desc: Brown-Out Reset Disable. When BORD is 1, the BOD will not reset the device when the VDD(REG)(3V3) voltage dips goes below the BOD reset trip level. The Brown-Out interrupt is not affected. When BORD is 0, the BOD reset is enabled.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SMFLAG: bool, // bit offset: 8 desc: Sleep Mode entry flag. Set when the Sleep mode is successfully entered. Cleared by software writing a one to this bit.
        DSFLAG: bool, // bit offset: 9 desc: Deep Sleep entry flag. Set when the Deep Sleep mode is successfully entered. Cleared by software writing a one to this bit.
        PDFLAG: bool, // bit offset: 10 desc: Power-down entry flag. Set when the Power-down mode is successfully entered. Cleared by software writing a one to this bit.
        DPDFLAG: bool, // bit offset: 11 desc: Deep Power-down entry flag. Set when the Deep Power-down mode is successfully entered. Cleared by software writing a one to this bit.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 196 Power Control for Peripherals Register
    pub const PCONP = mmio(Address + 0x000000c4, 32, packed struct {
        reserved1: u1 = 0,
        PCTIM0: bool, // bit offset: 1 desc: Timer/Counter 0 power/clock control bit.
        PCTIM1: bool, // bit offset: 2 desc: Timer/Counter 1 power/clock control bit.
        PCUART0: bool, // bit offset: 3 desc: UART0 power/clock control bit.
        PCUART1: bool, // bit offset: 4 desc: UART1 power/clock control bit.
        reserved2: u1 = 0,
        PCPWM1: bool, // bit offset: 6 desc: PWM1 power/clock control bit.
        PCI2C0: bool, // bit offset: 7 desc: The I2C0 interface power/clock control bit.
        PCSPI: bool, // bit offset: 8 desc: The SPI interface power/clock control bit.
        PCRTC: bool, // bit offset: 9 desc: The RTC power/clock control bit.
        PCSSP1: bool, // bit offset: 10 desc: The SSP 1 interface power/clock control bit.
        reserved3: u1 = 0,
        PCADC: bool, // bit offset: 12 desc: A/D converter (ADC) power/clock control bit. Note: Clear the PDN bit in the AD0CR before clearing this bit, and set this bit before setting PDN.
        PCCAN1: bool, // bit offset: 13 desc: CAN Controller 1 power/clock control bit.
        PCCAN2: bool, // bit offset: 14 desc: CAN Controller 2 power/clock control bit.
        PCGPIO: bool, // bit offset: 15 desc: Power/clock control bit for IOCON, GPIO, and GPIO interrupts.
        PCRIT: bool, // bit offset: 16 desc: Repetitive Interrupt Timer power/clock control bit.
        PCMCPWM: bool, // bit offset: 17 desc: Motor Control PWM
        PCQEI: bool, // bit offset: 18 desc: Quadrature Encoder Interface power/clock control bit.
        PCI2C1: bool, // bit offset: 19 desc: The I2C1 interface power/clock control bit.
        reserved4: u1 = 0,
        PCSSP0: bool, // bit offset: 21 desc: The SSP0 interface power/clock control bit.
        PCTIM2: bool, // bit offset: 22 desc: Timer 2 power/clock control bit.
        PCTIM3: bool, // bit offset: 23 desc: Timer 3 power/clock control bit.
        PCUART2: bool, // bit offset: 24 desc: UART 2 power/clock control bit.
        PCUART3: bool, // bit offset: 25 desc: UART 3 power/clock control bit.
        PCI2C2: bool, // bit offset: 26 desc: I2C interface 2 power/clock control bit.
        PCI2S: bool, // bit offset: 27 desc: I2S interface power/clock control bit.
        reserved5: u1 = 0,
        PCGPDMA: bool, // bit offset: 29 desc: GPDMA function power/clock control bit.
        PCENET: bool, // bit offset: 30 desc: Ethernet block power/clock control bit.
        PCUSB: bool, // bit offset: 31 desc: USB interface power/clock control bit.
    });
    // byte offset: 260 CPU Clock Configuration Register
    pub const CCLKCFG = mmio(Address + 0x00000104, 32, packed struct {
        CCLKSEL: u8, // bit offset: 0 desc: Selects the divide value for creating the CPU clock (CCLK) from the PLL0 output. 0 = pllclk is divided by 1 to produce the CPU clock. This setting is not allowed when the PLL0 is connected, because the rate would always be greater than the maximum allowed CPU clock. 1 = pllclk is divided by 2 to produce the CPU clock. This setting is not allowed when the PLL0 is connected, because the rate would always be greater than the maximum allowed CPU clock. 2 = pllclk is divided by 3 to produce the CPU clock. 3 = pllclk is divided by 4 to produce the CPU clock. ... 255 = pllclk is divided by 256 to produce the CPU clock.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 264 USB Clock Configuration Register
    pub const USBCLKCFG = mmio(Address + 0x00000108, 32, packed struct {
        USBSEL: u4, // bit offset: 0 desc: Selects the divide value for creating the USB clock from the PLL0 output. Only the values shown below can produce even number multiples of 48 MHz from the PLL0 output. Warning: Improper setting of this value will result in incorrect operation of the USB interface. 5 = PLL0 output is divided by 6. PLL0 output must be 288 MHz. 7 = PLL0 output is divided by 8. PLL0 output must be 384 MHz. 9 = PLL0 output is divided by 10. PLL0 output must be 480 MHz.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 268 Clock Source Select Register
    pub const CLKSRCSEL = mmio(Address + 0x0000010c, 32, packed struct {
        CLKSRC: u2, // bit offset: 0 desc: Selects the clock source for PLL0 as follows. Warning: Improper setting of this value, or an incorrect sequence of changing this value may result in incorrect operation of the device.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 272 Allows clearing the current CAN channel sleep state as well as reading that state.
    pub const CANSLEEPCLR = mmio(Address + 0x00000110, 32, packed struct {
        reserved1: u1 = 0,
        CAN1SLEEP: bool, // bit offset: 1 desc: Sleep status and control for CAN channel 1. Read: when 1, indicates that CAN channel 1 is in the sleep mode. Write: writing a 1 causes clocks to be restored to CAN channel 1.
        CAN2SLEEP: bool, // bit offset: 2 desc: Sleep status and control for CAN channel 2. Read: when 1, indicates that CAN channel 2 is in the sleep mode. Write: writing a 1 causes clocks to be restored to CAN channel 2.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 276 Allows reading the wake-up state of the CAN channels.
    pub const CANWAKEFLAGS = mmio(Address + 0x00000114, 32, packed struct {
        reserved1: u1 = 0,
        CAN1WAKE: bool, // bit offset: 1 desc: Wake-up status for CAN channel 1. Read: when 1, indicates that a falling edge has occurred on the receive data line of CAN channel 1. Write: writing a 1 clears this bit.
        CAN2WAKE: bool, // bit offset: 2 desc: Wake-up status for CAN channel 2. Read: when 1, indicates that a falling edge has occurred on the receive data line of CAN channel 2. Write: writing a 1 clears this bit.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 320 External Interrupt Flag Register
    pub const EXTINT = mmio(Address + 0x00000140, 32, packed struct {
        EINT0: bool, // bit offset: 0 desc: In level-sensitive mode, this bit is set if the EINT0 function is selected for its pin, and the pin is in its active state. In edge-sensitive mode, this bit is set if the EINT0 function is selected for its pin, and the selected edge occurs on the pin. This bit is cleared by writing a one to it, except in level sensitive mode when the pin is in its active state.
        EINT1: bool, // bit offset: 1 desc: In level-sensitive mode, this bit is set if the EINT1 function is selected for its pin, and the pin is in its active state. In edge-sensitive mode, this bit is set if the EINT1 function is selected for its pin, and the selected edge occurs on the pin. This bit is cleared by writing a one to it, except in level sensitive mode when the pin is in its active state.
        EINT2: bool, // bit offset: 2 desc: In level-sensitive mode, this bit is set if the EINT2 function is selected for its pin, and the pin is in its active state. In edge-sensitive mode, this bit is set if the EINT2 function is selected for its pin, and the selected edge occurs on the pin. This bit is cleared by writing a one to it, except in level sensitive mode when the pin is in its active state.
        EINT3: bool, // bit offset: 3 desc: In level-sensitive mode, this bit is set if the EINT3 function is selected for its pin, and the pin is in its active state. In edge-sensitive mode, this bit is set if the EINT3 function is selected for its pin, and the selected edge occurs on the pin. This bit is cleared by writing a one to it, except in level sensitive mode when the pin is in its active state.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 328 External Interrupt Mode register
    pub const EXTMODE = mmio(Address + 0x00000148, 32, packed struct {
        EXTMODE0: bool, // bit offset: 0 desc: External interrupt 0 EINT0 mode.
        EXTMODE1: bool, // bit offset: 1 desc: External interrupt 1 EINT1 mode.
        EXTMODE2: bool, // bit offset: 2 desc: External interrupt 2 EINT2 mode.
        EXTMODE3: bool, // bit offset: 3 desc: External interrupt 3 EINT3 mode.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 332 External Interrupt Polarity Register
    pub const EXTPOLAR = mmio(Address + 0x0000014c, 32, packed struct {
        EXTPOLAR0: bool, // bit offset: 0 desc: External interrupt 0 EINT0 polarity.
        EXTPOLAR1: bool, // bit offset: 1 desc: External interrupt 1 EINT1 polarity.
        EXTPOLAR2: bool, // bit offset: 2 desc: External interrupt 2 EINT2 polarity.
        EXTPOLAR3: bool, // bit offset: 3 desc: External interrupt 3 EINT3 polarity.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 384 Reset Source Identification Register
    pub const RSID = mmio(Address + 0x00000180, 32, packed struct {
        POR: bool, // bit offset: 0 desc: Assertion of the POR signal sets this bit, and clears all of the other bits in this register. But if another Reset signal (e.g., External Reset) remains asserted after the POR signal is negated, then its bit is set. This bit is not affected by any of the other sources of Reset.
        EXTR: bool, // bit offset: 1 desc: Assertion of the RESET signal sets this bit. This bit is cleared only by software or POR.
        WDTR: bool, // bit offset: 2 desc: This bit is set when the Watchdog Timer times out and the WDTRESET bit in the Watchdog Mode Register is 1. This bit is cleared only by software or POR.
        BODR: bool, // bit offset: 3 desc: This bit is set when the VDD(REG)(3V3) voltage reaches a level below the BOD reset trip level (typically 1.85 V under nominal room temperature conditions). If the VDD(REG)(3V3) voltage dips from the normal operating range to below the BOD reset trip level and recovers, the BODR bit will be set to 1. If the VDD(REG)(3V3) voltage dips from the normal operating range to below the BOD reset trip level and continues to decline to the level at which POR is asserted (nominally 1 V), the BODR bit is cleared. If the VDD(REG)(3V3) voltage rises continuously from below 1 V to a level above the BOD reset trip level, the BODR will be set to 1. This bit is cleared only by software or POR. Note: Only in the case where a reset occurs and the POR = 0, the BODR bit indicates if the VDD(REG)(3V3) voltage was below the BOD reset trip level or not.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 416 System control and status
    pub const SCS = mmio(Address + 0x000001a0, 32, packed struct {
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        OSCRANGE: bool, // bit offset: 4 desc: Main oscillator range select.
        OSCEN: bool, // bit offset: 5 desc: Main oscillator enable.
        OSCSTAT: bool, // bit offset: 6 desc: Main oscillator status.
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 424 Peripheral Clock Selection register 0.
    pub const PCLKSEL0 = mmio(Address + 0x000001a8, 32, packed struct {
        PCLK_WDT: u2, // bit offset: 0 desc: Peripheral clock selection for WDT.
        PCLK_TIMER0: u2, // bit offset: 2 desc: Peripheral clock selection for TIMER0.
        PCLK_TIMER1: u2, // bit offset: 4 desc: Peripheral clock selection for TIMER1.
        PCLK_UART0: u2, // bit offset: 6 desc: Peripheral clock selection for UART0.
        PCLK_UART1: u2, // bit offset: 8 desc: Peripheral clock selection for UART1.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PCLK_PWM1: u2, // bit offset: 12 desc: Peripheral clock selection for PWM1.
        PCLK_I2C0: u2, // bit offset: 14 desc: Peripheral clock selection for I2C0.
        PCLK_SPI: u2, // bit offset: 16 desc: Peripheral clock selection for SPI.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        PCLK_SSP1: u2, // bit offset: 20 desc: Peripheral clock selection for SSP1.
        PCLK_DAC: u2, // bit offset: 22 desc: Peripheral clock selection for DAC.
        PCLK_ADC: u2, // bit offset: 24 desc: Peripheral clock selection for ADC.
        PCLK_CAN1: u2, // bit offset: 26 desc: Peripheral clock selection for CAN1.PCLK_CAN1 and PCLK_CAN2 must have the same PCLK divide value when the CAN function is used.
        PCLK_CAN2: u2, // bit offset: 28 desc: Peripheral clock selection for CAN2.PCLK_CAN1 and PCLK_CAN2 must have the same PCLK divide value when the CAN function is used.
        PCLK_ACF: u2, // bit offset: 30 desc: Peripheral clock selection for CAN acceptance filtering.PCLK_CAN1 and PCLK_CAN2 must have the same PCLK divide value when the CAN function is used.
    });
    // byte offset: 428 Peripheral Clock Selection register 1.
    pub const PCLKSEL1 = mmio(Address + 0x000001ac, 32, packed struct {
        PCLK_QEI: u2, // bit offset: 0 desc: Peripheral clock selection for the Quadrature Encoder Interface.
        PCLK_GPIOINT: u2, // bit offset: 2 desc: Peripheral clock selection for GPIO interrupts.
        PCLK_PCB: u2, // bit offset: 4 desc: Peripheral clock selection for the Pin Connect block.
        PCLK_I2C1: u2, // bit offset: 6 desc: Peripheral clock selection for I2C1.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PCLK_SSP0: u2, // bit offset: 10 desc: Peripheral clock selection for SSP0.
        PCLK_TIMER2: u2, // bit offset: 12 desc: Peripheral clock selection for TIMER2.
        PCLK_TIMER3: u2, // bit offset: 14 desc: Peripheral clock selection for TIMER3.
        PCLK_UART2: u2, // bit offset: 16 desc: Peripheral clock selection for UART2.
        PCLK_UART3: u2, // bit offset: 18 desc: Peripheral clock selection for UART3.
        PCLK_I2C2: u2, // bit offset: 20 desc: Peripheral clock selection for I2C2.
        PCLK_I2S: u2, // bit offset: 22 desc: Peripheral clock selection for I2S.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        PCLK_RIT: u2, // bit offset: 26 desc: Peripheral clock selection for Repetitive Interrupt Timer.
        PCLK_SYSCON: u2, // bit offset: 28 desc: Peripheral clock selection for the System Control block.
        PCLK_MC: u2, // bit offset: 30 desc: Peripheral clock selection for the Motor Control PWM.
    });
    // byte offset: 448 USB Interrupt Status
    pub const USBINTST = mmio(Address + 0x000001c0, 32, packed struct {
        USB_INT_REQ_LP: bool, // bit offset: 0 desc: Low priority interrupt line status. This bit is read-only.
        USB_INT_REQ_HP: bool, // bit offset: 1 desc: High priority interrupt line status. This bit is read-only.
        USB_INT_REQ_DMA: bool, // bit offset: 2 desc: DMA interrupt line status. This bit is read-only.
        USB_HOST_INT: bool, // bit offset: 3 desc: USB host interrupt line status. This bit is read-only.
        USB_ATX_INT: bool, // bit offset: 4 desc: External ATX interrupt line status. This bit is read-only.
        USB_OTG_INT: bool, // bit offset: 5 desc: OTG interrupt line status. This bit is read-only.
        USB_I2C_INT: bool, // bit offset: 6 desc: I2C module interrupt line status. This bit is read-only.
        reserved1: u1 = 0,
        USB_NEED_CLK: bool, // bit offset: 8 desc: USB need clock indicator. This bit is read-only. This bit is set to 1 when USB activity or a change of state on the USB data pins is detected, and it indicates that a PLL supplied clock of 48 MHz is needed. Once USB_NEED_CLK becomes one, it resets to zero 5 ms after the last packet has been received/sent, or 2 ms after the Suspend Change (SUS_CH) interrupt has occurred. A change of this bit from 0 to 1 can wake up the microcontroller if activity on the USB bus is selected to wake up the part from the Power-down mode (see Section 4.7.9 Wake-up from Reduced Power Modes for details). Also see Section 4.5.8 PLLs and Power-down mode and Section 4.7.10 Power Control for Peripherals register (PCONP - 0x400F C0C4) for considerations about the PLL and invoking the Power-down mode. This bit is read-only.
        reserved23: u1 = 0,
        reserved22: u1 = 0,
        reserved21: u1 = 0,
        reserved20: u1 = 0,
        reserved19: u1 = 0,
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        EN_USB_INTS: bool, // bit offset: 31 desc: Enable all USB interrupts. When this bit is cleared, the NVIC does not see the ORed output of the USB interrupt lines.
    });
    // byte offset: 452 Selects between alternative requests on DMA channels 0 through 7 and 10 through 15
    pub const DMACREQSEL = mmio(Address + 0x000001c4, 32, packed struct {
        DMASEL08: bool, // bit offset: 0 desc: Selects the DMA request for GPDMA input 8: 0 - uart0 tx 1 - Timer 0 match 0 is selected.
        DMASEL09: bool, // bit offset: 1 desc: Selects the DMA request for GPDMA input 9: 0 - uart0 rx 1 - Timer 0 match 1 is selected.
        DMASEL10: bool, // bit offset: 2 desc: Selects the DMA request for GPDMA input 10: 0 - uart1 tx is selected. 1 - Timer 1 match 0 is selected.
        DMASEL11: bool, // bit offset: 3 desc: Selects the DMA request for GPDMA input 11: 0 - uart1 rx is selected. 1 - Timer 1 match 1 is selected.
        DMASEL12: bool, // bit offset: 4 desc: Selects the DMA request for GPDMA input 12: 0 - uart2 tx is selected. 1 - Timer 2 match 0 is selected.
        DMASEL13: bool, // bit offset: 5 desc: Selects the DMA request for GPDMA input 13: 0 - uart2 rx is selected. 1 - Timer 2 match 1 is selected.
        DMASEL14: bool, // bit offset: 6 desc: Selects the DMA request for GPDMA input 14: 0 - uart3 tx is selected. 1 - I2S channel 0 is selected.
        DMASEL15: bool, // bit offset: 7 desc: Selects the DMA request for GPDMA input 15: 0 - uart3 rx is selected. 1 - I2S channel 1 is selected.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 456 Clock Output Configuration Register
    pub const CLKOUTCFG = mmio(Address + 0x000001c8, 32, packed struct {
        CLKOUTSEL: u4, // bit offset: 0 desc: Selects the clock source for the CLKOUT function. Other values are reserved. Do not use.
        CLKOUTDIV: u4, // bit offset: 4 desc: Integer value to divide the output clock by, minus one. 0 = Clock is divided by 1 1 = Clock is divided by 2. 2 = Clock is divided by 3. ... 15 = Clock is divided by 16.
        CLKOUT_EN: bool, // bit offset: 8 desc: CLKOUT enable control, allows switching the CLKOUT source without glitches. Clear to stop CLKOUT on the next falling edge. Set to enable CLKOUT.
        CLKOUT_ACT: bool, // bit offset: 9 desc: CLKOUT activity indication. Reads as 1 when CLKOUT is enabled. Read as 0 when CLKOUT has been disabled via the CLKOUT_EN bit and the clock has completed being stopped.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const EMAC = extern struct {
    pub const Address: u32 = 0x50000000;
    // byte offset: 0 MAC configuration register 1.
    pub const MAC1 = mmio(Address + 0x00000000, 32, packed struct {
        RXENABLE: bool, // bit offset: 0 desc: RECEIVE ENABLE. Set this to allow receive frames to be received. Internally the MAC synchronizes this control bit to the incoming receive stream.
        PARF: bool, // bit offset: 1 desc: PASS ALL RECEIVE FRAMES. When enabled (set to 1), the MAC will pass all frames regardless of type (normal vs. Control). When disabled, the MAC does not pass valid Control frames.
        RXFLOWCTRL: bool, // bit offset: 2 desc: RX FLOW CONTROL. When enabled (set to 1), the MAC acts upon received PAUSE Flow Control frames. When disabled, received PAUSE Flow Control frames are ignored.
        TXFLOWCTRL: bool, // bit offset: 3 desc: TX FLOW CONTROL. When enabled (set to 1), PAUSE Flow Control frames are allowed to be transmitted. When disabled, Flow Control frames are blocked.
        LOOPBACK: bool, // bit offset: 4 desc: Setting this bit will cause the MAC Transmit interface to be looped back to the MAC Receive interface. Clearing this bit results in normal operation.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESETTX: bool, // bit offset: 8 desc: Setting this bit will put the Transmit Function logic in reset.
        RESETMCSTX: bool, // bit offset: 9 desc: Setting this bit resets the MAC Control Sublayer / Transmit logic. The MCS logic implements flow control.
        RESETRX: bool, // bit offset: 10 desc: Setting this bit will put the Ethernet receive logic in reset.
        RESETMCSRX: bool, // bit offset: 11 desc: Setting this bit resets the MAC Control Sublayer / Receive logic. The MCS logic implements flow control.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        SIMRESET: bool, // bit offset: 14 desc: SIMULATION RESET. Setting this bit will cause a reset to the random number generator within the Transmit Function.
        SOFTRESET: bool, // bit offset: 15 desc: SOFT RESET. Setting this bit will put all modules within the MAC in reset except the Host Interface.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 MAC configuration register 2.
    pub const MAC2 = mmio(Address + 0x00000004, 32, packed struct {
        FULLDUPLEX: bool, // bit offset: 0 desc: When enabled (set to 1), the MAC operates in Full-Duplex mode. When disabled, the MAC operates in Half-Duplex mode.
        FLC: bool, // bit offset: 1 desc: FRAMELENGTH CHECKING. When enabled (set to 1), both transmit and receive frame lengths are compared to the Length/Type field. If the Length/Type field represents a length then the check is performed. Mismatches are reported in the StatusInfo word for each received frame.
        HFEN: bool, // bit offset: 2 desc: HUGE FRAME ENABLEWhen enabled (set to 1), frames of any length are transmitted and received.
        DELAYEDCRC: bool, // bit offset: 3 desc: DELAYED CRC. This bit determines the number of bytes, if any, of proprietary header information that exist on the front of IEEE 802.3 frames. When 1, four bytes of header (ignored by the CRC function) are added. When 0, there is no proprietary header.
        CRCEN: bool, // bit offset: 4 desc: CRC ENABLESet this bit to append a CRC to every frame whether padding was required or not. Must be set if PAD/CRC ENABLE is set. Clear this bit if frames presented to the MAC contain a CRC.
        PADCRCEN: bool, // bit offset: 5 desc: PAD CRC ENABLE. Set this bit to have the MAC pad all short frames. Clear this bit if frames presented to the MAC have a valid length. This bit is used in conjunction with AUTO PAD ENABLE and VLAN PAD ENABLE. See Table 153 - Pad Operation for details on the pad function.
        VLANPADEN: bool, // bit offset: 6 desc: VLAN PAD ENABLE. Set this bit to cause the MAC to pad all short frames to 64 bytes and append a valid CRC. Consult Table 153 - Pad Operation for more information on the various padding features. Note: This bit is ignored if PAD / CRC ENABLE is cleared.
        AUTODETPADEN: bool, // bit offset: 7 desc: AUTODETECTPAD ENABLE. Set this bit to cause the MAC to automatically detect the type of frame, either tagged or un-tagged, by comparing the two octets following the source address with 0x8100 (VLAN Protocol ID) and pad accordingly. Table 153 - Pad Operation provides a description of the pad function based on the configuration of this register. Note: This bit is ignored if PAD / CRC ENABLE is cleared.
        PPENF: bool, // bit offset: 8 desc: PURE PREAMBLE ENFORCEMEN. When enabled (set to 1), the MAC will verify the content of the preamble to ensure it contains 0x55 and is error-free. A packet with an incorrect preamble is discarded. When disabled, no preamble checking is performed.
        LPENF: bool, // bit offset: 9 desc: LONG PREAMBLE ENFORCEMENT. When enabled (set to 1), the MAC only allows receive packets which contain preamble fields less than 12 bytes in length. When disabled, the MAC allows any length preamble as per the Standard.
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        NOBACKOFF: bool, // bit offset: 12 desc: When enabled (set to 1), the MAC will immediately retransmit following a collision rather than using the Binary Exponential Backoff algorithm as specified in the Standard.
        BP_NOBACKOFF: bool, // bit offset: 13 desc: BACK PRESSURE / NO BACKOFF. When enabled (set to 1), after the MAC incidentally causes a collision during back pressure, it will immediately retransmit without backoff, reducing the chance of further collisions and ensuring transmit packets get sent.
        EXCESSDEFER: bool, // bit offset: 14 desc: When enabled (set to 1) the MAC will defer to carrier indefinitely as per the Standard. When disabled, the MAC will abort when the excessive deferral limit is reached.
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 Back-to-Back Inter-Packet-Gap register.
    pub const IPGT = mmio(Address + 0x00000008, 32, packed struct {
        BTOBINTEGAP: u7, // bit offset: 0 desc: BACK-TO-BACK INTER-PACKET-GAP.This is a programmable field representing the nibble time offset of the minimum possible period between the end of any transmitted packet to the beginning of the next. In Full-Duplex mode, the register value should be the desired period in nibble times minus 3. In Half-Duplex mode, the register value should be the desired period in nibble times minus 6. In Full-Duplex the recommended setting is 0x15 (21d), which represents the minimum IPG of 960 ns (in 100 Mbps mode) or 9.6 us (in 10 Mbps mode). In Half-Duplex the recommended setting is 0x12 (18d), which also represents the minimum IPG of 960 ns (in 100 Mbps mode) or 9.6 us (in 10 Mbps mode).
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 Non Back-to-Back Inter-Packet-Gap register.
    pub const IPGR = mmio(Address + 0x0000000c, 32, packed struct {
        NBTOBINTEGAP2: u7, // bit offset: 0 desc: NON-BACK-TO-BACK INTER-PACKET-GAP PART2. This is a programmable field representing the Non-Back-to-Back Inter-Packet-Gap. The recommended value is 0x12 (18d), which represents the minimum IPG of 960 ns (in 100 Mbps mode) or 9.6 us (in 10 Mbps mode).
        reserved1: u1 = 0,
        NBTOBINTEGAP1: u7, // bit offset: 8 desc: NON-BACK-TO-BACK INTER-PACKET-GAP PART1. This is a programmable field representing the optional carrierSense window referenced in IEEE 802.3/4.2.3.2.1 'Carrier Deference'. If carrier is detected during the timing of IPGR1, the MAC defers to carrier. If, however, carrier becomes active after IPGR1, the MAC continues timing IPGR2 and transmits, knowingly causing a collision, thus ensuring fair access to medium. Its range of values is 0x0 to IPGR2. The recommended value is 0xC (12d)
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 Collision window / Retry register.
    pub const CLRT = mmio(Address + 0x00000010, 32, packed struct {
        RETRANSMAX: u4, // bit offset: 0 desc: RETRANSMISSION MAXIMUM.This is a programmable field specifying the number of retransmission attempts following a collision before aborting the packet due to excessive collisions. The Standard specifies the attemptLimit to be 0xF (15d). See IEEE 802.3/4.2.3.2.5.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        COLLWIN: u6, // bit offset: 8 desc: COLLISION WINDOW. This is a programmable field representing the slot time or collision window during which collisions occur in properly configured networks. The default value of 0x37 (55d) represents a 56 byte window following the preamble and SFD.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 Maximum Frame register.
    pub const MAXF = mmio(Address + 0x00000014, 32, packed struct {
        MAXFLEN: u16, // bit offset: 0 desc: MAXIMUM FRAME LENGTH. This field resets to the value 0x0600, which represents a maximum receive frame of 1536 octets. An untagged maximum size Ethernet frame is 1518 octets. A tagged frame adds four octets for a total of 1522 octets. If a shorter maximum length restriction is desired, program this 16-bit field.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 PHY Support register.
    pub const SUPP = mmio(Address + 0x00000018, 32, packed struct {
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SPEED: bool, // bit offset: 8 desc: This bit configures the Reduced MII logic for the current operating speed. When set, 100 Mbps mode is selected. When cleared, 10 Mbps mode is selected.
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 Test register.
    pub const TEST = mmio(Address + 0x0000001c, 32, packed struct {
        SCPQ: bool, // bit offset: 0 desc: SHORTCUT PAUSE QUANTA. This bit reduces the effective PAUSE quanta from 64 byte-times to 1 byte-time.
        TESTPAUSE: bool, // bit offset: 1 desc: This bit causes the MAC Control sublayer to inhibit transmissions, just as if a PAUSE Receive Control frame with a nonzero pause time parameter was received.
        TESTBP: bool, // bit offset: 2 desc: TEST BACKPRESSURE. Setting this bit will cause the MAC to assert backpressure on the link. Backpressure causes preamble to be transmitted, raising carrier sense. A transmit packet from the system will be sent during backpressure.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 MII Mgmt Configuration register.
    pub const MCFG = mmio(Address + 0x00000020, 32, packed struct {
        SCANINC: bool, // bit offset: 0 desc: SCAN INCREMENT. Set this bit to cause the MII Management hardware to perform read cycles across a range of PHYs. When set, the MII Management hardware will perform read cycles from address 1 through the value set in PHY ADDRESS[4:0]. Clear this bit to allow continuous reads of the same PHY.
        SUPPPREAMBLE: bool, // bit offset: 1 desc: SUPPRESS PREAMBLE. Set this bit to cause the MII Management hardware to perform read/write cycles without the 32-bit preamble field. Clear this bit to cause normal cycles to be performed. Some PHYs support suppressed preamble.
        CLOCKSEL: u4, // bit offset: 2 desc: CLOCK SELECT. This field is used by the clock divide logic in creating the MII Management Clock (MDC) which IEEE 802.3u defines to be no faster than 2.5 MHz. Some PHYs support clock rates up to 12.5 MHz, however. The AHB bus clock (HCLK) is divided by the specified amount. Refer to Table 160 below for the definition of values for this field.
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RESETMIIMGMT: bool, // bit offset: 15 desc: RESET MII MGMT. This bit resets the MII Management hardware.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 MII Mgmt Command register.
    pub const MCMD = mmio(Address + 0x00000024, 32, packed struct {
        READ: bool, // bit offset: 0 desc: This bit causes the MII Management hardware to perform a single Read cycle. The Read data is returned in Register MRDD (MII Mgmt Read Data).
        SCAN: bool, // bit offset: 1 desc: This bit causes the MII Management hardware to perform Read cycles continuously. This is useful for monitoring Link Fail for example.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 MII Mgmt Address register.
    pub const MADR = mmio(Address + 0x00000028, 32, packed struct {
        REGADDR: u5, // bit offset: 0 desc: REGISTER ADDRESS. This field represents the 5-bit Register Address field of Mgmt cycles. Up to 32 registers can be accessed.
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PHYADDR: u5, // bit offset: 8 desc: PHY ADDRESS. This field represents the 5-bit PHY Address field of Mgmt cycles. Up to 31 PHYs can be addressed (0 is reserved).
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 MII Mgmt Write Data register.
    pub const MWTD = mmio(Address + 0x0000002c, 32, packed struct {
        WRITEDATA: u16, // bit offset: 0 desc: WRITE DATA. When written, an MII Mgmt write cycle is performed using the 16-bit data and the pre-configured PHY and Register addresses from the MII Mgmt Address register (MADR).
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 MII Mgmt Read Data register.
    pub const MRDD = mmio(Address + 0x00000030, 32, packed struct {
        READDATA: u16, // bit offset: 0 desc: READ DATA. Following an MII Mgmt Read Cycle, the 16-bit data can be read from this location.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 52 MII Mgmt Indicators register.
    pub const MIND = mmio(Address + 0x00000034, 32, packed struct {
        BUSY: bool, // bit offset: 0 desc: When 1 is returned - indicates MII Mgmt is currently performing an MII Mgmt Read or Write cycle.
        SCANNING: bool, // bit offset: 1 desc: When 1 is returned - indicates a scan operation (continuous MII Mgmt Read cycles) is in progress.
        NOTVALID: bool, // bit offset: 2 desc: When 1 is returned - indicates MII Mgmt Read cycle has not completed and the Read Data is not yet valid.
        MIILINKFAIL: bool, // bit offset: 3 desc: When 1 is returned - indicates that an MII Mgmt link fail has occurred.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 64 Station Address 0 register.
    pub const SA0 = mmio(Address + 0x00000040, 32, packed struct {
        SADDR2: u8, // bit offset: 0 desc: STATION ADDRESS, 2nd octet. This field holds the second octet of the station address.
        SADDR1: u8, // bit offset: 8 desc: STATION ADDRESS, 1st octet. This field holds the first octet of the station address.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 68 Station Address 1 register.
    pub const SA1 = mmio(Address + 0x00000044, 32, packed struct {
        SADDR4: u8, // bit offset: 0 desc: STATION ADDRESS, 4th octet. This field holds the fourth octet of the station address.
        SADDR3: u8, // bit offset: 8 desc: STATION ADDRESS, 3rd octet. This field holds the third octet of the station address.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 72 Station Address 2 register.
    pub const SA2 = mmio(Address + 0x00000048, 32, packed struct {
        SADDR6: u8, // bit offset: 0 desc: STATION ADDRESS, 6th octet. This field holds the sixth octet of the station address.
        SADDR5: u8, // bit offset: 8 desc: STATION ADDRESS, 5th octet. This field holds the fifth octet of the station address.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 256 Command register.
    pub const COMMAND = mmio(Address + 0x00000100, 32, packed struct {
        RXENABLE: bool, // bit offset: 0 desc: Enable receive.
        TXENABLE: bool, // bit offset: 1 desc: Enable transmit.
        reserved1: u1 = 0,
        REGRESET: bool, // bit offset: 3 desc: When a 1 is written, all datapaths and the host registers are reset. The MAC needs to be reset separately.
        TXRESET: bool, // bit offset: 4 desc: When a 1 is written, the transmit datapath is reset.
        RXRESET: bool, // bit offset: 5 desc: When a 1 is written, the receive datapath is reset.
        PASSRUNTFRAME: bool, // bit offset: 6 desc: When set to 1 , passes runt frames s1maller than 64 bytes to memory unless they have a CRC error. If 0 runt frames are filtered out.
        PASSRXFILTER: bool, // bit offset: 7 desc: When set to 1 , disables receive filtering i.e. all frames received are written to memory.
        TXFLOWCONTROL: bool, // bit offset: 8 desc: Enable IEEE 802.3 / clause 31 flow control sending pause frames in full duplex and continuous preamble in half duplex.
        RMII: bool, // bit offset: 9 desc: When set to 1 , RMII mode is selected; if 0, MII mode is selected.
        FULLDUPLEX: bool, // bit offset: 10 desc: When set to 1 , indicates full duplex operation.
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 260 Status register.
    pub const STATUS = mmio(Address + 0x00000104, 32, packed struct {
        RXSTATUS: bool, // bit offset: 0 desc: If 1, the receive channel is active. If 0, the receive channel is inactive.
        TXSTATUS: bool, // bit offset: 1 desc: If 1, the transmit channel is active. If 0, the transmit channel is inactive.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 264 Receive descriptor base address register.
    pub const RXDESCRIPTOR = mmio(Address + 0x00000108, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXDESCRIPTOR: u30, // bit offset: 2 desc: MSBs of receive descriptor base address.
    });
    // byte offset: 268 Receive status base address register.
    pub const RXSTATUS = mmio(Address + 0x0000010c, 32, packed struct {
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        RXSTATUS: u29, // bit offset: 3 desc: MSBs of receive status base address.
    });
    // byte offset: 272 Receive number of descriptors register.
    pub const RXDESCRIPTORNUMBER = mmio(Address + 0x00000110, 32, packed struct {
        RXDESCRIPTORN: u16, // bit offset: 0 desc: RxDescriptorNumber. Number of descriptors in the descriptor array for which RxDescriptor is the base address. The number of descriptors is minus one encoded.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 276 Receive produce index register.
    pub const RXPRODUCEINDEX = mmio(Address + 0x00000114, 32, packed struct {
        RXPRODUCEIX: u16, // bit offset: 0 desc: Index of the descriptor that is going to be filled next by the receive datapath.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 280 Receive consume index register.
    pub const RXCONSUMEINDEX = mmio(Address + 0x00000118, 32, packed struct {
        RXCONSUMEIX: u16, // bit offset: 0 desc: Index of the descriptor that is going to be processed next by the receive
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 284 Transmit descriptor base address register.
    pub const TXDESCRIPTOR = mmio(Address + 0x0000011c, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TXD: u30, // bit offset: 2 desc: TxDescriptor. MSBs of transmit descriptor base address.
    });
    // byte offset: 288 Transmit status base address register.
    pub const TXSTATUS = mmio(Address + 0x00000120, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        TXSTAT: u30, // bit offset: 2 desc: TxStatus. MSBs of transmit status base address.
    });
    // byte offset: 292 Transmit number of descriptors register.
    pub const TXDESCRIPTORNUMBER = mmio(Address + 0x00000124, 32, packed struct {
        TXDN: u16, // bit offset: 0 desc: TxDescriptorNumber. Number of descriptors in the descriptor array for which TxDescriptor is the base address. The register is minus one encoded.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 296 Transmit produce index register.
    pub const TXPRODUCEINDEX = mmio(Address + 0x00000128, 32, packed struct {
        TXPI: u16, // bit offset: 0 desc: TxProduceIndex. Index of the descriptor that is going to be filled next by the transmit software driver.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 300 Transmit consume index register.
    pub const TXCONSUMEINDEX = mmio(Address + 0x0000012c, 32, packed struct {
        TXCI: u16, // bit offset: 0 desc: TxConsumeIndex. Index of the descriptor that is going to be transmitted next by the transmit datapath.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 344 Transmit status vector 0 register.
    pub const TSV0 = mmio(Address + 0x00000158, 32, packed struct {
        CRCERR: bool, // bit offset: 0 desc: CRC error. The attached CRC in the packet did not match the internally generated CRC.
        LCE: bool, // bit offset: 1 desc: Length check error. Indicates the frame length field does not match the actual number of data items and is not a type field.
        LOR: bool, // bit offset: 2 desc: Length out of range. Indicates that frame type/length field was larger than 1500 bytes. The EMAC doesn't distinguish the frame type and frame length, so, e.g. when the IP(0x8000) or ARP(0x0806) packets are received, it compares the frame type with the max length and gives the "Length out of range" error. In fact, this bit is not an error indication, but simply a statement by the chip regarding the status of the received frame.
        DONE: bool, // bit offset: 3 desc: Transmission of packet was completed.
        MULTICAST: bool, // bit offset: 4 desc: Packet's destination was a multicast address.
        BROADCAST: bool, // bit offset: 5 desc: Packet's destination was a broadcast address.
        PACKETDEFER: bool, // bit offset: 6 desc: Packet was deferred for at least one attempt, but less than an excessive defer.
        EXDF: bool, // bit offset: 7 desc: Excessive Defer. Packet was deferred in excess of 6071 nibble times in 100 Mbps or 24287 bit times in 10 Mbps mode.
        EXCOL: bool, // bit offset: 8 desc: Excessive Collision. Packet was aborted due to exceeding of maximum allowed number of collisions.
        LCOL: bool, // bit offset: 9 desc: Late Collision. Collision occurred beyond collision window, 512 bit times.
        GIANT: bool, // bit offset: 10 desc: Byte count in frame was greater than can be represented in the transmit byte count field in TSV1.
        UNDERRUN: bool, // bit offset: 11 desc: Host side caused buffer underrun.
        TOTALBYTES: u16, // bit offset: 12 desc: The total number of bytes transferred including collided attempts.
        CONTROLFRAME: bool, // bit offset: 28 desc: The frame was a control frame.
        PAUSE: bool, // bit offset: 29 desc: The frame was a control frame with a valid PAUSE opcode.
        BACKPRESSURE: bool, // bit offset: 30 desc: Carrier-sense method backpressure was previously applied.
        VLAN: bool, // bit offset: 31 desc: Frame's length/type field contained 0x8100 which is the VLAN protocol identifier.
    });
    // byte offset: 348 Transmit status vector 1 register.
    pub const TSV1 = mmio(Address + 0x0000015c, 32, packed struct {
        TBC: u16, // bit offset: 0 desc: Transmit byte count. The total number of bytes in the frame, not counting the collided bytes.
        TCC: u4, // bit offset: 16 desc: Transmit collision count. Number of collisions the current packet incurred during transmission attempts. The maximum number of collisions (16) cannot be represented.
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 352 Receive status vector register.
    pub const RSV = mmio(Address + 0x00000160, 32, packed struct {
        RBC: u16, // bit offset: 0 desc: Received byte count. Indicates length of received frame.
        PPI: bool, // bit offset: 16 desc: Packet previously ignored. Indicates that a packet was dropped.
        RXDVSEEN: bool, // bit offset: 17 desc: RXDV event previously seen. Indicates that the last receive event seen was not long enough to be a valid packet.
        CESEEN: bool, // bit offset: 18 desc: Carrier event previously seen. Indicates that at some time since the last receive statistics, a carrier event was detected.
        RCV: bool, // bit offset: 19 desc: Receive code violation. Indicates that received PHY data does not represent a valid receive code.
        CRCERR: bool, // bit offset: 20 desc: CRC error. The attached CRC in the packet did not match the internally generated CRC.
        LCERR: bool, // bit offset: 21 desc: Length check error. Indicates the frame length field does not match the actual number of data items and is not a type field.
        LOR: bool, // bit offset: 22 desc: Length out of range. Indicates that frame type/length field was larger than 1518 bytes. The EMAC doesn't distinguish the frame type and frame length, so, e.g. when the IP(0x8000) or ARP(0x0806) packets are received, it compares the frame type with the max length and gives the "Length out of range" error. In fact, this bit is not an error indication, but simply a statement by the chip regarding the status of the received frame.
        ROK: bool, // bit offset: 23 desc: Receive OK. The packet had valid CRC and no symbol errors.
        MULTICAST: bool, // bit offset: 24 desc: The packet destination was a multicast address.
        BROADCAST: bool, // bit offset: 25 desc: The packet destination was a broadcast address.
        DRIBBLENIBBLE: bool, // bit offset: 26 desc: Indicates that after the end of packet another 1-7 bits were received. A single nibble, called dribble nibble, is formed but not sent out.
        CONTROLFRAME: bool, // bit offset: 27 desc: The frame was a control frame.
        PAUSE: bool, // bit offset: 28 desc: The frame was a control frame with a valid PAUSE opcode.
        UO: bool, // bit offset: 29 desc: Unsupported Opcode. The current frame was recognized as a Control Frame but contains an unknown opcode.
        VLAN: bool, // bit offset: 30 desc: Frame's length/type field contained 0x8100 which is the VLAN protocol identifier.
        padding1: u1 = 0,
    });
    // byte offset: 368 Flow control counter register.
    pub const FLOWCONTROLCOUNTER = mmio(Address + 0x00000170, 32, packed struct {
        MC: u16, // bit offset: 0 desc: MirrorCounter. In full duplex mode the MirrorCounter specifies the number of cycles before re-issuing the Pause control frame.
        PT: u16, // bit offset: 16 desc: PauseTimer. In full-duplex mode the PauseTimer specifies the value that is inserted into the pause timer field of a pause flow control frame. In half duplex mode the PauseTimer specifies the number of backpressure cycles.
    });
    // byte offset: 372 Flow control status register.
    pub const FLOWCONTROLSTATUS = mmio(Address + 0x00000174, 32, packed struct {
        MCC: u16, // bit offset: 0 desc: MirrorCounterCurrent. In full duplex mode this register represents the current value of the datapath's mirror counter which counts up to the value specified by the MirrorCounter field in the FlowControlCounter register. In half duplex mode the register counts until it reaches the value of the PauseTimer bits in the FlowControlCounter register.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 512 Receive filter control register.
    pub const RXFILTERCTRL = mmio(Address + 0x00000200, 32, packed struct {
        AUE: bool, // bit offset: 0 desc: AcceptUnicastEn. When set to 1, all unicast frames are accepted.
        ABE: bool, // bit offset: 1 desc: AcceptBroadcastEn. When set to 1, all broadcast frames are accepted.
        AME: bool, // bit offset: 2 desc: AcceptMulticastEn. When set to 1, all multicast frames are accepted.
        AUHE: bool, // bit offset: 3 desc: AcceptUnicastHashEn. When set to 1, unicast frames that pass the imperfect hash filter are accepted.
        AMHE: bool, // bit offset: 4 desc: AcceptMulticastHashEn. When set to 1, multicast frames that pass the imperfect hash filter are accepted.
        APE: bool, // bit offset: 5 desc: AcceptPerfectEn. When set to 1, the frames with a destination address identical to the station address are accepted.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        MPEW: bool, // bit offset: 12 desc: MagicPacketEnWoL. When set to 1, the result of the magic packet filter will generate a WoL interrupt when there is a match.
        RFEW: bool, // bit offset: 13 desc: RxFilterEnWoL. When set to 1, the result of the perfect address matching filter and the imperfect hash filter will generate a WoL interrupt when there is a match.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 516 Receive filter WoL status register.
    pub const RXFILTERWOLSTATUS = mmio(Address + 0x00000204, 32, packed struct {
        AUW: bool, // bit offset: 0 desc: AcceptUnicastWoL. When the value is 1, a unicast frames caused WoL.
        ABW: bool, // bit offset: 1 desc: AcceptBroadcastWoL. When the value is 1, a broadcast frame caused WoL.
        AMW: bool, // bit offset: 2 desc: AcceptMulticastWoL. When the value is 1, a multicast frame caused WoL.
        AUHW: bool, // bit offset: 3 desc: AcceptUnicastHashWoL. When the value is 1, a unicast frame that passes the imperfect hash filter caused WoL.
        AMHW: bool, // bit offset: 4 desc: AcceptMulticastHashWoL. When the value is 1, a multicast frame that passes the imperfect hash filter caused WoL.
        APW: bool, // bit offset: 5 desc: AcceptPerfectWoL. When the value is 1, the perfect address matching filter caused WoL.
        reserved1: u1 = 0,
        RFW: bool, // bit offset: 7 desc: RxFilterWoL. When the value is 1, the receive filter caused WoL.
        MPW: bool, // bit offset: 8 desc: MagicPacketWoL. When the value is 1, the magic packet filter caused WoL.
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 520 Receive filter WoL clear register.
    pub const RXFILTERWOLCLEAR = mmio(Address + 0x00000208, 32, packed struct {
        AUWCLR: bool, // bit offset: 0 desc: AcceptUnicastWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        ABWCLR: bool, // bit offset: 1 desc: AcceptBroadcastWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        AMWCLR: bool, // bit offset: 2 desc: AcceptMulticastWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        AUHWCLR: bool, // bit offset: 3 desc: AcceptUnicastHashWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        AMHWCLR: bool, // bit offset: 4 desc: AcceptMulticastHashWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        APWCLR: bool, // bit offset: 5 desc: AcceptPerfectWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        reserved1: u1 = 0,
        RFWCLR: bool, // bit offset: 7 desc: RxFilterWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        MPWCLR: bool, // bit offset: 8 desc: MagicPacketWoLClr. When a 1 is written, the corresponding status bit in the RxFilterWoLStatus register is cleared.
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 528 Hash filter table LSBs register.
    pub const HASHFILTERL = mmio(Address + 0x00000210, 32, packed struct {
        HFL: u32, // bit offset: 0 desc: HashFilterL. Bits 31:0 of the imperfect filter hash table for receive filtering.
    });
    // byte offset: 532 Hash filter table MSBs register.
    pub const HASHFILTERH = mmio(Address + 0x00000214, 32, packed struct {
        HFH: u32, // bit offset: 0 desc: Bits 63:32 of the imperfect filter hash table for receive filtering.
    });
    // byte offset: 4064 Interrupt status register.
    pub const INTSTATUS = mmio(Address + 0x00000fe0, 32, packed struct {
        RXOVERRUNINT: bool, // bit offset: 0 desc: Interrupt set on a fatal overrun error in the receive queue. The fatal interrupt should be resolved by a Rx soft-reset. The bit is not set when there is a nonfatal overrun error.
        RXERRORINT: bool, // bit offset: 1 desc: Interrupt trigger on receive errors: AlignmentError, RangeError, LengthError, SymbolError, CRCError or NoDescriptor or Overrun.
        RXFINISHEDINT: bool, // bit offset: 2 desc: Interrupt triggered when all receive descriptors have been processed i.e. on the transition to the situation where ProduceIndex == ConsumeIndex.
        RXDONEINT: bool, // bit offset: 3 desc: Interrupt triggered when a receive descriptor has been processed while the Interrupt bit in the Control field of the descriptor was set.
        TXUNDERRUNINT: bool, // bit offset: 4 desc: Interrupt set on a fatal underrun error in the transmit queue. The fatal interrupt should be resolved by a Tx soft-reset. The bit is not set when there is a nonfatal underrun error.
        TXERRORINT: bool, // bit offset: 5 desc: Interrupt trigger on transmit errors: LateCollision, ExcessiveCollision and ExcessiveDefer, NoDescriptor or Underrun.
        TXFINISHEDINT: bool, // bit offset: 6 desc: Interrupt triggered when all transmit descriptors have been processed i.e. on the transition to the situation where ProduceIndex == ConsumeIndex.
        TXDONEINT: bool, // bit offset: 7 desc: Interrupt triggered when a descriptor has been transmitted while the Interrupt bit in the Control field of the descriptor was set.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SOFTINT: bool, // bit offset: 12 desc: Interrupt triggered by software writing a 1 to the SoftIntSet bit in the IntSet register.
        WAKEUPINT: bool, // bit offset: 13 desc: Interrupt triggered by a Wake-up event detected by the receive filter.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4068 Interrupt enable register.
    pub const INTENABLE = mmio(Address + 0x00000fe4, 32, packed struct {
        RXOVERRUNINTEN: bool, // bit offset: 0 desc: Enable for interrupt trigger on receive buffer overrun or descriptor underrun situations.
        RXERRORINTEN: bool, // bit offset: 1 desc: Enable for interrupt trigger on receive errors.
        RXFINISHEDINTEN: bool, // bit offset: 2 desc: Enable for interrupt triggered when all receive descriptors have been processed i.e. on the transition to the situation where ProduceIndex == ConsumeIndex.
        RXDONEINTEN: bool, // bit offset: 3 desc: Enable for interrupt triggered when a receive descriptor has been processed while the Interrupt bit in the Control field of the descriptor was set.
        TXUNDERRUNINTEN: bool, // bit offset: 4 desc: Enable for interrupt trigger on transmit buffer or descriptor underrun situations.
        TXERRORINTEN: bool, // bit offset: 5 desc: Enable for interrupt trigger on transmit errors.
        TXFINISHEDINTEN: bool, // bit offset: 6 desc: Enable for interrupt triggered when all transmit descriptors have been processed i.e. on the transition to the situation where ProduceIndex == ConsumeIndex.
        TXDONEINTEN: bool, // bit offset: 7 desc: Enable for interrupt triggered when a descriptor has been transmitted while the Interrupt bit in the Control field of the descriptor was set.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SOFTINTEN: bool, // bit offset: 12 desc: Enable for interrupt triggered by the SoftInt bit in the IntStatus register, caused by software writing a 1 to the SoftIntSet bit in the IntSet register.
        WAKEUPINTEN: bool, // bit offset: 13 desc: Enable for interrupt triggered by a Wake-up event detected by the receive filter.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4072 Interrupt clear register.
    pub const INTCLEAR = mmio(Address + 0x00000fe8, 32, packed struct {
        RXOVERRUNINTCLR: bool, // bit offset: 0 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        RXERRORINTCLR: bool, // bit offset: 1 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        RXFINISHEDINTCLR: bool, // bit offset: 2 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        RXDONEINTCLR: bool, // bit offset: 3 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        TXUNDERRUNINTCLR: bool, // bit offset: 4 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        TXERRORINTCLR: bool, // bit offset: 5 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        TXFINISHEDINTCLR: bool, // bit offset: 6 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        TXDONEINTCLR: bool, // bit offset: 7 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SOFTINTCLR: bool, // bit offset: 12 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        WAKEUPINTCLR: bool, // bit offset: 13 desc: Writing a 1 clears the corresponding status bit in interrupt status register IntStatus.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4076 Interrupt set register.
    pub const INTSET = mmio(Address + 0x00000fec, 32, packed struct {
        RXOVERRUNINTSET: bool, // bit offset: 0 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        RXERRORINTSET: bool, // bit offset: 1 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        RXFINISHEDINTSET: bool, // bit offset: 2 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        RXDONEINTSET: bool, // bit offset: 3 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        TXUNDERRUNINTSET: bool, // bit offset: 4 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        TXERRORINTSET: bool, // bit offset: 5 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        TXFINISHEDINTSET: bool, // bit offset: 6 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        TXDONEINTSET: bool, // bit offset: 7 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SOFTINTSET: bool, // bit offset: 12 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        WAKEUPINTSET: bool, // bit offset: 13 desc: Writing a 1 to one sets the corresponding status bit in interrupt status register IntStatus.
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4084 Power-down register.
    pub const POWERDOWN = mmio(Address + 0x00000ff4, 32, packed struct {
        reserved31: u1 = 0,
        reserved30: u1 = 0,
        reserved29: u1 = 0,
        reserved28: u1 = 0,
        reserved27: u1 = 0,
        reserved26: u1 = 0,
        reserved25: u1 = 0,
        reserved24: u1 = 0,
        reserved23: u1 = 0,
        reserved22: u1 = 0,
        reserved21: u1 = 0,
        reserved20: u1 = 0,
        reserved19: u1 = 0,
        reserved18: u1 = 0,
        reserved17: u1 = 0,
        reserved16: u1 = 0,
        reserved15: u1 = 0,
        reserved14: u1 = 0,
        reserved13: u1 = 0,
        reserved12: u1 = 0,
        reserved11: u1 = 0,
        reserved10: u1 = 0,
        reserved9: u1 = 0,
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        PD: bool, // bit offset: 31 desc: PowerDownMACAHB. If true, all AHB accesses will return a read/write error, except accesses to the Power-Down register.
    });
};
pub const GPDMA = extern struct {
    pub const Address: u32 = 0x50004000;
    // byte offset: 0 DMA Interrupt Status Register
    pub const INTSTAT = mmio(Address + 0x00000000, 32, packed struct {
        INTSTAT0: bool, // bit offset: 0 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        INTSTAT1: bool, // bit offset: 1 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        INTSTAT2: bool, // bit offset: 2 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        INTSTAT3: bool, // bit offset: 3 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        INTSTAT4: bool, // bit offset: 4 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        INTSTAT5: bool, // bit offset: 5 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        INTSTAT6: bool, // bit offset: 6 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        INTSTAT7: bool, // bit offset: 7 desc: Status of DMA channel interrupts after masking. Each bit represents one channel: 0 - the corresponding channel has no active interrupt request. 1 - the corresponding channel does have an active interrupt request.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4 DMA Interrupt Terminal Count Request Status Register
    pub const INTTCSTAT = mmio(Address + 0x00000004, 32, packed struct {
        INTTCSTAT0: bool, // bit offset: 0 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        INTTCSTAT1: bool, // bit offset: 1 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        INTTCSTAT2: bool, // bit offset: 2 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        INTTCSTAT3: bool, // bit offset: 3 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        INTTCSTAT4: bool, // bit offset: 4 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        INTTCSTAT5: bool, // bit offset: 5 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        INTTCSTAT6: bool, // bit offset: 6 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        INTTCSTAT7: bool, // bit offset: 7 desc: Terminal count interrupt request status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 8 DMA Interrupt Terminal Count Request Clear Register
    pub const INTTCCLEAR = mmio(Address + 0x00000008, 32, packed struct {
        INTTCCLEAR0: bool, // bit offset: 0 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        INTTCCLEAR1: bool, // bit offset: 1 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        INTTCCLEAR2: bool, // bit offset: 2 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        INTTCCLEAR3: bool, // bit offset: 3 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        INTTCCLEAR4: bool, // bit offset: 4 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        INTTCCLEAR5: bool, // bit offset: 5 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        INTTCCLEAR6: bool, // bit offset: 6 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        INTTCCLEAR7: bool, // bit offset: 7 desc: Allows clearing the Terminal count interrupt request (IntTCStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel terminal count interrupt.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 12 DMA Interrupt Error Status Register
    pub const INTERRSTAT = mmio(Address + 0x0000000c, 32, packed struct {
        INTERRSTAT0: bool, // bit offset: 0 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        INTERRSTAT1: bool, // bit offset: 1 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        INTERRSTAT2: bool, // bit offset: 2 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        INTERRSTAT3: bool, // bit offset: 3 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        INTERRSTAT4: bool, // bit offset: 4 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        INTERRSTAT5: bool, // bit offset: 5 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        INTERRSTAT6: bool, // bit offset: 6 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        INTERRSTAT7: bool, // bit offset: 7 desc: Interrupt error status for DMA channels. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 16 DMA Interrupt Error Clear Register
    pub const INTERRCLR = mmio(Address + 0x00000010, 32, packed struct {
        INTERRCLR0: bool, // bit offset: 0 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        INTERRCLR1: bool, // bit offset: 1 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        INTERRCLR2: bool, // bit offset: 2 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        INTERRCLR3: bool, // bit offset: 3 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        INTERRCLR4: bool, // bit offset: 4 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        INTERRCLR5: bool, // bit offset: 5 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        INTERRCLR6: bool, // bit offset: 6 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        INTERRCLR7: bool, // bit offset: 7 desc: Writing a 1 clears the error interrupt request (IntErrStat) for DMA channels. Each bit represents one channel: 0 - writing 0 has no effect. 1 - clears the corresponding channel error interrupt.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 20 DMA Raw Interrupt Terminal Count Status Register
    pub const RAWINTTCSTAT = mmio(Address + 0x00000014, 32, packed struct {
        RAWINTTCSTAT0: bool, // bit offset: 0 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        RAWINTTCSTAT1: bool, // bit offset: 1 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        RAWINTTCSTAT2: bool, // bit offset: 2 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        RAWINTTCSTAT3: bool, // bit offset: 3 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        RAWINTTCSTAT4: bool, // bit offset: 4 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        RAWINTTCSTAT5: bool, // bit offset: 5 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        RAWINTTCSTAT6: bool, // bit offset: 6 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        RAWINTTCSTAT7: bool, // bit offset: 7 desc: Status of the terminal count interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active terminal count interrupt request. 1 - the corresponding channel does have an active terminal count interrupt request.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 24 DMA Raw Error Interrupt Status Register
    pub const RAWINTERRSTAT = mmio(Address + 0x00000018, 32, packed struct {
        RAWINTERRSTAT0: bool, // bit offset: 0 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        RAWINTERRSTAT1: bool, // bit offset: 1 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        RAWINTERRSTAT2: bool, // bit offset: 2 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        RAWINTERRSTAT3: bool, // bit offset: 3 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        RAWINTERRSTAT4: bool, // bit offset: 4 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        RAWINTERRSTAT5: bool, // bit offset: 5 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        RAWINTERRSTAT6: bool, // bit offset: 6 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        RAWINTERRSTAT7: bool, // bit offset: 7 desc: Status of the error interrupt for DMA channels prior to masking. Each bit represents one channel: 0 - the corresponding channel has no active error interrupt request. 1 - the corresponding channel does have an active error interrupt request.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 28 DMA Enabled Channel Register
    pub const ENBLDCHNS = mmio(Address + 0x0000001c, 32, packed struct {
        ENABLEDCHANNELS0: bool, // bit offset: 0 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        ENABLEDCHANNELS1: bool, // bit offset: 1 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        ENABLEDCHANNELS2: bool, // bit offset: 2 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        ENABLEDCHANNELS3: bool, // bit offset: 3 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        ENABLEDCHANNELS4: bool, // bit offset: 4 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        ENABLEDCHANNELS5: bool, // bit offset: 5 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        ENABLEDCHANNELS6: bool, // bit offset: 6 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        ENABLEDCHANNELS7: bool, // bit offset: 7 desc: Enable status for DMA channels. Each bit represents one channel: 0 - DMA channel is disabled. 1 - DMA channel is enabled.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 32 DMA Software Burst Request Register
    pub const SOFTBREQ = mmio(Address + 0x00000020, 32, packed struct {
        SOFTBREQ0: bool, // bit offset: 0 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ1: bool, // bit offset: 1 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ2: bool, // bit offset: 2 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ3: bool, // bit offset: 3 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ4: bool, // bit offset: 4 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ5: bool, // bit offset: 5 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ6: bool, // bit offset: 6 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ7: bool, // bit offset: 7 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ8: bool, // bit offset: 8 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ9: bool, // bit offset: 9 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ10: bool, // bit offset: 10 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ11: bool, // bit offset: 11 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ12: bool, // bit offset: 12 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ13: bool, // bit offset: 13 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ14: bool, // bit offset: 14 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        SOFTBREQ15: bool, // bit offset: 15 desc: Software burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral Description (refer to Table 672 for peripheral hardware connections to the DMA controller): 0 - writing 0 has no effect. 1 - writing 1 generates a DMA burst request for the corresponding request line.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 36 DMA Software Single Request Register
    pub const SOFTSREQ = mmio(Address + 0x00000024, 32, packed struct {
        SOFTSREQ0: bool, // bit offset: 0 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ1: bool, // bit offset: 1 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ2: bool, // bit offset: 2 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ3: bool, // bit offset: 3 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ4: bool, // bit offset: 4 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ5: bool, // bit offset: 5 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ6: bool, // bit offset: 6 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ7: bool, // bit offset: 7 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ8: bool, // bit offset: 8 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ9: bool, // bit offset: 9 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ10: bool, // bit offset: 10 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ11: bool, // bit offset: 11 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ12: bool, // bit offset: 12 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ13: bool, // bit offset: 13 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ14: bool, // bit offset: 14 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        SOFTSREQ15: bool, // bit offset: 15 desc: Software single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA single transfer request for the corresponding request line.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 40 DMA Software Last Burst Request Register
    pub const SOFTLBREQ = mmio(Address + 0x00000028, 32, packed struct {
        SOFTLBREQ0: bool, // bit offset: 0 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ1: bool, // bit offset: 1 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ2: bool, // bit offset: 2 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ3: bool, // bit offset: 3 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ4: bool, // bit offset: 4 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ5: bool, // bit offset: 5 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ6: bool, // bit offset: 6 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ7: bool, // bit offset: 7 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ8: bool, // bit offset: 8 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ9: bool, // bit offset: 9 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ10: bool, // bit offset: 10 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ11: bool, // bit offset: 11 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ12: bool, // bit offset: 12 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ13: bool, // bit offset: 13 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ14: bool, // bit offset: 14 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        SOFTLBREQ15: bool, // bit offset: 15 desc: Software last burst request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last burst request for the corresponding request line.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 44 DMA Software Last Single Request Register
    pub const SOFTLSREQ = mmio(Address + 0x0000002c, 32, packed struct {
        SOFTLSREQ0: bool, // bit offset: 0 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ1: bool, // bit offset: 1 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ2: bool, // bit offset: 2 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ3: bool, // bit offset: 3 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ4: bool, // bit offset: 4 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ5: bool, // bit offset: 5 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ6: bool, // bit offset: 6 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ7: bool, // bit offset: 7 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ8: bool, // bit offset: 8 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ9: bool, // bit offset: 9 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ10: bool, // bit offset: 10 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ11: bool, // bit offset: 11 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ12: bool, // bit offset: 12 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ13: bool, // bit offset: 13 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ14: bool, // bit offset: 14 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        SOFTLSREQ15: bool, // bit offset: 15 desc: Software last single transfer request flags for each of 16 possible sources. Each bit represents one DMA request line or peripheral function: 0 - writing 0 has no effect. 1 - writing 1 generates a DMA last single transfer request for the corresponding request line.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 48 DMA Configuration Register
    pub const CONFIG = mmio(Address + 0x00000030, 32, packed struct {
        E: bool, // bit offset: 0 desc: DMA Controller enable: 0 = disabled (default). Disabling the DMA Controller reduces power consumption. 1 = enabled.
        M: bool, // bit offset: 1 desc: AHB Master endianness configuration: 0 = little-endian mode (default). 1 = big-endian mode.
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 52 DMA Synchronization Register
    pub const SYNC = mmio(Address + 0x00000034, 32, packed struct {
        DMACSYNC0: bool, // bit offset: 0 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC1: bool, // bit offset: 1 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC2: bool, // bit offset: 2 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC3: bool, // bit offset: 3 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC4: bool, // bit offset: 4 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC5: bool, // bit offset: 5 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC6: bool, // bit offset: 6 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC7: bool, // bit offset: 7 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC8: bool, // bit offset: 8 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC9: bool, // bit offset: 9 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC10: bool, // bit offset: 10 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC11: bool, // bit offset: 11 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC12: bool, // bit offset: 12 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC13: bool, // bit offset: 13 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC14: bool, // bit offset: 14 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        DMACSYNC15: bool, // bit offset: 15 desc: Controls the synchronization logic for DMA request signals. Each bit represents one set of DMA request lines as described in the preceding text: 0 - synchronization logic for the corresponding DMA request signals are enabled. 1 - synchronization logic for the corresponding DMA request signals are disabled.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 256 DMA Channel 0 Source Address Register
    pub const SRCADDR0 = mmio(Address + 0x00000100, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 260 DMA Channel 0 Destination Address Register
    pub const DESTADDR0 = mmio(Address + 0x00000104, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 264 DMA Channel 0 Linked List Item Register
    pub const LLI0 = mmio(Address + 0x00000108, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 268 DMA Channel 0 Control Register
    pub const CONTROL0 = mmio(Address + 0x0000010c, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 272 DMA Channel 0 Configuration Register[1]
    pub const CONFIG0 = mmio(Address + 0x00000110, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
    // byte offset: 288 DMA Channel 0 Source Address Register
    pub const SRCADDR1 = mmio(Address + 0x00000120, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 292 DMA Channel 0 Destination Address Register
    pub const DESTADDR1 = mmio(Address + 0x00000124, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 296 DMA Channel 0 Linked List Item Register
    pub const LLI1 = mmio(Address + 0x00000128, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 300 DMA Channel 0 Control Register
    pub const CONTROL1 = mmio(Address + 0x0000012c, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 304 DMA Channel 0 Configuration Register[1]
    pub const CONFIG1 = mmio(Address + 0x00000130, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
    // byte offset: 320 DMA Channel 0 Source Address Register
    pub const SRCADDR2 = mmio(Address + 0x00000140, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 324 DMA Channel 0 Destination Address Register
    pub const DESTADDR2 = mmio(Address + 0x00000144, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 328 DMA Channel 0 Linked List Item Register
    pub const LLI2 = mmio(Address + 0x00000148, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 332 DMA Channel 0 Control Register
    pub const CONTROL2 = mmio(Address + 0x0000014c, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 336 DMA Channel 0 Configuration Register[1]
    pub const CONFIG2 = mmio(Address + 0x00000150, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
    // byte offset: 352 DMA Channel 0 Source Address Register
    pub const SRCADDR3 = mmio(Address + 0x00000160, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 356 DMA Channel 0 Destination Address Register
    pub const DESTADDR3 = mmio(Address + 0x00000164, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 360 DMA Channel 0 Linked List Item Register
    pub const LLI3 = mmio(Address + 0x00000168, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 364 DMA Channel 0 Control Register
    pub const CONTROL3 = mmio(Address + 0x0000016c, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 368 DMA Channel 0 Configuration Register[1]
    pub const CONFIG3 = mmio(Address + 0x00000170, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
    // byte offset: 384 DMA Channel 0 Source Address Register
    pub const SRCADDR4 = mmio(Address + 0x00000180, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 388 DMA Channel 0 Destination Address Register
    pub const DESTADDR4 = mmio(Address + 0x00000184, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 392 DMA Channel 0 Linked List Item Register
    pub const LLI4 = mmio(Address + 0x00000188, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 396 DMA Channel 0 Control Register
    pub const CONTROL4 = mmio(Address + 0x0000018c, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 400 DMA Channel 0 Configuration Register[1]
    pub const CONFIG4 = mmio(Address + 0x00000190, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
    // byte offset: 416 DMA Channel 0 Source Address Register
    pub const SRCADDR5 = mmio(Address + 0x000001a0, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 420 DMA Channel 0 Destination Address Register
    pub const DESTADDR5 = mmio(Address + 0x000001a4, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 424 DMA Channel 0 Linked List Item Register
    pub const LLI5 = mmio(Address + 0x000001a8, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 428 DMA Channel 0 Control Register
    pub const CONTROL5 = mmio(Address + 0x000001ac, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 432 DMA Channel 0 Configuration Register[1]
    pub const CONFIG5 = mmio(Address + 0x000001b0, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
    // byte offset: 448 DMA Channel 0 Source Address Register
    pub const SRCADDR6 = mmio(Address + 0x000001c0, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 452 DMA Channel 0 Destination Address Register
    pub const DESTADDR6 = mmio(Address + 0x000001c4, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 456 DMA Channel 0 Linked List Item Register
    pub const LLI6 = mmio(Address + 0x000001c8, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 460 DMA Channel 0 Control Register
    pub const CONTROL6 = mmio(Address + 0x000001cc, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 464 DMA Channel 0 Configuration Register[1]
    pub const CONFIG6 = mmio(Address + 0x000001d0, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
    // byte offset: 480 DMA Channel 0 Source Address Register
    pub const SRCADDR7 = mmio(Address + 0x000001e0, 32, packed struct {
        SRCADDR: u32, // bit offset: 0 desc: DMA source address. Reading this register will return the current source address.
    });
    // byte offset: 484 DMA Channel 0 Destination Address Register
    pub const DESTADDR7 = mmio(Address + 0x000001e4, 32, packed struct {
        DESTADDR: u32, // bit offset: 0 desc: DMA Destination address. Reading this register will return the current destination address.
    });
    // byte offset: 488 DMA Channel 0 Linked List Item Register
    pub const LLI7 = mmio(Address + 0x000001e8, 32, packed struct {
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        LLI: u30, // bit offset: 2 desc: Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0.
    });
    // byte offset: 492 DMA Channel 0 Control Register
    pub const CONTROL7 = mmio(Address + 0x000001ec, 32, packed struct {
        TRANSFERSIZE: u12, // bit offset: 0 desc: Transfer size. This field sets the size of the transfer when the DMA controller is the flow controller, in which case the value must be set before the channel is enabled. Transfer size is updated as data transfers are completed. A read from this field indicates the number of transfers completed on the destination bus. Reading the register when the channel is active does not give useful information because by the time that the software has processed the value read, the channel might have progressed. It is intended to be used only when a channel is enabled and then disabled. The transfer size value is not used if a peripheral is the flow controller.
        SBSIZE: u3, // bit offset: 12 desc: Source burst size. Indicates the number of transfers that make up a source burst. This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the source peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        DBSIZE: u3, // bit offset: 15 desc: Destination burst size. Indicates the number of transfers that make up a destination burst transfer request. This value must be set to the burst size of the destination peripheral or, if the destination is memory, to the memory boundary size. The burst size is the amount of data that is transferred when the DMACBREQ signal goes active in the destination peripheral. 000 - 1 001 - 4 010 - 8 011 - 16 100 - 32 101 - 64 110 - 128 111 - 256
        SWIDTH: u3, // bit offset: 18 desc: Source transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        DWIDTH: u3, // bit offset: 21 desc: Destination transfer width. The source and destination widths can be different from each other. The hardware automatically packs and unpacks the data as required. 000 - Byte (8-bit) 001 - Halfword (16-bit) 010 - Word (32-bit) 011 to 111 - Reserved
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        SI: bool, // bit offset: 26 desc: Source increment: 0 - the source address is not incremented after each transfer. 1 - the source address is incremented after each transfer.
        DI: bool, // bit offset: 27 desc: Destination increment: 0 - the destination address is not incremented after each transfer. 1 - the destination address is incremented after each transfer.
        PROT1: bool, // bit offset: 28 desc: This is provided to the peripheral during a DMA bus access and indicates that the access is in user mode or privileged mode. This information is not used in the LPC178x/177x. 0 - access is in user mode. 1 - access is in privileged mode.
        PROT2: bool, // bit offset: 29 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is bufferable or not bufferable. This information is not used in the LPC178x/177x. 0 - access is not bufferable. 1 - access is bufferable.
        PROT3: bool, // bit offset: 30 desc: This is provided to the peripheral during a DMA bus access and indicates to the peripheral that the access is cacheable or not cacheable. This information is not used in the LPC178x/177x. 0 - access is not cacheable. 1 - access is cacheable.
        I: bool, // bit offset: 31 desc: Terminal count interrupt enable bit. 0 - the terminal count interrupt is disabled. 1 - the terminal count interrupt is enabled.
    });
    // byte offset: 496 DMA Channel 0 Configuration Register[1]
    pub const CONFIG7 = mmio(Address + 0x000001f0, 32, packed struct {
        E: bool, // bit offset: 0 desc: Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled. 1 = channel enabled. The Channel Enable bit status can also be found by reading the DMACEnbldChns Register. A channel is enabled by setting this bit. A channel can be disabled by clearing the Enable bit. This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled. Any data in the FIFO of the relevant channel is lost. Restarting the channel by setting the Channel Enable bit has unpredictable effects, the channel must be fully re-initialized. The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached, the DMA transfer is completed, or if a channel error is encountered. If a channel must be disabled without losing data in the FIFO, the Halt bit must be set so that further DMA requests are ignored. The Active bit must then be polled until it reaches 0, indicating that there is no data left in the FIFO. Finally, the Channel Enable bit can be cleared.
        SRCPERIPHERAL: u5, // bit offset: 1 desc: Source peripheral. This value selects the DMA source request peripheral. This field is ignored if the source of the transfer is from memory. See Table 672 for peripheral identification.
        DESTPERIPHERAL: u5, // bit offset: 6 desc: Destination peripheral. This value selects the DMA destination request peripheral. This field is ignored if the destination of the transfer is to memory. See Table 672 for peripheral identification.
        TRANSFERTYPE: u3, // bit offset: 11 desc: This value indicates the type of transfer and specifies the flow controller. The transfer type can be memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral. Flow can be controlled by the DMA controller, the source peripheral, or the destination peripheral. Refer to Table 694 for the encoding of this field.
        IE: bool, // bit offset: 14 desc: Interrupt error mask. When cleared, this bit masks out the error interrupt of the relevant channel.
        ITC: bool, // bit offset: 15 desc: Terminal count interrupt mask. When cleared, this bit masks out the terminal count interrupt of the relevant channel.
        L: bool, // bit offset: 16 desc: Lock. When set, this bit enables locked transfers. This information is not used in the LPC178x/177x.
        A: bool, // bit offset: 17 desc: Active: 0 = there is no data in the FIFO of the channel. 1 = the channel FIFO has data. This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel. This is a read-only bit.
        H: bool, // bit offset: 18 desc: Halt: 0 = enable DMA requests. 1 = ignore further source DMA requests. The contents of the channel FIFO are drained. This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.
    });
};
pub const USB = extern struct {
    pub const Address: u32 = 0x50008000;
    // byte offset: 220 USB Receive Packet Length
    pub const RXPLEN = mmio(Address + 0x000000dc, 32, packed struct {
        PKT_LNGTH: u10, // bit offset: 0 desc: The remaining number of bytes to be read from the currently selected endpoint's buffer. When this field decrements to 0, the RxENDPKT bit will be set in USBDevIntSt.
        DV: bool, // bit offset: 10 desc: Data valid. This bit is useful for isochronous endpoints. Non-isochronous endpoints do not raise an interrupt when an erroneous data packet is received. But invalid data packet can be produced with a bus reset. For isochronous endpoints, data transfer will happen even if an erroneous packet is received. In this case DV bit will not be set for the packet.
        PKT_RDY: bool, // bit offset: 11 desc: The PKT_LNGTH field is valid and the packet is ready for reading.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 256 OTG Interrupt Status
    pub const INTST = mmio(Address + 0x00000100, 32, packed struct {
        TMR: bool, // bit offset: 0 desc: Timer time-out.
        REMOVE_PU: bool, // bit offset: 1 desc: Remove pull-up. This bit is set by hardware to indicate that software needs to disable the D+ pull-up resistor.
        HNP_FAILURE: bool, // bit offset: 2 desc: HNP failed. This bit is set by hardware to indicate that the HNP switching has failed.
        HNP_SUCCESS: bool, // bit offset: 3 desc: HNP succeeded. This bit is set by hardware to indicate that the HNP switching has succeeded.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 260 OTG Interrupt Enable
    pub const INTEN = mmio(Address + 0x00000104, 32, packed struct {
        TMR_EN: bool, // bit offset: 0 desc: 1 = enable the corresponding bit in the IntSt register.
        REMOVE_PU_EN: bool, // bit offset: 1 desc: 1 = enable the corresponding bit in the IntSt register.
        HNP_FAILURE_EN: bool, // bit offset: 2 desc: 1 = enable the corresponding bit in the IntSt register.
        HNP_SUCCES_EN: bool, // bit offset: 3 desc: 1 = enable the corresponding bit in the IntSt register.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 264 OTG Interrupt Set
    pub const INTSET = mmio(Address + 0x00000108, 32, packed struct {
        TMR_SET: bool, // bit offset: 0 desc: 0 = no effect. 1 = set the corresponding bit in the IntSt register.
        REMOVE_PU_SET: bool, // bit offset: 1 desc: 0 = no effect. 1 = set the corresponding bit in the IntSt register.
        HNP_FAILURE_SET: bool, // bit offset: 2 desc: 0 = no effect. 1 = set the corresponding bit in the IntSt register.
        HNP_SUCCES_SET: bool, // bit offset: 3 desc: 0 = no effect. 1 = set the corresponding bit in the IntSt register.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 268 OTG Interrupt Clear
    pub const INTCLR = mmio(Address + 0x0000010c, 32, packed struct {
        TMR_CLR: bool, // bit offset: 0 desc: 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
        REMOVE_PU_CLR: bool, // bit offset: 1 desc: 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
        HNP_FAILURE_CLR: bool, // bit offset: 2 desc: 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
        HNP_SUCCES_CLR: bool, // bit offset: 3 desc: 0 = no effect. 1 = clear the corresponding bit in the IntSt register.
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 272 OTG Status and Control and USB port select
    pub const STCTRL = mmio(Address + 0x00000110, 32, packed struct {
        PORT_FUNC: u2, // bit offset: 0 desc: Controls connection of USB functions (see Figure 51). Bit 0 is set or cleared by hardware when B_HNP_TRACK or A_HNP_TRACK is set and HNP succeeds. See Section 14.9. 00: U1 = device (OTG), U2 = host 01: U1 = host (OTG), U2 = host 10: Reserved 11: U1 = host, U2 = device In a device-only configuration, the following values are allowed: 00: U1 = device. The USB device controller signals are mapped to the U1 port: USB_CONNECT1, USB_UP_LED1, USB_D+1, USB_D-1. 11: U2 = device. The USB device controller signals are mapped to the U2 port: USB_CONNECT2, USB_UP_LED2, USB_D+2, USB_D-2.
        TMR_SCALE: u2, // bit offset: 2 desc: Timer scale selection. This field determines the duration of each timer count. 00: 10 ms (100 KHz) 01: 100 ms (10 KHz) 10: 1000 ms (1 KHz) 11: Reserved
        TMR_MODE: bool, // bit offset: 4 desc: Timer mode selection. 0: monoshot 1: free running
        TMR_EN: bool, // bit offset: 5 desc: Timer enable. When set, TMR_CNT increments. When cleared, TMR_CNT is reset to 0.
        TMR_RST: bool, // bit offset: 6 desc: Timer reset. Writing one to this bit resets TMR_CNT to 0. This provides a single bit control for the software to restart the timer when the timer is enabled.
        reserved1: u1 = 0,
        B_HNP_TRACK: bool, // bit offset: 8 desc: Enable HNP tracking for B-device (peripheral), see Section 14.9. Hardware clears this bit when HNP_SUCCESS or HNP_FAILURE is set.
        A_HNP_TRACK: bool, // bit offset: 9 desc: Enable HNP tracking for A-device (host), see Section 14.9. Hardware clears this bit when HNP_SUCCESS or HNP_FAILURE is set.
        PU_REMOVED: bool, // bit offset: 10 desc: When the B-device changes its role from peripheral to host, software sets this bit when it removes the D+ pull-up, see Section 14.9. Hardware clears this bit when HNP_SUCCESS or HNP_FAILURE is set.
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        TMR_CNT: u16, // bit offset: 16 desc: Current timer count value.
    });
    // byte offset: 276 OTG Timer
    pub const TMR = mmio(Address + 0x00000114, 32, packed struct {
        TIMEOUT_CNT: u16, // bit offset: 0 desc: The TMR interrupt is set when TMR_CNT reaches this value.
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 512 USB Device Interrupt Status
    pub const DEVINTST = mmio(Address + 0x00000200, 32, packed struct {
        FRAME: bool, // bit offset: 0 desc: The frame interrupt occurs every 1 ms. This is used in isochronous packet transfers.
        EP_FAST: bool, // bit offset: 1 desc: Fast endpoint interrupt. If an Endpoint Interrupt Priority register (USBEpIntPri) bit is set, the corresponding endpoint interrupt will be routed to this bit.
        EP_SLOW: bool, // bit offset: 2 desc: Slow endpoints interrupt. If an Endpoint Interrupt Priority Register (USBEpIntPri) bit is not set, the corresponding endpoint interrupt will be routed to this bit.
        DEV_STAT: bool, // bit offset: 3 desc: Set when USB Bus reset, USB suspend change or Connect change event occurs. Refer to Section 13.12.6 Set Device Status (Command: 0xFE, Data: write 1 byte) on page 366.
        CCEMPTY: bool, // bit offset: 4 desc: The command code register (USBCmdCode) is empty (New command can be written).
        CDFULL: bool, // bit offset: 5 desc: Command data register (USBCmdData) is full (Data can be read now).
        RxENDPKT: bool, // bit offset: 6 desc: The current packet in the endpoint buffer is transferred to the CPU.
        TxENDPKT: bool, // bit offset: 7 desc: The number of data bytes transferred to the endpoint buffer equals the number of bytes programmed in the TxPacket length register (USBTxPLen).
        EP_RLZED: bool, // bit offset: 8 desc: Endpoints realized. Set when Realize Endpoint register (USBReEp) or MaxPacketSize register (USBMaxPSize) is updated and the corresponding operation is completed.
        ERR_INT: bool, // bit offset: 9 desc: Error Interrupt. Any bus error interrupt from the USB device. Refer to Section 13.12.9 Read Error Status (Command: 0xFB, Data: read 1 byte) on page 368
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 516 USB Device Interrupt Enable
    pub const DEVINTEN = mmio(Address + 0x00000204, 32, packed struct {
        FRAMEEN: bool, // bit offset: 0 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        EP_FASTEN: bool, // bit offset: 1 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        EP_SLOWEN: bool, // bit offset: 2 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        DEV_STATEN: bool, // bit offset: 3 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        CCEMPTYEN: bool, // bit offset: 4 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        CDFULLEN: bool, // bit offset: 5 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        RxENDPKTEN: bool, // bit offset: 6 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        TxENDPKTEN: bool, // bit offset: 7 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        EP_RLZEDEN: bool, // bit offset: 8 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        ERR_INTEN: bool, // bit offset: 9 desc: 0 = No interrupt is generated. 1 = An interrupt will be generated when the corresponding bit in the Device Interrupt Status (USBDevIntSt) register (Table 261) is set. By default, the interrupt is routed to the USB_INT_REQ_LP interrupt line. Optionally, either the EP_FAST or FRAME interrupt may be routed to the USB_INT_REQ_HP interrupt line by changing the value of USBDevIntPri.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 520 USB Device Interrupt Clear
    pub const DEVINTCLR = mmio(Address + 0x00000208, 32, packed struct {
        FRAMECLR: bool, // bit offset: 0 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        EP_FASTCLR: bool, // bit offset: 1 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        EP_SLOWCLR: bool, // bit offset: 2 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        DEV_STATCLR: bool, // bit offset: 3 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        CCEMPTYCLR: bool, // bit offset: 4 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        CDFULLCLR: bool, // bit offset: 5 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        RxENDPKTCLR: bool, // bit offset: 6 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        TxENDPKTCLR: bool, // bit offset: 7 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        EP_RLZEDCLR: bool, // bit offset: 8 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        ERR_INTCLR: bool, // bit offset: 9 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is cleared.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 524 USB Device Interrupt Set
    pub const DEVINTSET = mmio(Address + 0x0000020c, 32, packed struct {
        FRAMESET: bool, // bit offset: 0 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        EP_FASTSET: bool, // bit offset: 1 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        EP_SLOWSET: bool, // bit offset: 2 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        DEV_STATSET: bool, // bit offset: 3 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        CCEMPTYSET: bool, // bit offset: 4 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        CDFULLSET: bool, // bit offset: 5 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        RxENDPKTSET: bool, // bit offset: 6 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        TxENDPKTSET: bool, // bit offset: 7 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        EP_RLZEDSET: bool, // bit offset: 8 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        ERR_INTSET: bool, // bit offset: 9 desc: 0 = No effect. 1 = The corresponding bit in USBDevIntSt (Section 13.10.3.2) is set.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 528 USB Command Code
    pub const CMDCODE = mmio(Address + 0x00000210, 32, packed struct {
        reserved8: u1 = 0,
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        CMD_PHASE: u8, // bit offset: 8 desc: The command phase:
        CMD_CODE_WDATA: u8, // bit offset: 16 desc: This is a multi-purpose field. When CMD_PHASE is Command or Read, this field contains the code for the command (CMD_CODE). When CMD_PHASE is Write, this field contains the command write data (CMD_WDATA).
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 532 USB Command Data
    pub const CMDDATA = mmio(Address + 0x00000214, 32, packed struct {
        CMD_RDATA: u8, // bit offset: 0 desc: Command Read Data.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 536 USB Receive Data
    pub const RXDATA = mmio(Address + 0x00000218, 32, packed struct {
        RX_DATA: u32, // bit offset: 0 desc: Data received.
    });
    // byte offset: 540 USB Transmit Data
    pub const TXDATA = mmio(Address + 0x0000021c, 32, packed struct {
        TX_DATA: u32, // bit offset: 0 desc: Transmit Data.
    });
    // byte offset: 548 USB Transmit Packet Length
    pub const TXPLEN = mmio(Address + 0x00000224, 32, packed struct {
        PKT_LNGTH: u10, // bit offset: 0 desc: The remaining number of bytes to be written to the selected endpoint buffer. This field is decremented by 4 by hardware after each write to USBTxData. When this field decrements to 0, the TxENDPKT bit will be set in USBDevIntSt.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 552 USB Control
    pub const CTRL = mmio(Address + 0x00000228, 32, packed struct {
        RD_EN: bool, // bit offset: 0 desc: Read mode control. Enables reading data from the OUT endpoint buffer for the endpoint specified in the LOG_ENDPOINT field using the USBRxData register. This bit is cleared by hardware when the last word of the current packet is read from USBRxData.
        WR_EN: bool, // bit offset: 1 desc: Write mode control. Enables writing data to the IN endpoint buffer for the endpoint specified in the LOG_ENDPOINT field using the USBTxData register. This bit is cleared by hardware when the number of bytes in USBTxLen have been sent.
        LOG_ENDPOINT: u4, // bit offset: 2 desc: Logical Endpoint number.
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 556 USB Device Interrupt Priority
    pub const DEVINTPRI = mmio(Address + 0x0000022c, 32, packed struct {
        FRAME: bool, // bit offset: 0 desc: Frame interrupt routing
        EP_FAST: bool, // bit offset: 1 desc: Fast endpoint interrupt routing
        padding30: u1 = 0,
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 560 USB Endpoint Interrupt Status
    pub const EPINTST = mmio(Address + 0x00000230, 32, packed struct {
        EPST0: bool, // bit offset: 0 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST1: bool, // bit offset: 1 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST2: bool, // bit offset: 2 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST3: bool, // bit offset: 3 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST4: bool, // bit offset: 4 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST5: bool, // bit offset: 5 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST6: bool, // bit offset: 6 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST7: bool, // bit offset: 7 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST8: bool, // bit offset: 8 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST9: bool, // bit offset: 9 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST10: bool, // bit offset: 10 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST11: bool, // bit offset: 11 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST12: bool, // bit offset: 12 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST13: bool, // bit offset: 13 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST14: bool, // bit offset: 14 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST15: bool, // bit offset: 15 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST16: bool, // bit offset: 16 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST17: bool, // bit offset: 17 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST18: bool, // bit offset: 18 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST19: bool, // bit offset: 19 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST20: bool, // bit offset: 20 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST21: bool, // bit offset: 21 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST22: bool, // bit offset: 22 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST23: bool, // bit offset: 23 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST24: bool, // bit offset: 24 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST25: bool, // bit offset: 25 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST26: bool, // bit offset: 26 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST27: bool, // bit offset: 27 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST28: bool, // bit offset: 28 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST29: bool, // bit offset: 29 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST30: bool, // bit offset: 30 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
        EPST31: bool, // bit offset: 31 desc: 1 = Endpoint Data Received (bits 0, 2, 4, ..., 30) or Transmitted (bits 1, 3, 5, ..., 31) Interrupt received.
    });
    // byte offset: 564 USB Endpoint Interrupt Enable
    pub const EPINTEN = mmio(Address + 0x00000234, 32, packed struct {
        EPEN0: bool, // bit offset: 0 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN1: bool, // bit offset: 1 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN2: bool, // bit offset: 2 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN3: bool, // bit offset: 3 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN4: bool, // bit offset: 4 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN5: bool, // bit offset: 5 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN6: bool, // bit offset: 6 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN7: bool, // bit offset: 7 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN8: bool, // bit offset: 8 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN9: bool, // bit offset: 9 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN10: bool, // bit offset: 10 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN11: bool, // bit offset: 11 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN12: bool, // bit offset: 12 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN13: bool, // bit offset: 13 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN14: bool, // bit offset: 14 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN15: bool, // bit offset: 15 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN16: bool, // bit offset: 16 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN17: bool, // bit offset: 17 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN18: bool, // bit offset: 18 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN19: bool, // bit offset: 19 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN20: bool, // bit offset: 20 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN21: bool, // bit offset: 21 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN22: bool, // bit offset: 22 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN23: bool, // bit offset: 23 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN24: bool, // bit offset: 24 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN25: bool, // bit offset: 25 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN26: bool, // bit offset: 26 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN27: bool, // bit offset: 27 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN28: bool, // bit offset: 28 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN29: bool, // bit offset: 29 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN30: bool, // bit offset: 30 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
        EPEN31: bool, // bit offset: 31 desc: 0= The corresponding bit in USBDMARSt is set when an interrupt occurs for this endpoint. 1 = The corresponding bit in USBEpIntSt is set when an interrupt occurs for this endpoint. Implies Slave mode for this endpoint.
    });
    // byte offset: 568 USB Endpoint Interrupt Clear
    pub const EPINTCLR = mmio(Address + 0x00000238, 32, packed struct {
        EPCLR0: bool, // bit offset: 0 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR1: bool, // bit offset: 1 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR2: bool, // bit offset: 2 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR3: bool, // bit offset: 3 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR4: bool, // bit offset: 4 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR5: bool, // bit offset: 5 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR6: bool, // bit offset: 6 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR7: bool, // bit offset: 7 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR8: bool, // bit offset: 8 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR9: bool, // bit offset: 9 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR10: bool, // bit offset: 10 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR11: bool, // bit offset: 11 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR12: bool, // bit offset: 12 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR13: bool, // bit offset: 13 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR14: bool, // bit offset: 14 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR15: bool, // bit offset: 15 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR16: bool, // bit offset: 16 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR17: bool, // bit offset: 17 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR18: bool, // bit offset: 18 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR19: bool, // bit offset: 19 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR20: bool, // bit offset: 20 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR21: bool, // bit offset: 21 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR22: bool, // bit offset: 22 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR23: bool, // bit offset: 23 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR24: bool, // bit offset: 24 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR25: bool, // bit offset: 25 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR26: bool, // bit offset: 26 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR27: bool, // bit offset: 27 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR28: bool, // bit offset: 28 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR29: bool, // bit offset: 29 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR30: bool, // bit offset: 30 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
        EPCLR31: bool, // bit offset: 31 desc: 0 = No effect. 1 = Clears the corresponding bit in USBEpIntSt, by executing the SIE Select Endpoint/Clear Interrupt command for this endpoint.
    });
    // byte offset: 572 USB Endpoint Interrupt Set
    pub const EPINTSET = mmio(Address + 0x0000023c, 32, packed struct {
        EPSET0: bool, // bit offset: 0 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET1: bool, // bit offset: 1 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET2: bool, // bit offset: 2 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET3: bool, // bit offset: 3 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET4: bool, // bit offset: 4 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET5: bool, // bit offset: 5 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET6: bool, // bit offset: 6 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET7: bool, // bit offset: 7 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET8: bool, // bit offset: 8 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET9: bool, // bit offset: 9 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET10: bool, // bit offset: 10 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET11: bool, // bit offset: 11 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET12: bool, // bit offset: 12 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET13: bool, // bit offset: 13 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET14: bool, // bit offset: 14 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET15: bool, // bit offset: 15 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET16: bool, // bit offset: 16 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET17: bool, // bit offset: 17 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET18: bool, // bit offset: 18 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET19: bool, // bit offset: 19 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET20: bool, // bit offset: 20 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET21: bool, // bit offset: 21 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET22: bool, // bit offset: 22 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET23: bool, // bit offset: 23 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET24: bool, // bit offset: 24 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET25: bool, // bit offset: 25 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET26: bool, // bit offset: 26 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET27: bool, // bit offset: 27 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET28: bool, // bit offset: 28 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET29: bool, // bit offset: 29 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET30: bool, // bit offset: 30 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
        EPSET31: bool, // bit offset: 31 desc: 0 = No effect. 1 = Sets the corresponding bit in USBEpIntSt.
    });
    // byte offset: 576 USB Endpoint Priority
    pub const EPINTPRI = mmio(Address + 0x00000240, 32, packed struct {
        EPPRI0: bool, // bit offset: 0 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI1: bool, // bit offset: 1 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI2: bool, // bit offset: 2 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI3: bool, // bit offset: 3 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI4: bool, // bit offset: 4 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI5: bool, // bit offset: 5 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI6: bool, // bit offset: 6 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI7: bool, // bit offset: 7 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI8: bool, // bit offset: 8 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI9: bool, // bit offset: 9 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI10: bool, // bit offset: 10 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI11: bool, // bit offset: 11 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI12: bool, // bit offset: 12 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI13: bool, // bit offset: 13 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI14: bool, // bit offset: 14 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI15: bool, // bit offset: 15 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI16: bool, // bit offset: 16 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI17: bool, // bit offset: 17 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI18: bool, // bit offset: 18 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI19: bool, // bit offset: 19 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI20: bool, // bit offset: 20 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI21: bool, // bit offset: 21 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI22: bool, // bit offset: 22 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI23: bool, // bit offset: 23 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI24: bool, // bit offset: 24 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI25: bool, // bit offset: 25 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI26: bool, // bit offset: 26 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI27: bool, // bit offset: 27 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI28: bool, // bit offset: 28 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI29: bool, // bit offset: 29 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI30: bool, // bit offset: 30 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
        EPPRI31: bool, // bit offset: 31 desc: 0 = The corresponding interrupt is routed to the EP_SLOW bit of USBDevIntSt 1 = The corresponding interrupt is routed to the EP_FAST bit of USBDevIntSt
    });
    // byte offset: 580 USB Realize Endpoint
    pub const REEP = mmio(Address + 0x00000244, 32, packed struct {
        EPR0: bool, // bit offset: 0 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR1: bool, // bit offset: 1 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR2: bool, // bit offset: 2 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR3: bool, // bit offset: 3 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR4: bool, // bit offset: 4 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR5: bool, // bit offset: 5 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR6: bool, // bit offset: 6 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR7: bool, // bit offset: 7 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR8: bool, // bit offset: 8 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR9: bool, // bit offset: 9 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR10: bool, // bit offset: 10 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR11: bool, // bit offset: 11 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR12: bool, // bit offset: 12 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR13: bool, // bit offset: 13 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR14: bool, // bit offset: 14 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR15: bool, // bit offset: 15 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR16: bool, // bit offset: 16 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR17: bool, // bit offset: 17 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR18: bool, // bit offset: 18 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR19: bool, // bit offset: 19 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR20: bool, // bit offset: 20 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR21: bool, // bit offset: 21 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR22: bool, // bit offset: 22 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR23: bool, // bit offset: 23 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR24: bool, // bit offset: 24 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR25: bool, // bit offset: 25 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR26: bool, // bit offset: 26 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR27: bool, // bit offset: 27 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR28: bool, // bit offset: 28 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR29: bool, // bit offset: 29 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR30: bool, // bit offset: 30 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
        EPR31: bool, // bit offset: 31 desc: 0 = Endpoint EPxx is not realized. 1 = Endpoint EPxx is realized.
    });
    // byte offset: 584 USB Endpoint Index
    pub const EPIND = mmio(Address + 0x00000248, 32, packed struct {
        PHY_EP: u5, // bit offset: 0 desc: Physical endpoint number (0-31)
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 588 USB MaxPacketSize
    pub const MAXPSIZE = mmio(Address + 0x0000024c, 32, packed struct {
        MPS: u10, // bit offset: 0 desc: The maximum packet size value.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 592 USB DMA Request Status
    pub const DMARST = mmio(Address + 0x00000250, 32, packed struct {
        EPRST0: bool, // bit offset: 0 desc: Control endpoint OUT (DMA cannot be enabled for this endpoint and EP0 bit must be 0).
        EPRST1: bool, // bit offset: 1 desc: Control endpoint IN (DMA cannot be enabled for this endpoint and EP1 bit must be 0).
        EPRST2: bool, // bit offset: 2 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST3: bool, // bit offset: 3 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST4: bool, // bit offset: 4 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST5: bool, // bit offset: 5 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST6: bool, // bit offset: 6 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST7: bool, // bit offset: 7 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST8: bool, // bit offset: 8 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST9: bool, // bit offset: 9 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST10: bool, // bit offset: 10 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST11: bool, // bit offset: 11 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST12: bool, // bit offset: 12 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST13: bool, // bit offset: 13 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST14: bool, // bit offset: 14 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST15: bool, // bit offset: 15 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST16: bool, // bit offset: 16 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST17: bool, // bit offset: 17 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST18: bool, // bit offset: 18 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST19: bool, // bit offset: 19 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST20: bool, // bit offset: 20 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST21: bool, // bit offset: 21 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST22: bool, // bit offset: 22 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST23: bool, // bit offset: 23 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST24: bool, // bit offset: 24 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST25: bool, // bit offset: 25 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST26: bool, // bit offset: 26 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST27: bool, // bit offset: 27 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST28: bool, // bit offset: 28 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST29: bool, // bit offset: 29 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST30: bool, // bit offset: 30 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
        EPRST31: bool, // bit offset: 31 desc: Endpoint xx (2 <= xx <= 31) DMA request. 0 = DMA not requested by endpoint xx. 1 = DMA requested by endpoint xx.
    });
    // byte offset: 596 USB DMA Request Clear
    pub const DMARCLR = mmio(Address + 0x00000254, 32, packed struct {
        EPRCLR0: bool, // bit offset: 0 desc: Control endpoint OUT (DMA cannot be enabled for this endpoint and the EP0 bit must be 0).
        EPRCLR1: bool, // bit offset: 1 desc: Control endpoint IN (DMA cannot be enabled for this endpoint and the EP1 bit must be 0).
        EPRCLR2: bool, // bit offset: 2 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR3: bool, // bit offset: 3 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR4: bool, // bit offset: 4 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR5: bool, // bit offset: 5 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR6: bool, // bit offset: 6 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR7: bool, // bit offset: 7 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR8: bool, // bit offset: 8 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR9: bool, // bit offset: 9 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR10: bool, // bit offset: 10 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR11: bool, // bit offset: 11 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR12: bool, // bit offset: 12 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR13: bool, // bit offset: 13 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR14: bool, // bit offset: 14 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR15: bool, // bit offset: 15 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR16: bool, // bit offset: 16 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR17: bool, // bit offset: 17 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR18: bool, // bit offset: 18 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR19: bool, // bit offset: 19 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR20: bool, // bit offset: 20 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR21: bool, // bit offset: 21 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR22: bool, // bit offset: 22 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR23: bool, // bit offset: 23 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR24: bool, // bit offset: 24 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR25: bool, // bit offset: 25 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR26: bool, // bit offset: 26 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR27: bool, // bit offset: 27 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR28: bool, // bit offset: 28 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR29: bool, // bit offset: 29 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR30: bool, // bit offset: 30 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
        EPRCLR31: bool, // bit offset: 31 desc: Clear the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Clear the corresponding bit in USBDMARSt.
    });
    // byte offset: 600 USB DMA Request Set
    pub const DMARSET = mmio(Address + 0x00000258, 32, packed struct {
        EPRSET0: bool, // bit offset: 0 desc: Control endpoint OUT (DMA cannot be enabled for this endpoint and the EP0 bit must be 0).
        EPRSET1: bool, // bit offset: 1 desc: Control endpoint IN (DMA cannot be enabled for this endpoint and the EP1 bit must be 0).
        EPRSET2: bool, // bit offset: 2 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET3: bool, // bit offset: 3 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET4: bool, // bit offset: 4 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET5: bool, // bit offset: 5 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET6: bool, // bit offset: 6 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET7: bool, // bit offset: 7 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET8: bool, // bit offset: 8 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET9: bool, // bit offset: 9 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET10: bool, // bit offset: 10 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET11: bool, // bit offset: 11 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET12: bool, // bit offset: 12 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET13: bool, // bit offset: 13 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET14: bool, // bit offset: 14 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET15: bool, // bit offset: 15 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET16: bool, // bit offset: 16 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET17: bool, // bit offset: 17 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET18: bool, // bit offset: 18 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET19: bool, // bit offset: 19 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET20: bool, // bit offset: 20 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET21: bool, // bit offset: 21 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET22: bool, // bit offset: 22 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET23: bool, // bit offset: 23 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET24: bool, // bit offset: 24 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET25: bool, // bit offset: 25 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET26: bool, // bit offset: 26 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET27: bool, // bit offset: 27 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET28: bool, // bit offset: 28 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET29: bool, // bit offset: 29 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET30: bool, // bit offset: 30 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
        EPRSET31: bool, // bit offset: 31 desc: Set the endpoint xx (2 <= xx <= 31) DMA request. 0 = No effect 1 = Set the corresponding bit in USBDMARSt.
    });
    // byte offset: 640 USB UDCA Head
    pub const UDCAH = mmio(Address + 0x00000280, 32, packed struct {
        reserved7: u1 = 0,
        reserved6: u1 = 0,
        reserved5: u1 = 0,
        reserved4: u1 = 0,
        reserved3: u1 = 0,
        reserved2: u1 = 0,
        reserved1: u1 = 0,
        UDCA_ADDR: u25, // bit offset: 7 desc: Start address of the UDCA.
    });
    // byte offset: 644 USB Endpoint DMA Status
    pub const EPDMAST = mmio(Address + 0x00000284, 32, packed struct {
        EP_DMA_ST0: bool, // bit offset: 0 desc: Control endpoint OUT (DMA cannot be enabled for this endpoint and the EP0_DMA_ENABLE bit must be 0).
        EP_DMA_ST1: bool, // bit offset: 1 desc: Control endpoint IN (DMA cannot be enabled for this endpoint and the EP1_DMA_ENABLE bit must be 0).
        EP_DMA_ST2: bool, // bit offset: 2 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST3: bool, // bit offset: 3 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST4: bool, // bit offset: 4 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST5: bool, // bit offset: 5 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST6: bool, // bit offset: 6 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST7: bool, // bit offset: 7 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST8: bool, // bit offset: 8 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST9: bool, // bit offset: 9 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST10: bool, // bit offset: 10 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST11: bool, // bit offset: 11 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST12: bool, // bit offset: 12 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST13: bool, // bit offset: 13 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST14: bool, // bit offset: 14 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST15: bool, // bit offset: 15 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST16: bool, // bit offset: 16 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST17: bool, // bit offset: 17 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST18: bool, // bit offset: 18 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST19: bool, // bit offset: 19 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST20: bool, // bit offset: 20 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST21: bool, // bit offset: 21 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST22: bool, // bit offset: 22 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST23: bool, // bit offset: 23 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST24: bool, // bit offset: 24 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST25: bool, // bit offset: 25 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST26: bool, // bit offset: 26 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST27: bool, // bit offset: 27 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST28: bool, // bit offset: 28 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST29: bool, // bit offset: 29 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST30: bool, // bit offset: 30 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
        EP_DMA_ST31: bool, // bit offset: 31 desc: Endpoint xx (2 <= xx <= 31) DMA enabled bit. 0 = The DMA for endpoint EPxx is disabled. 1 = The DMA for endpoint EPxx is enabled.
    });
    // byte offset: 648 USB Endpoint DMA Enable
    pub const EPDMAEN = mmio(Address + 0x00000288, 32, packed struct {
        EP_DMA_EN0: bool, // bit offset: 0 desc: Control endpoint OUT (DMA cannot be enabled for this endpoint and the EP0_DMA_ENABLE bit value must be 0).
        EP_DMA_EN1: bool, // bit offset: 1 desc: Control endpoint IN (DMA cannot be enabled for this endpoint and the EP1_DMA_ENABLE bit must be 0).
        EP_DMA_EN: u30, // bit offset: 2 desc: Endpoint xx(2 <= xx <= 31) DMA enable control bit. 0 = No effect. 1 = Enable the DMA operation for endpoint EPxx.
    });
    // byte offset: 652 USB Endpoint DMA Disable
    pub const EPDMADIS = mmio(Address + 0x0000028c, 32, packed struct {
        EP_DMA_DIS0: bool, // bit offset: 0 desc: Control endpoint OUT (DMA cannot be enabled for this endpoint and the EP0_DMA_DISABLE bit value must be 0).
        EP_DMA_DIS1: bool, // bit offset: 1 desc: Control endpoint IN (DMA cannot be enabled for this endpoint and the EP1_DMA_DISABLE bit value must be 0).
        EP_DMA_DIS2: bool, // bit offset: 2 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS3: bool, // bit offset: 3 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS4: bool, // bit offset: 4 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS5: bool, // bit offset: 5 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS6: bool, // bit offset: 6 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS7: bool, // bit offset: 7 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS8: bool, // bit offset: 8 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS9: bool, // bit offset: 9 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS10: bool, // bit offset: 10 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS11: bool, // bit offset: 11 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS12: bool, // bit offset: 12 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS13: bool, // bit offset: 13 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS14: bool, // bit offset: 14 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS15: bool, // bit offset: 15 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS16: bool, // bit offset: 16 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS17: bool, // bit offset: 17 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS18: bool, // bit offset: 18 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS19: bool, // bit offset: 19 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS20: bool, // bit offset: 20 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS21: bool, // bit offset: 21 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS22: bool, // bit offset: 22 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS23: bool, // bit offset: 23 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS24: bool, // bit offset: 24 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS25: bool, // bit offset: 25 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS26: bool, // bit offset: 26 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS27: bool, // bit offset: 27 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS28: bool, // bit offset: 28 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS29: bool, // bit offset: 29 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS30: bool, // bit offset: 30 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
        EP_DMA_DIS31: bool, // bit offset: 31 desc: Endpoint xx (2 <= xx <= 31) DMA disable control bit. 0 = No effect. 1 = Disable the DMA operation for endpoint EPxx.
    });
    // byte offset: 656 USB DMA Interrupt Status
    pub const DMAINTST = mmio(Address + 0x00000290, 32, packed struct {
        EOT: bool, // bit offset: 0 desc: End of Transfer Interrupt bit.
        NDDR: bool, // bit offset: 1 desc: New DD Request Interrupt bit.
        ERR: bool, // bit offset: 2 desc: System Error Interrupt bit.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 660 USB DMA Interrupt Enable
    pub const DMAINTEN = mmio(Address + 0x00000294, 32, packed struct {
        EOT: bool, // bit offset: 0 desc: End of Transfer Interrupt enable bit.
        NDDR: bool, // bit offset: 1 desc: New DD Request Interrupt enable bit.
        ERR: bool, // bit offset: 2 desc: System Error Interrupt enable bit.
        padding29: u1 = 0,
        padding28: u1 = 0,
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 672 USB End of Transfer Interrupt Status
    pub const EOTINTST = mmio(Address + 0x000002a0, 32, packed struct {
        EPTXINTST0: bool, // bit offset: 0 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST1: bool, // bit offset: 1 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST2: bool, // bit offset: 2 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST3: bool, // bit offset: 3 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST4: bool, // bit offset: 4 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST5: bool, // bit offset: 5 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST6: bool, // bit offset: 6 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST7: bool, // bit offset: 7 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST8: bool, // bit offset: 8 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST9: bool, // bit offset: 9 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST10: bool, // bit offset: 10 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST11: bool, // bit offset: 11 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST12: bool, // bit offset: 12 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST13: bool, // bit offset: 13 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST14: bool, // bit offset: 14 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST15: bool, // bit offset: 15 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST16: bool, // bit offset: 16 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST17: bool, // bit offset: 17 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST18: bool, // bit offset: 18 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST19: bool, // bit offset: 19 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST20: bool, // bit offset: 20 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST21: bool, // bit offset: 21 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST22: bool, // bit offset: 22 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST23: bool, // bit offset: 23 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST24: bool, // bit offset: 24 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST25: bool, // bit offset: 25 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST26: bool, // bit offset: 26 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST27: bool, // bit offset: 27 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST28: bool, // bit offset: 28 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST29: bool, // bit offset: 29 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST30: bool, // bit offset: 30 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
        EPTXINTST31: bool, // bit offset: 31 desc: Endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = There is no End of Transfer interrupt request for endpoint xx. 1 = There is an End of Transfer Interrupt request for endpoint xx.
    });
    // byte offset: 676 USB End of Transfer Interrupt Clear
    pub const EOTINTCLR = mmio(Address + 0x000002a4, 32, packed struct {
        EPTXINTCLR0: bool, // bit offset: 0 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR1: bool, // bit offset: 1 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR2: bool, // bit offset: 2 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR3: bool, // bit offset: 3 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR4: bool, // bit offset: 4 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR5: bool, // bit offset: 5 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR6: bool, // bit offset: 6 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR7: bool, // bit offset: 7 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR8: bool, // bit offset: 8 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR9: bool, // bit offset: 9 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR10: bool, // bit offset: 10 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR11: bool, // bit offset: 11 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR12: bool, // bit offset: 12 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR13: bool, // bit offset: 13 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR14: bool, // bit offset: 14 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR15: bool, // bit offset: 15 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR16: bool, // bit offset: 16 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR17: bool, // bit offset: 17 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR18: bool, // bit offset: 18 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR19: bool, // bit offset: 19 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR20: bool, // bit offset: 20 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR21: bool, // bit offset: 21 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR22: bool, // bit offset: 22 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR23: bool, // bit offset: 23 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR24: bool, // bit offset: 24 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR25: bool, // bit offset: 25 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR26: bool, // bit offset: 26 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR27: bool, // bit offset: 27 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR28: bool, // bit offset: 28 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR29: bool, // bit offset: 29 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR30: bool, // bit offset: 30 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTCLR31: bool, // bit offset: 31 desc: Clear endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Clear the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
    });
    // byte offset: 680 USB End of Transfer Interrupt Set
    pub const EOTINTSET = mmio(Address + 0x000002a8, 32, packed struct {
        EPTXINTSET0: bool, // bit offset: 0 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET1: bool, // bit offset: 1 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET2: bool, // bit offset: 2 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET3: bool, // bit offset: 3 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET4: bool, // bit offset: 4 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET5: bool, // bit offset: 5 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET6: bool, // bit offset: 6 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET7: bool, // bit offset: 7 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET8: bool, // bit offset: 8 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET9: bool, // bit offset: 9 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET10: bool, // bit offset: 10 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET11: bool, // bit offset: 11 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET12: bool, // bit offset: 12 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET13: bool, // bit offset: 13 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET14: bool, // bit offset: 14 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET15: bool, // bit offset: 15 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET16: bool, // bit offset: 16 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET17: bool, // bit offset: 17 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET18: bool, // bit offset: 18 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET19: bool, // bit offset: 19 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET20: bool, // bit offset: 20 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET21: bool, // bit offset: 21 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET22: bool, // bit offset: 22 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET23: bool, // bit offset: 23 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET24: bool, // bit offset: 24 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET25: bool, // bit offset: 25 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET26: bool, // bit offset: 26 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET27: bool, // bit offset: 27 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET28: bool, // bit offset: 28 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET29: bool, // bit offset: 29 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET30: bool, // bit offset: 30 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
        EPTXINTSET31: bool, // bit offset: 31 desc: Set endpoint xx (2 <= xx <= 31) End of Transfer Interrupt request. 0 = No effect. 1 = Set the EPxx End of Transfer Interrupt request in the USBEoTIntSt register.
    });
    // byte offset: 684 USB New DD Request Interrupt Status
    pub const NDDRINTST = mmio(Address + 0x000002ac, 32, packed struct {
        EPNDDINTST0: bool, // bit offset: 0 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST1: bool, // bit offset: 1 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST2: bool, // bit offset: 2 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST3: bool, // bit offset: 3 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST4: bool, // bit offset: 4 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST5: bool, // bit offset: 5 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST6: bool, // bit offset: 6 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST7: bool, // bit offset: 7 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST8: bool, // bit offset: 8 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST9: bool, // bit offset: 9 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST10: bool, // bit offset: 10 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST11: bool, // bit offset: 11 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST12: bool, // bit offset: 12 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST13: bool, // bit offset: 13 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST14: bool, // bit offset: 14 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST15: bool, // bit offset: 15 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST16: bool, // bit offset: 16 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST17: bool, // bit offset: 17 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST18: bool, // bit offset: 18 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST19: bool, // bit offset: 19 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST20: bool, // bit offset: 20 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST21: bool, // bit offset: 21 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST22: bool, // bit offset: 22 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST23: bool, // bit offset: 23 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST24: bool, // bit offset: 24 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST25: bool, // bit offset: 25 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST26: bool, // bit offset: 26 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST27: bool, // bit offset: 27 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST28: bool, // bit offset: 28 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST29: bool, // bit offset: 29 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST30: bool, // bit offset: 30 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
        EPNDDINTST31: bool, // bit offset: 31 desc: Endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = There is no new DD interrupt request for endpoint xx. 1 = There is a new DD interrupt request for endpoint xx.
    });
    // byte offset: 688 USB New DD Request Interrupt Clear
    pub const NDDRINTCLR = mmio(Address + 0x000002b0, 32, packed struct {
        EPNDDINTCLR0: bool, // bit offset: 0 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR1: bool, // bit offset: 1 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR2: bool, // bit offset: 2 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR3: bool, // bit offset: 3 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR4: bool, // bit offset: 4 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR5: bool, // bit offset: 5 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR6: bool, // bit offset: 6 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR7: bool, // bit offset: 7 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR8: bool, // bit offset: 8 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR9: bool, // bit offset: 9 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR10: bool, // bit offset: 10 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR11: bool, // bit offset: 11 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR12: bool, // bit offset: 12 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR13: bool, // bit offset: 13 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR14: bool, // bit offset: 14 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR15: bool, // bit offset: 15 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR16: bool, // bit offset: 16 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR17: bool, // bit offset: 17 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR18: bool, // bit offset: 18 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR19: bool, // bit offset: 19 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR20: bool, // bit offset: 20 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR21: bool, // bit offset: 21 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR22: bool, // bit offset: 22 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR23: bool, // bit offset: 23 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR24: bool, // bit offset: 24 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR25: bool, // bit offset: 25 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR26: bool, // bit offset: 26 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR27: bool, // bit offset: 27 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR28: bool, // bit offset: 28 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR29: bool, // bit offset: 29 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR30: bool, // bit offset: 30 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTCLR31: bool, // bit offset: 31 desc: Clear endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Clear the EPxx new DD interrupt request in the USBNDDRIntSt register.
    });
    // byte offset: 692 USB New DD Request Interrupt Set
    pub const NDDRINTSET = mmio(Address + 0x000002b4, 32, packed struct {
        EPNDDINTSET0: bool, // bit offset: 0 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET1: bool, // bit offset: 1 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET2: bool, // bit offset: 2 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET3: bool, // bit offset: 3 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET4: bool, // bit offset: 4 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET5: bool, // bit offset: 5 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET6: bool, // bit offset: 6 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET7: bool, // bit offset: 7 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET8: bool, // bit offset: 8 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET9: bool, // bit offset: 9 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET10: bool, // bit offset: 10 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET11: bool, // bit offset: 11 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET12: bool, // bit offset: 12 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET13: bool, // bit offset: 13 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET14: bool, // bit offset: 14 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET15: bool, // bit offset: 15 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET16: bool, // bit offset: 16 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET17: bool, // bit offset: 17 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET18: bool, // bit offset: 18 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET19: bool, // bit offset: 19 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET20: bool, // bit offset: 20 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET21: bool, // bit offset: 21 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET22: bool, // bit offset: 22 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET23: bool, // bit offset: 23 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET24: bool, // bit offset: 24 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET25: bool, // bit offset: 25 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET26: bool, // bit offset: 26 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET27: bool, // bit offset: 27 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET28: bool, // bit offset: 28 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET29: bool, // bit offset: 29 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET30: bool, // bit offset: 30 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
        EPNDDINTSET31: bool, // bit offset: 31 desc: Set endpoint xx (2 <= xx <= 31) new DD interrupt request. 0 = No effect. 1 = Set the EPxx new DD interrupt request in the USBNDDRIntSt register.
    });
    // byte offset: 696 USB System Error Interrupt Status
    pub const SYSERRINTST = mmio(Address + 0x000002b8, 32, packed struct {
        EPERRINTST0: bool, // bit offset: 0 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST1: bool, // bit offset: 1 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST2: bool, // bit offset: 2 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST3: bool, // bit offset: 3 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST4: bool, // bit offset: 4 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST5: bool, // bit offset: 5 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST6: bool, // bit offset: 6 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST7: bool, // bit offset: 7 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST8: bool, // bit offset: 8 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST9: bool, // bit offset: 9 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST10: bool, // bit offset: 10 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST11: bool, // bit offset: 11 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST12: bool, // bit offset: 12 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST13: bool, // bit offset: 13 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST14: bool, // bit offset: 14 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST15: bool, // bit offset: 15 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST16: bool, // bit offset: 16 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST17: bool, // bit offset: 17 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST18: bool, // bit offset: 18 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST19: bool, // bit offset: 19 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST20: bool, // bit offset: 20 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST21: bool, // bit offset: 21 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST22: bool, // bit offset: 22 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST23: bool, // bit offset: 23 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST24: bool, // bit offset: 24 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST25: bool, // bit offset: 25 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST26: bool, // bit offset: 26 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST27: bool, // bit offset: 27 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST28: bool, // bit offset: 28 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST29: bool, // bit offset: 29 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST30: bool, // bit offset: 30 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
        EPERRINTST31: bool, // bit offset: 31 desc: Endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = There is no System Error Interrupt request for endpoint xx. 1 = There is a System Error Interrupt request for endpoint xx.
    });
    // byte offset: 700 USB System Error Interrupt Clear
    pub const SYSERRINTCLR = mmio(Address + 0x000002bc, 32, packed struct {
        EPERRINTCLR0: bool, // bit offset: 0 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR1: bool, // bit offset: 1 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR2: bool, // bit offset: 2 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR3: bool, // bit offset: 3 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR4: bool, // bit offset: 4 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR5: bool, // bit offset: 5 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR6: bool, // bit offset: 6 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR7: bool, // bit offset: 7 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR8: bool, // bit offset: 8 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR9: bool, // bit offset: 9 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR10: bool, // bit offset: 10 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR11: bool, // bit offset: 11 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR12: bool, // bit offset: 12 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR13: bool, // bit offset: 13 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR14: bool, // bit offset: 14 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR15: bool, // bit offset: 15 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR16: bool, // bit offset: 16 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR17: bool, // bit offset: 17 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR18: bool, // bit offset: 18 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR19: bool, // bit offset: 19 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR20: bool, // bit offset: 20 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR21: bool, // bit offset: 21 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR22: bool, // bit offset: 22 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR23: bool, // bit offset: 23 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR24: bool, // bit offset: 24 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR25: bool, // bit offset: 25 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR26: bool, // bit offset: 26 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR27: bool, // bit offset: 27 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR28: bool, // bit offset: 28 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR29: bool, // bit offset: 29 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR30: bool, // bit offset: 30 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTCLR31: bool, // bit offset: 31 desc: Clear endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Clear the EPxx System Error Interrupt request in the USBSysErrIntSt register.
    });
    // byte offset: 704 USB System Error Interrupt Set
    pub const SYSERRINTSET = mmio(Address + 0x000002c0, 32, packed struct {
        EPERRINTSET0: bool, // bit offset: 0 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET1: bool, // bit offset: 1 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET2: bool, // bit offset: 2 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET3: bool, // bit offset: 3 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET4: bool, // bit offset: 4 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET5: bool, // bit offset: 5 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET6: bool, // bit offset: 6 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET7: bool, // bit offset: 7 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET8: bool, // bit offset: 8 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET9: bool, // bit offset: 9 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET10: bool, // bit offset: 10 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET11: bool, // bit offset: 11 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET12: bool, // bit offset: 12 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET13: bool, // bit offset: 13 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET14: bool, // bit offset: 14 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET15: bool, // bit offset: 15 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET16: bool, // bit offset: 16 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET17: bool, // bit offset: 17 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET18: bool, // bit offset: 18 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET19: bool, // bit offset: 19 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET20: bool, // bit offset: 20 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET21: bool, // bit offset: 21 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET22: bool, // bit offset: 22 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET23: bool, // bit offset: 23 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET24: bool, // bit offset: 24 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET25: bool, // bit offset: 25 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET26: bool, // bit offset: 26 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET27: bool, // bit offset: 27 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET28: bool, // bit offset: 28 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET29: bool, // bit offset: 29 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET30: bool, // bit offset: 30 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
        EPERRINTSET31: bool, // bit offset: 31 desc: Set endpoint xx (2 <= xx <= 31) System Error Interrupt request. 0 = No effect. 1 = Set the EPxx System Error Interrupt request in the USBSysErrIntSt register.
    });
    // byte offset: 768 I2C Receive
    pub const I2C_RX = mmio(Address + 0x00000300, 32, packed struct {
        RXDATA: u8, // bit offset: 0 desc: Receive data.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 768 I2C Transmit
    pub const I2C_WO = mmio(Address + 0x00000300, 32, packed struct {
        TXDATA: u8, // bit offset: 0 desc: Transmit data.
        START: bool, // bit offset: 8 desc: When 1, issue a START condition before transmitting this byte.
        STOP: bool, // bit offset: 9 desc: When 1, issue a STOP condition after transmitting this byte.
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 772 I2C Status
    pub const I2C_STS = mmio(Address + 0x00000304, 32, packed struct {
        TDI: bool, // bit offset: 0 desc: Transaction Done Interrupt. This flag is set if a transaction completes successfully. It is cleared by writing a one to bit 0 of the status register. It is unaffected by slave transactions.
        AFI: bool, // bit offset: 1 desc: Arbitration Failure Interrupt. When transmitting, if the SDA is low when SDAOUT is high, then this I2C has lost the arbitration to another device on the bus. The Arbitration Failure bit is set when this happens. It is cleared by writing a one to bit 1 of the status register.
        NAI: bool, // bit offset: 2 desc: No Acknowledge Interrupt. After every byte of data is sent, the transmitter expects an acknowledge from the receiver. This bit is set if the acknowledge is not received. It is cleared when a byte is written to the master TX FIFO.
        DRMI: bool, // bit offset: 3 desc: Master Data Request Interrupt. Once a transmission is started, the transmitter must have data to transmit as long as it isn't followed by a stop condition or it will hold SCL low until more data is available. The Master Data Request bit is set when the master transmitter is data-starved. If the master TX FIFO is empty and the last byte did not have a STOP condition flag, then SCL is held low until the CPU writes another byte to transmit. This bit is cleared when a byte is written to the master TX FIFO.
        DRSI: bool, // bit offset: 4 desc: Slave Data Request Interrupt. Once a transmission is started, the transmitter must have data to transmit as long as it isn't followed by a STOP condition or it will hold SCL low until more data is available. The Slave Data Request bit is set when the slave transmitter is data-starved. If the slave TX FIFO is empty and the last byte transmitted was acknowledged, then SCL is held low until the CPU writes another byte to transmit. This bit is cleared when a byte is written to the slave Tx FIFO.
        Active: bool, // bit offset: 5 desc: Indicates whether the bus is busy. This bit is set when a START condition has been seen. It is cleared when a STOP condition is seen..
        SCL: bool, // bit offset: 6 desc: The current value of the SCL signal.
        SDA: bool, // bit offset: 7 desc: The current value of the SDA signal.
        RFF: bool, // bit offset: 8 desc: Receive FIFO Full (RFF). This bit is set when the RX FIFO is full and cannot accept any more data. It is cleared when the RX FIFO is not full. If a byte arrives when the Receive FIFO is full, the SCL is held low until the CPU reads the RX FIFO and makes room for it.
        RFE: bool, // bit offset: 9 desc: Receive FIFO Empty. RFE is set when the RX FIFO is empty and is cleared when the RX FIFO contains valid data.
        TFF: bool, // bit offset: 10 desc: Transmit FIFO Full. TFF is set when the TX FIFO is full and is cleared when the TX FIFO is not full.
        TFE: bool, // bit offset: 11 desc: Transmit FIFO Empty. TFE is set when the TX FIFO is empty and is cleared when the TX FIFO contains valid data.
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 776 I2C Control
    pub const I2C_CTL = mmio(Address + 0x00000308, 32, packed struct {
        TDIE: bool, // bit offset: 0 desc: Transmit Done Interrupt Enable. This enables the TDI interrupt signalling that this I2C issued a STOP condition.
        AFIE: bool, // bit offset: 1 desc: Transmitter Arbitration Failure Interrupt Enable. This enables the AFI interrupt which is asserted during transmission when trying to set SDA high, but the bus is driven low by another device.
        NAIE: bool, // bit offset: 2 desc: Transmitter No Acknowledge Interrupt Enable. This enables the NAI interrupt signalling that transmitted byte was not acknowledged.
        DRMIE: bool, // bit offset: 3 desc: Master Transmitter Data Request Interrupt Enable. This enables the DRMI interrupt which signals that the master transmitter has run out of data, has not issued a STOP, and is holding the SCL line low.
        DRSIE: bool, // bit offset: 4 desc: Slave Transmitter Data Request Interrupt Enable. This enables the DRSI interrupt which signals that the slave transmitter has run out of data and the last byte was acknowledged, so the SCL line is being held low.
        REFIE: bool, // bit offset: 5 desc: Receive FIFO Full Interrupt Enable. This enables the Receive FIFO Full interrupt to indicate that the receive FIFO cannot accept any more data.
        RFDAIE: bool, // bit offset: 6 desc: Receive Data Available Interrupt Enable. This enables the DAI interrupt to indicate that data is available in the receive FIFO (i.e. not empty).
        TFFIE: bool, // bit offset: 7 desc: Transmit FIFO Not Full Interrupt Enable. This enables the Transmit FIFO Not Full interrupt to indicate that the more data can be written to the transmit FIFO. Note that this is not full. It is intended help the CPU to write to the I2C block only when there is room in the FIFO and do this without polling the status register.
        SRST: bool, // bit offset: 8 desc: Soft reset. This is only needed in unusual circumstances. If a device issues a start condition without issuing a stop condition. A system timer may be used to reset the I2C if the bus remains busy longer than the time-out period. On a soft reset, the Tx and Rx FIFOs are flushed, I2C_STS register is cleared, and all internal state machines are reset to appear idle. The I2C_CLKHI, I2C_CLKLO and I2C_CTL (except Soft Reset Bit) are NOT modified by a soft reset.
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 780 I2C Clock High
    pub const I2C_CLKHI = mmio(Address + 0x0000030c, 32, packed struct {
        CDHI: u8, // bit offset: 0 desc: Clock divisor high. This value is the number of 48 MHz clocks the serial clock (SCL) will be high.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 784 I2C Clock Low
    pub const I2C_CLKLO = mmio(Address + 0x00000310, 32, packed struct {
        CDLO: u8, // bit offset: 0 desc: Clock divisor low. This value is the number of 48 MHz clocks the serial clock (SCL) will be low.
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4084 USB Clock Control
    pub const USBCLKCTRL = mmio(Address + 0x00000ff4, 32, packed struct {
        reserved1: u1 = 0,
        DEV_CLK_EN: bool, // bit offset: 1 desc: Device clock enable. Enables the usbclk input to the device controller
        reserved2: u1 = 0,
        PORTSEL_CLK_EN: bool, // bit offset: 3 desc: Port select register clock enable.
        AHB_CLK_EN: bool, // bit offset: 4 desc: AHB clock enable
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4084 OTG clock controller
    pub const OTGCLKCTRL = mmio(Address + 0x00000ff4, 32, packed struct {
        HOST_CLK_EN: bool, // bit offset: 0 desc: Host clock enable
        DEV_CLK_EN: bool, // bit offset: 1 desc: Device clock enable
        I2C_CLK_EN: bool, // bit offset: 2 desc: I2C clock enable
        OTG_CLK_EN: bool, // bit offset: 3 desc: OTG clock enable. In device-only applications, this bit enables access to the PORTSEL register.
        AHB_CLK_EN: bool, // bit offset: 4 desc: AHB master clock enable
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4088 USB Clock Status
    pub const USBCLKST = mmio(Address + 0x00000ff8, 32, packed struct {
        reserved1: u1 = 0,
        DEV_CLK_ON: bool, // bit offset: 1 desc: Device clock on. The usbclk input to the device controller is active .
        reserved2: u1 = 0,
        PORTSEL_CLK_ON: bool, // bit offset: 3 desc: Port select register clock on.
        AHB_CLK_ON: bool, // bit offset: 4 desc: AHB clock on.
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
    // byte offset: 4088 OTG clock status
    pub const OTGCLKST = mmio(Address + 0x00000ff8, 32, packed struct {
        HOST_CLK_ON: bool, // bit offset: 0 desc: Host clock status.
        DEV_CLK_ON: bool, // bit offset: 1 desc: Device clock status.
        I2C_CLK_ON: bool, // bit offset: 2 desc: I2C clock status.
        OTG_CLK_ON: bool, // bit offset: 3 desc: OTG clock status.
        AHB_CLK_ON: bool, // bit offset: 4 desc: AHB master clock status.
        padding27: u1 = 0,
        padding26: u1 = 0,
        padding25: u1 = 0,
        padding24: u1 = 0,
        padding23: u1 = 0,
        padding22: u1 = 0,
        padding21: u1 = 0,
        padding20: u1 = 0,
        padding19: u1 = 0,
        padding18: u1 = 0,
        padding17: u1 = 0,
        padding16: u1 = 0,
        padding15: u1 = 0,
        padding14: u1 = 0,
        padding13: u1 = 0,
        padding12: u1 = 0,
        padding11: u1 = 0,
        padding10: u1 = 0,
        padding9: u1 = 0,
        padding8: u1 = 0,
        padding7: u1 = 0,
        padding6: u1 = 0,
        padding5: u1 = 0,
        padding4: u1 = 0,
        padding3: u1 = 0,
        padding2: u1 = 0,
        padding1: u1 = 0,
    });
};
pub const GPIO = extern struct {
    pub const Address: u32 = 0x2009c000;
    // byte offset: 0 GPIO Port Direction control register.
    pub const DIR0 = mmio(Address + 0x00000000, 32, packed struct {
        PINDIR0: bool, // bit offset: 0 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR1: bool, // bit offset: 1 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR2: bool, // bit offset: 2 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR3: bool, // bit offset: 3 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR4: bool, // bit offset: 4 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR5: bool, // bit offset: 5 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR6: bool, // bit offset: 6 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR7: bool, // bit offset: 7 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR8: bool, // bit offset: 8 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR9: bool, // bit offset: 9 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR10: bool, // bit offset: 10 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR11: bool, // bit offset: 11 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR12: bool, // bit offset: 12 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR13: bool, // bit offset: 13 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR14: bool, // bit offset: 14 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR15: bool, // bit offset: 15 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR16: bool, // bit offset: 16 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR17: bool, // bit offset: 17 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR18: bool, // bit offset: 18 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR19: bool, // bit offset: 19 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR20: bool, // bit offset: 20 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR21: bool, // bit offset: 21 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR22: bool, // bit offset: 22 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR23: bool, // bit offset: 23 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR24: bool, // bit offset: 24 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR25: bool, // bit offset: 25 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR26: bool, // bit offset: 26 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR27: bool, // bit offset: 27 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR28: bool, // bit offset: 28 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR29: bool, // bit offset: 29 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR30: bool, // bit offset: 30 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR31: bool, // bit offset: 31 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
    });
    // byte offset: 16 Mask register for Port.
    pub const MASK0 = mmio(Address + 0x00000010, 32, packed struct {
        PINMASK0: bool, // bit offset: 0 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK1: bool, // bit offset: 1 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK2: bool, // bit offset: 2 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK3: bool, // bit offset: 3 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK4: bool, // bit offset: 4 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK5: bool, // bit offset: 5 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK6: bool, // bit offset: 6 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK7: bool, // bit offset: 7 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK8: bool, // bit offset: 8 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK9: bool, // bit offset: 9 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK10: bool, // bit offset: 10 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK11: bool, // bit offset: 11 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK12: bool, // bit offset: 12 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK13: bool, // bit offset: 13 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK14: bool, // bit offset: 14 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK15: bool, // bit offset: 15 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK16: bool, // bit offset: 16 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK17: bool, // bit offset: 17 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK18: bool, // bit offset: 18 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK19: bool, // bit offset: 19 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK20: bool, // bit offset: 20 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK21: bool, // bit offset: 21 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK22: bool, // bit offset: 22 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK23: bool, // bit offset: 23 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK24: bool, // bit offset: 24 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK25: bool, // bit offset: 25 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK26: bool, // bit offset: 26 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK27: bool, // bit offset: 27 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK28: bool, // bit offset: 28 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK29: bool, // bit offset: 29 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK30: bool, // bit offset: 30 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK31: bool, // bit offset: 31 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
    });
    // byte offset: 20 Port Pin value register using FIOMASK.
    pub const PIN0 = mmio(Address + 0x00000014, 32, packed struct {
        PINVAL0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 24 Port Output Set register using FIOMASK.
    pub const SET0 = mmio(Address + 0x00000018, 32, packed struct {
        PINSET0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 28 Port Output Clear register using FIOMASK.
    pub const CLR0 = mmio(Address + 0x0000001c, 32, packed struct {
        PINCLR0: bool, // bit offset: 0 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR1: bool, // bit offset: 1 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR2: bool, // bit offset: 2 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR3: bool, // bit offset: 3 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR4: bool, // bit offset: 4 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR5: bool, // bit offset: 5 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR6: bool, // bit offset: 6 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR7: bool, // bit offset: 7 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR8: bool, // bit offset: 8 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR9: bool, // bit offset: 9 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR10: bool, // bit offset: 10 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR11: bool, // bit offset: 11 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR12: bool, // bit offset: 12 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR13: bool, // bit offset: 13 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR14: bool, // bit offset: 14 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR15: bool, // bit offset: 15 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR16: bool, // bit offset: 16 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR17: bool, // bit offset: 17 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR18: bool, // bit offset: 18 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR19: bool, // bit offset: 19 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR20: bool, // bit offset: 20 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR21: bool, // bit offset: 21 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR22: bool, // bit offset: 22 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR23: bool, // bit offset: 23 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR24: bool, // bit offset: 24 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR25: bool, // bit offset: 25 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR26: bool, // bit offset: 26 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR27: bool, // bit offset: 27 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR28: bool, // bit offset: 28 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR29: bool, // bit offset: 29 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR30: bool, // bit offset: 30 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR31: bool, // bit offset: 31 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
    });
    // byte offset: 32 GPIO Port Direction control register.
    pub const DIR1 = mmio(Address + 0x00000020, 32, packed struct {
        PINDIR0: bool, // bit offset: 0 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR1: bool, // bit offset: 1 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR2: bool, // bit offset: 2 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR3: bool, // bit offset: 3 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR4: bool, // bit offset: 4 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR5: bool, // bit offset: 5 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR6: bool, // bit offset: 6 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR7: bool, // bit offset: 7 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR8: bool, // bit offset: 8 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR9: bool, // bit offset: 9 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR10: bool, // bit offset: 10 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR11: bool, // bit offset: 11 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR12: bool, // bit offset: 12 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR13: bool, // bit offset: 13 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR14: bool, // bit offset: 14 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR15: bool, // bit offset: 15 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR16: bool, // bit offset: 16 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR17: bool, // bit offset: 17 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR18: bool, // bit offset: 18 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR19: bool, // bit offset: 19 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR20: bool, // bit offset: 20 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR21: bool, // bit offset: 21 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR22: bool, // bit offset: 22 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR23: bool, // bit offset: 23 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR24: bool, // bit offset: 24 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR25: bool, // bit offset: 25 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR26: bool, // bit offset: 26 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR27: bool, // bit offset: 27 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR28: bool, // bit offset: 28 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR29: bool, // bit offset: 29 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR30: bool, // bit offset: 30 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR31: bool, // bit offset: 31 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
    });
    // byte offset: 48 Mask register for Port.
    pub const MASK1 = mmio(Address + 0x00000030, 32, packed struct {
        PINMASK0: bool, // bit offset: 0 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK1: bool, // bit offset: 1 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK2: bool, // bit offset: 2 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK3: bool, // bit offset: 3 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK4: bool, // bit offset: 4 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK5: bool, // bit offset: 5 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK6: bool, // bit offset: 6 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK7: bool, // bit offset: 7 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK8: bool, // bit offset: 8 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK9: bool, // bit offset: 9 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK10: bool, // bit offset: 10 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK11: bool, // bit offset: 11 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK12: bool, // bit offset: 12 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK13: bool, // bit offset: 13 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK14: bool, // bit offset: 14 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK15: bool, // bit offset: 15 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK16: bool, // bit offset: 16 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK17: bool, // bit offset: 17 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK18: bool, // bit offset: 18 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK19: bool, // bit offset: 19 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK20: bool, // bit offset: 20 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK21: bool, // bit offset: 21 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK22: bool, // bit offset: 22 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK23: bool, // bit offset: 23 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK24: bool, // bit offset: 24 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK25: bool, // bit offset: 25 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK26: bool, // bit offset: 26 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK27: bool, // bit offset: 27 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK28: bool, // bit offset: 28 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK29: bool, // bit offset: 29 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK30: bool, // bit offset: 30 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK31: bool, // bit offset: 31 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
    });
    // byte offset: 52 Port Pin value register using FIOMASK.
    pub const PIN1 = mmio(Address + 0x00000034, 32, packed struct {
        PINVAL0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 56 Port Output Set register using FIOMASK.
    pub const SET1 = mmio(Address + 0x00000038, 32, packed struct {
        PINSET0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 60 Port Output Clear register using FIOMASK.
    pub const CLR1 = mmio(Address + 0x0000003c, 32, packed struct {
        PINCLR0: bool, // bit offset: 0 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR1: bool, // bit offset: 1 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR2: bool, // bit offset: 2 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR3: bool, // bit offset: 3 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR4: bool, // bit offset: 4 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR5: bool, // bit offset: 5 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR6: bool, // bit offset: 6 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR7: bool, // bit offset: 7 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR8: bool, // bit offset: 8 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR9: bool, // bit offset: 9 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR10: bool, // bit offset: 10 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR11: bool, // bit offset: 11 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR12: bool, // bit offset: 12 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR13: bool, // bit offset: 13 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR14: bool, // bit offset: 14 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR15: bool, // bit offset: 15 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR16: bool, // bit offset: 16 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR17: bool, // bit offset: 17 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR18: bool, // bit offset: 18 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR19: bool, // bit offset: 19 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR20: bool, // bit offset: 20 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR21: bool, // bit offset: 21 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR22: bool, // bit offset: 22 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR23: bool, // bit offset: 23 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR24: bool, // bit offset: 24 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR25: bool, // bit offset: 25 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR26: bool, // bit offset: 26 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR27: bool, // bit offset: 27 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR28: bool, // bit offset: 28 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR29: bool, // bit offset: 29 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR30: bool, // bit offset: 30 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR31: bool, // bit offset: 31 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
    });
    // byte offset: 64 GPIO Port Direction control register.
    pub const DIR2 = mmio(Address + 0x00000040, 32, packed struct {
        PINDIR0: bool, // bit offset: 0 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR1: bool, // bit offset: 1 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR2: bool, // bit offset: 2 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR3: bool, // bit offset: 3 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR4: bool, // bit offset: 4 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR5: bool, // bit offset: 5 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR6: bool, // bit offset: 6 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR7: bool, // bit offset: 7 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR8: bool, // bit offset: 8 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR9: bool, // bit offset: 9 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR10: bool, // bit offset: 10 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR11: bool, // bit offset: 11 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR12: bool, // bit offset: 12 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR13: bool, // bit offset: 13 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR14: bool, // bit offset: 14 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR15: bool, // bit offset: 15 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR16: bool, // bit offset: 16 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR17: bool, // bit offset: 17 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR18: bool, // bit offset: 18 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR19: bool, // bit offset: 19 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR20: bool, // bit offset: 20 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR21: bool, // bit offset: 21 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR22: bool, // bit offset: 22 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR23: bool, // bit offset: 23 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR24: bool, // bit offset: 24 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR25: bool, // bit offset: 25 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR26: bool, // bit offset: 26 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR27: bool, // bit offset: 27 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR28: bool, // bit offset: 28 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR29: bool, // bit offset: 29 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR30: bool, // bit offset: 30 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR31: bool, // bit offset: 31 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
    });
    // byte offset: 80 Mask register for Port.
    pub const MASK2 = mmio(Address + 0x00000050, 32, packed struct {
        PINMASK0: bool, // bit offset: 0 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK1: bool, // bit offset: 1 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK2: bool, // bit offset: 2 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK3: bool, // bit offset: 3 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK4: bool, // bit offset: 4 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK5: bool, // bit offset: 5 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK6: bool, // bit offset: 6 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK7: bool, // bit offset: 7 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK8: bool, // bit offset: 8 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK9: bool, // bit offset: 9 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK10: bool, // bit offset: 10 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK11: bool, // bit offset: 11 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK12: bool, // bit offset: 12 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK13: bool, // bit offset: 13 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK14: bool, // bit offset: 14 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK15: bool, // bit offset: 15 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK16: bool, // bit offset: 16 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK17: bool, // bit offset: 17 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK18: bool, // bit offset: 18 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK19: bool, // bit offset: 19 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK20: bool, // bit offset: 20 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK21: bool, // bit offset: 21 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK22: bool, // bit offset: 22 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK23: bool, // bit offset: 23 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK24: bool, // bit offset: 24 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK25: bool, // bit offset: 25 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK26: bool, // bit offset: 26 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK27: bool, // bit offset: 27 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK28: bool, // bit offset: 28 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK29: bool, // bit offset: 29 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK30: bool, // bit offset: 30 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK31: bool, // bit offset: 31 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
    });
    // byte offset: 84 Port Pin value register using FIOMASK.
    pub const PIN2 = mmio(Address + 0x00000054, 32, packed struct {
        PINVAL0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 88 Port Output Set register using FIOMASK.
    pub const SET2 = mmio(Address + 0x00000058, 32, packed struct {
        PINSET0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 92 Port Output Clear register using FIOMASK.
    pub const CLR2 = mmio(Address + 0x0000005c, 32, packed struct {
        PINCLR0: bool, // bit offset: 0 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR1: bool, // bit offset: 1 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR2: bool, // bit offset: 2 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR3: bool, // bit offset: 3 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR4: bool, // bit offset: 4 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR5: bool, // bit offset: 5 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR6: bool, // bit offset: 6 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR7: bool, // bit offset: 7 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR8: bool, // bit offset: 8 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR9: bool, // bit offset: 9 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR10: bool, // bit offset: 10 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR11: bool, // bit offset: 11 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR12: bool, // bit offset: 12 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR13: bool, // bit offset: 13 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR14: bool, // bit offset: 14 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR15: bool, // bit offset: 15 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR16: bool, // bit offset: 16 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR17: bool, // bit offset: 17 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR18: bool, // bit offset: 18 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR19: bool, // bit offset: 19 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR20: bool, // bit offset: 20 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR21: bool, // bit offset: 21 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR22: bool, // bit offset: 22 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR23: bool, // bit offset: 23 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR24: bool, // bit offset: 24 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR25: bool, // bit offset: 25 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR26: bool, // bit offset: 26 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR27: bool, // bit offset: 27 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR28: bool, // bit offset: 28 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR29: bool, // bit offset: 29 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR30: bool, // bit offset: 30 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR31: bool, // bit offset: 31 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
    });
    // byte offset: 96 GPIO Port Direction control register.
    pub const DIR3 = mmio(Address + 0x00000060, 32, packed struct {
        PINDIR0: bool, // bit offset: 0 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR1: bool, // bit offset: 1 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR2: bool, // bit offset: 2 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR3: bool, // bit offset: 3 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR4: bool, // bit offset: 4 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR5: bool, // bit offset: 5 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR6: bool, // bit offset: 6 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR7: bool, // bit offset: 7 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR8: bool, // bit offset: 8 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR9: bool, // bit offset: 9 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR10: bool, // bit offset: 10 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR11: bool, // bit offset: 11 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR12: bool, // bit offset: 12 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR13: bool, // bit offset: 13 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR14: bool, // bit offset: 14 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR15: bool, // bit offset: 15 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR16: bool, // bit offset: 16 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR17: bool, // bit offset: 17 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR18: bool, // bit offset: 18 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR19: bool, // bit offset: 19 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR20: bool, // bit offset: 20 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR21: bool, // bit offset: 21 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR22: bool, // bit offset: 22 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR23: bool, // bit offset: 23 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR24: bool, // bit offset: 24 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR25: bool, // bit offset: 25 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR26: bool, // bit offset: 26 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR27: bool, // bit offset: 27 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR28: bool, // bit offset: 28 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR29: bool, // bit offset: 29 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR30: bool, // bit offset: 30 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR31: bool, // bit offset: 31 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
    });
    // byte offset: 112 Mask register for Port.
    pub const MASK3 = mmio(Address + 0x00000070, 32, packed struct {
        PINMASK0: bool, // bit offset: 0 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK1: bool, // bit offset: 1 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK2: bool, // bit offset: 2 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK3: bool, // bit offset: 3 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK4: bool, // bit offset: 4 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK5: bool, // bit offset: 5 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK6: bool, // bit offset: 6 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK7: bool, // bit offset: 7 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK8: bool, // bit offset: 8 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK9: bool, // bit offset: 9 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK10: bool, // bit offset: 10 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK11: bool, // bit offset: 11 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK12: bool, // bit offset: 12 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK13: bool, // bit offset: 13 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK14: bool, // bit offset: 14 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK15: bool, // bit offset: 15 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK16: bool, // bit offset: 16 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK17: bool, // bit offset: 17 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK18: bool, // bit offset: 18 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK19: bool, // bit offset: 19 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK20: bool, // bit offset: 20 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK21: bool, // bit offset: 21 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK22: bool, // bit offset: 22 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK23: bool, // bit offset: 23 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK24: bool, // bit offset: 24 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK25: bool, // bit offset: 25 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK26: bool, // bit offset: 26 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK27: bool, // bit offset: 27 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK28: bool, // bit offset: 28 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK29: bool, // bit offset: 29 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK30: bool, // bit offset: 30 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK31: bool, // bit offset: 31 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
    });
    // byte offset: 116 Port Pin value register using FIOMASK.
    pub const PIN3 = mmio(Address + 0x00000074, 32, packed struct {
        PINVAL0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 120 Port Output Set register using FIOMASK.
    pub const SET3 = mmio(Address + 0x00000078, 32, packed struct {
        PINSET0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 124 Port Output Clear register using FIOMASK.
    pub const CLR3 = mmio(Address + 0x0000007c, 32, packed struct {
        PINCLR0: bool, // bit offset: 0 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR1: bool, // bit offset: 1 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR2: bool, // bit offset: 2 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR3: bool, // bit offset: 3 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR4: bool, // bit offset: 4 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR5: bool, // bit offset: 5 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR6: bool, // bit offset: 6 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR7: bool, // bit offset: 7 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR8: bool, // bit offset: 8 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR9: bool, // bit offset: 9 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR10: bool, // bit offset: 10 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR11: bool, // bit offset: 11 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR12: bool, // bit offset: 12 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR13: bool, // bit offset: 13 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR14: bool, // bit offset: 14 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR15: bool, // bit offset: 15 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR16: bool, // bit offset: 16 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR17: bool, // bit offset: 17 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR18: bool, // bit offset: 18 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR19: bool, // bit offset: 19 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR20: bool, // bit offset: 20 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR21: bool, // bit offset: 21 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR22: bool, // bit offset: 22 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR23: bool, // bit offset: 23 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR24: bool, // bit offset: 24 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR25: bool, // bit offset: 25 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR26: bool, // bit offset: 26 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR27: bool, // bit offset: 27 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR28: bool, // bit offset: 28 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR29: bool, // bit offset: 29 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR30: bool, // bit offset: 30 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR31: bool, // bit offset: 31 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
    });
    // byte offset: 128 GPIO Port Direction control register.
    pub const DIR4 = mmio(Address + 0x00000080, 32, packed struct {
        PINDIR0: bool, // bit offset: 0 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR1: bool, // bit offset: 1 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR2: bool, // bit offset: 2 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR3: bool, // bit offset: 3 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR4: bool, // bit offset: 4 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR5: bool, // bit offset: 5 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR6: bool, // bit offset: 6 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR7: bool, // bit offset: 7 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR8: bool, // bit offset: 8 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR9: bool, // bit offset: 9 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR10: bool, // bit offset: 10 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR11: bool, // bit offset: 11 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR12: bool, // bit offset: 12 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR13: bool, // bit offset: 13 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR14: bool, // bit offset: 14 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR15: bool, // bit offset: 15 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR16: bool, // bit offset: 16 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR17: bool, // bit offset: 17 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR18: bool, // bit offset: 18 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR19: bool, // bit offset: 19 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR20: bool, // bit offset: 20 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR21: bool, // bit offset: 21 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR22: bool, // bit offset: 22 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR23: bool, // bit offset: 23 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR24: bool, // bit offset: 24 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR25: bool, // bit offset: 25 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR26: bool, // bit offset: 26 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR27: bool, // bit offset: 27 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR28: bool, // bit offset: 28 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR29: bool, // bit offset: 29 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR30: bool, // bit offset: 30 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
        PINDIR31: bool, // bit offset: 31 desc: Fast GPIO Direction PORTx control bits. Bit 0 in DIRx controls pin Px[0], bit 31 in DIRx controls pin Px[31]. 0 = Controlled pin is input. 1 = Controlled pin is output.
    });
    // byte offset: 144 Mask register for Port.
    pub const MASK4 = mmio(Address + 0x00000090, 32, packed struct {
        PINMASK0: bool, // bit offset: 0 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK1: bool, // bit offset: 1 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK2: bool, // bit offset: 2 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK3: bool, // bit offset: 3 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK4: bool, // bit offset: 4 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK5: bool, // bit offset: 5 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK6: bool, // bit offset: 6 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK7: bool, // bit offset: 7 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK8: bool, // bit offset: 8 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK9: bool, // bit offset: 9 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK10: bool, // bit offset: 10 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK11: bool, // bit offset: 11 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK12: bool, // bit offset: 12 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK13: bool, // bit offset: 13 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK14: bool, // bit offset: 14 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK15: bool, // bit offset: 15 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK16: bool, // bit offset: 16 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK17: bool, // bit offset: 17 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK18: bool, // bit offset: 18 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK19: bool, // bit offset: 19 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK20: bool, // bit offset: 20 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK21: bool, // bit offset: 21 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK22: bool, // bit offset: 22 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK23: bool, // bit offset: 23 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK24: bool, // bit offset: 24 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK25: bool, // bit offset: 25 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK26: bool, // bit offset: 26 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK27: bool, // bit offset: 27 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK28: bool, // bit offset: 28 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK29: bool, // bit offset: 29 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK30: bool, // bit offset: 30 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
        PINMASK31: bool, // bit offset: 31 desc: Fast GPIO physical pin access control. 0 = Controlled pin is affected by writes to the port's SETx, CLRx, and PINx register(s). Current state of the pin can be read from the PINx register. 1 = Controlled pin is not affected by writes into the port's SETx, CLRx and PINx register(s). When the PINx register is read, this bit will not be updated with the state of the physical pin.
    });
    // byte offset: 148 Port Pin value register using FIOMASK.
    pub const PIN4 = mmio(Address + 0x00000094, 32, packed struct {
        PINVAL0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
        PINVAL31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in PINx corresponds to pin Px[0], bit 31 in PINx corresponds to pin Px[31]. 0 = Controlled pin output is set to LOW. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 152 Port Output Set register using FIOMASK.
    pub const SET4 = mmio(Address + 0x00000098, 32, packed struct {
        PINSET0: bool, // bit offset: 0 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET1: bool, // bit offset: 1 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET2: bool, // bit offset: 2 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET3: bool, // bit offset: 3 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET4: bool, // bit offset: 4 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET5: bool, // bit offset: 5 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET6: bool, // bit offset: 6 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET7: bool, // bit offset: 7 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET8: bool, // bit offset: 8 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET9: bool, // bit offset: 9 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET10: bool, // bit offset: 10 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET11: bool, // bit offset: 11 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET12: bool, // bit offset: 12 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET13: bool, // bit offset: 13 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET14: bool, // bit offset: 14 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET15: bool, // bit offset: 15 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET16: bool, // bit offset: 16 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET17: bool, // bit offset: 17 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET18: bool, // bit offset: 18 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET19: bool, // bit offset: 19 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET20: bool, // bit offset: 20 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET21: bool, // bit offset: 21 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET22: bool, // bit offset: 22 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET23: bool, // bit offset: 23 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET24: bool, // bit offset: 24 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET25: bool, // bit offset: 25 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET26: bool, // bit offset: 26 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET27: bool, // bit offset: 27 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET28: bool, // bit offset: 28 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET29: bool, // bit offset: 29 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET30: bool, // bit offset: 30 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
        PINSET31: bool, // bit offset: 31 desc: Fast GPIO output value Set bits. Bit 0 in SETx controls pin Px[0], bit 31 in SETx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to HIGH.
    });
    // byte offset: 156 Port Output Clear register using FIOMASK.
    pub const CLR4 = mmio(Address + 0x0000009c, 32, packed struct {
        PINCLR0: bool, // bit offset: 0 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR1: bool, // bit offset: 1 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR2: bool, // bit offset: 2 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR3: bool, // bit offset: 3 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR4: bool, // bit offset: 4 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR5: bool, // bit offset: 5 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR6: bool, // bit offset: 6 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR7: bool, // bit offset: 7 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR8: bool, // bit offset: 8 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR9: bool, // bit offset: 9 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR10: bool, // bit offset: 10 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR11: bool, // bit offset: 11 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR12: bool, // bit offset: 12 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR13: bool, // bit offset: 13 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR14: bool, // bit offset: 14 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR15: bool, // bit offset: 15 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR16: bool, // bit offset: 16 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR17: bool, // bit offset: 17 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR18: bool, // bit offset: 18 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR19: bool, // bit offset: 19 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR20: bool, // bit offset: 20 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR21: bool, // bit offset: 21 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR22: bool, // bit offset: 22 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR23: bool, // bit offset: 23 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR24: bool, // bit offset: 24 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR25: bool, // bit offset: 25 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR26: bool, // bit offset: 26 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR27: bool, // bit offset: 27 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR28: bool, // bit offset: 28 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR29: bool, // bit offset: 29 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR30: bool, // bit offset: 30 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
        PINCLR31: bool, // bit offset: 31 desc: Fast GPIO output value Clear bits. Bit 0 in CLRx controls pin Px[0], bit 31 in CLRx controls pin Px[31]. 0 = Controlled pin output is unchanged. 1 = Controlled pin output is set to LOW.
    });
};

